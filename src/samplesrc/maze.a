; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; samplesrc/maze.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; samplesrc/maze.pla: 0001: 
; samplesrc/maze.pla: 0002: include "inc/conio.plh"
; inc/conio.plh: 0001: import conio
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
					; CONIO -> X028
; inc/conio.plh: 0002:     //
; inc/conio.plh: 0003:     // ASCII key values
; inc/conio.plh: 0004:     //
; inc/conio.plh: 0005:     const keyarrowdown  = $0A
					; keyarrowdown = 10
; inc/conio.plh: 0006:     const keyarrowup    = $0B
					; keyarrowup = 11
; inc/conio.plh: 0007:     const keyarrowleft  = $08
					; keyarrowleft = 8
; inc/conio.plh: 0008:     const keyarrowright = $15
					; keyarrowright = 21
; inc/conio.plh: 0009:     const keyenter      = $0D
					; keyenter = 13
; inc/conio.plh: 0010:     const keyescape     = $1B
					; keyescape = 27
; inc/conio.plh: 0011:     const keyctrla      = $01
					; keyctrla = 1
; inc/conio.plh: 0012:     const keyctrlb      = $02
					; keyctrlb = 2
; inc/conio.plh: 0013:     const keyctrlc      = $03
					; keyctrlc = 3
; inc/conio.plh: 0014:     const keyctrld      = $04
					; keyctrld = 4
; inc/conio.plh: 0015:     const keyctrle      = $05
					; keyctrle = 5
; inc/conio.plh: 0016:     const keyctrlf      = $06
					; keyctrlf = 6
; inc/conio.plh: 0017:     const keyctrlg      = $07
					; keyctrlg = 7
; inc/conio.plh: 0018:     const keyctrli      = $09
					; keyctrli = 9
; inc/conio.plh: 0019:     const keyctrlk      = $0B
					; keyctrlk = 11
; inc/conio.plh: 0020:     const keyctrll      = $0C
					; keyctrll = 12
; inc/conio.plh: 0021:     const keyctrln      = $0E
					; keyctrln = 14
; inc/conio.plh: 0022:     const keyctrlo      = $0F
					; keyctrlo = 15
; inc/conio.plh: 0023:     const keyctrlp      = $10
					; keyctrlp = 16
; inc/conio.plh: 0024:     const keyctrlq      = $11
					; keyctrlq = 17
; inc/conio.plh: 0025:     const keyctrlr      = $12
					; keyctrlr = 18
; inc/conio.plh: 0026:     const keyctrls      = $13
					; keyctrls = 19
; inc/conio.plh: 0027:     const keyctrlt      = $14
					; keyctrlt = 20
; inc/conio.plh: 0028:     const keyctrlu      = $15
					; keyctrlu = 21
; inc/conio.plh: 0029:     const keyctrlv      = $16
					; keyctrlv = 22
; inc/conio.plh: 0030:     const keyctrlw      = $17
					; keyctrlw = 23
; inc/conio.plh: 0031:     const keyctrlx      = $18
					; keyctrlx = 24
; inc/conio.plh: 0032:     const keyctrly      = $19
					; keyctrly = 25
; inc/conio.plh: 0033:     const keyctrlz      = $1A
					; keyctrlz = 26
; inc/conio.plh: 0034:     const keytab        = keyctrli
					; keytab = 9
; inc/conio.plh: 0035:     const keydetab      = $1D
					; keydetab = 29
; inc/conio.plh: 0036:     const keyspace      = $20
					; keyspace = 32
; inc/conio.plh: 0037:     const keydelete     = $7F
					; keydelete = 127
; inc/conio.plh: 0038:     //
; inc/conio.plh: 0039:     // Option/Solid-Apple key modifier
; inc/conio.plh: 0040:     //
; inc/conio.plh: 0041:     const keyoptmod     = $80
					; keyoptmod = 128
; inc/conio.plh: 0042:     //
; inc/conio.plh: 0043:     // Clear optioms
; inc/conio.plh: 0044:     //
; inc/conio.plh: 0045:     const cleol         = 1
					; cleol = 1
; inc/conio.plh: 0046:     const cleos         = 2
					; cleos = 2
; inc/conio.plh: 0047:     const cls           = 3
					; cls = 3
; inc/conio.plh: 0048:     //
; inc/conio.plh: 0049:     // Control Codes
; inc/conio.plh: 0050:     //
; inc/conio.plh: 0051:     const ctrlattr      = 1
					; ctrlattr = 1
; inc/conio.plh: 0052:     const ctrlecho      = 2
					; ctrlecho = 2
; inc/conio.plh: 0053:     const ctrlcursor    = 3
					; ctrlcursor = 3
; inc/conio.plh: 0054:     const ctrlcase      = 4
					; ctrlcase = 4
; inc/conio.plh: 0055:     const ctrlscroll    = 5
					; ctrlscroll = 5
; inc/conio.plh: 0056:     //
; inc/conio.plh: 0057:     // Control parameters
; inc/conio.plh: 0058:     //
; inc/conio.plh: 0059:     const OFF           = 0
					; OFF = 0
; inc/conio.plh: 0060:     const ON            = 1
					; ON = 1
; inc/conio.plh: 0061:     const NORMAL        = $FF
					; NORMAL = 255
; inc/conio.plh: 0062:     const INVERSE       = $3F
					; INVERSE = 63
; inc/conio.plh: 0063:     const FLASH         = $7F
					; FLASH = 127
; inc/conio.plh: 0064:     const UP            = 1
					; UP = 1
; inc/conio.plh: 0065:     const DOWN          = -1
					; DOWN = -1
; inc/conio.plh: 0066:     //
; inc/conio.plh: 0067:     // Additional modes available on VIDEX UltraTerm
; inc/conio.plh: 0068:     //
; inc/conio.plh: 0069:     const UTmode80x24   = 1
					; UTmode80x24 = 1
; inc/conio.plh: 0070:     const UTmode96x24   = 2
					; UTmode96x24 = 2
; inc/conio.plh: 0071:     const UTmode160x24  = 3
					; UTmode160x24 = 3
; inc/conio.plh: 0072:     const UTmode80x24I  = 4
					; UTmode80x24I = 4
; inc/conio.plh: 0073:     const UTmode80x32I  = 5
					; UTmode80x32I = 5
; inc/conio.plh: 0074:     const UTmode80x48I  = 6
					; UTmode80x48I = 6
; inc/conio.plh: 0075:     const UTmode132x24I = 7
					; UTmode132x24I = 7
; inc/conio.plh: 0076:     const UTmode128x32I = 8
					; UTmode128x32I = 8
; inc/conio.plh: 0077:     //
; inc/conio.plh: 0078:     // API
; inc/conio.plh: 0079:     //
; inc/conio.plh: 0080:     struc t_conio
; inc/conio.plh: 0081:         word keypressed
					; keypressed = 0
; inc/conio.plh: 0082:         word getkey
					; getkey = 2
; inc/conio.plh: 0083:         word putchars
					; putchars = 4
; inc/conio.plh: 0084:         word clear
					; clear = 6
; inc/conio.plh: 0085:         word gotoxy
					; gotoxy = 8
; inc/conio.plh: 0086:         word viewport
					; viewport = 10
; inc/conio.plh: 0087:         word textctrl
					; textctrl = 12
; inc/conio.plh: 0088:         word textmode
					; textmode = 14
; inc/conio.plh: 0089:         word grmode
					; grmode = 16
; inc/conio.plh: 0090:         word grcolor
					; grcolor = 18
; inc/conio.plh: 0091:         word grplot
					; grplot = 20
; inc/conio.plh: 0092:         word tone
					; tone = 22
; inc/conio.plh: 0093:         word rnd
					; rnd = 24
; inc/conio.plh: 0094:     end
					; t_conio = 26
; inc/conio.plh: 0095: end
; samplesrc/maze.pla: 0002: 
; samplesrc/maze.pla: 0003: include "inc/args.plh"
; inc/args.plh: 0001: import args
	; DCI STRING: ARGS
	!BYTE	$C1,$D2,$C7,$53
					; ARGS -> X029
; inc/args.plh: 0002:     predef  argFirst, argNext(str)
					; ARGFIRST -> X030
					; ARGNEXT -> X031
; inc/args.plh: 0003: end
; samplesrc/maze.pla: 0003: 
; samplesrc/maze.pla: 0004: include "inc/int32.plh"
; inc/int32.plh: 0001: import int32
	; DCI STRING: INT32
	!BYTE	$C9,$CE,$D4,$B3,$32
					; INT32 -> X032
; inc/int32.plh: 0002:     const t_i32 = 4
					; t_i32 = 4
; inc/int32.plh: 0003:     
; inc/int32.plh: 0004:     predef zero32#0
					; ZERO32 -> X033
; inc/int32.plh: 0005:     predef zext16to32#0
					; ZEXT16TO32 -> X034
; inc/int32.plh: 0006:     predef neg32#0
					; NEG32 -> X035
; inc/int32.plh: 0007:     predef load32(i32ptr)#0
					; LOAD32 -> X036
; inc/int32.plh: 0008:     predef loadi16(imm16)#0
					; LOADI16 -> X037
; inc/int32.plh: 0009:     predef store32(i32ptr)#0
					; STORE32 -> X038
; inc/int32.plh: 0010:     predef add32(i32ptr)#0
					; ADD32 -> X039
; inc/int32.plh: 0011:     predef addi16(imm16)#0
					; ADDI16 -> X040
; inc/int32.plh: 0012:     predef sub32(i32ptr)#0
					; SUB32 -> X041
; inc/int32.plh: 0013:     predef subi16(imm16)#0
					; SUBI16 -> X042
; inc/int32.plh: 0014:     predef shl32(imm8)#0
					; SHL32 -> X043
; inc/int32.plh: 0015:     predef shr32(imm8)#0
					; SHR32 -> X044
; inc/int32.plh: 0016:     predef mul32(i32ptr)#0
					; MUL32 -> X045
; inc/int32.plh: 0017:     predef muli16(imm16)#0
					; MULI16 -> X046
; inc/int32.plh: 0018:     predef div32(i32ptr)#2
					; DIV32 -> X047
; inc/int32.plh: 0019:     predef divi16(imm16)#2
					; DIVI16 -> X048
; inc/int32.plh: 0020:     predef iseq32(i32ptr)#1
					; ISEQ32 -> X049
; inc/int32.plh: 0021:     predef iseqi16(imm16)#1
					; ISEQI16 -> X050
; inc/int32.plh: 0022:     predef isge32(i32ptr)#1
					; ISGE32 -> X051
; inc/int32.plh: 0023:     predef isgei16(imm16)#1
					; ISGEI16 -> X052
; inc/int32.plh: 0024:     predef isle32(i32ptr)#1
					; ISLE32 -> X053
; inc/int32.plh: 0025:     predef islei16(imm16)#1
					; ISLEI16 -> X054
; inc/int32.plh: 0026:     predef isgt32(i32ptr)#1
					; ISGT32 -> X055
; inc/int32.plh: 0027:     predef isgti16(imm16)#1
					; ISGTI16 -> X056
; inc/int32.plh: 0028:     predef islt32(i32ptr)#1
					; ISLT32 -> X057
; inc/int32.plh: 0029:     predef islti16(imm16)#1
					; ISLTI16 -> X058
; inc/int32.plh: 0030:     predef i32tos(i32ptr, strptr)#1
					; I32TOS -> X059
; inc/int32.plh: 0031:     predef puti32(i32ptr)#0
					; PUTI32 -> X060
; inc/int32.plh: 0032: end
; samplesrc/maze.pla: 0004: 
; samplesrc/maze.pla: 0005: include "inc/hgrlib.plh"
; inc/hgrlib.plh: 0001: import hgrlib
	; DCI STRING: HGRLIB
	!BYTE	$C8,$C7,$D2,$CC,$C9,$42
					; HGRLIB -> X061
; inc/hgrlib.plh: 0002:     predef divmod7(x)#2
					; DIVMOD7 -> X062
; inc/hgrlib.plh: 0003:     predef hgrPlot(x, y)#0
					; HGRPLOT -> X063
; inc/hgrlib.plh: 0004:     predef hgrOrPlot(x, y)#0
					; HGRORPLOT -> X064
; inc/hgrlib.plh: 0005:     predef hgrXorPlot(x, y)#0
					; HGRXORPLOT -> X065
; inc/hgrlib.plh: 0006:     predef hgrHLin(x1, x2, y)#0
					; HGRHLIN -> X066
; inc/hgrlib.plh: 0007:     predef hgrVLin(y1, y2, x)#0
					; HGRVLIN -> X067
; inc/hgrlib.plh: 0008:     predef hgrXorHLin(x1, x2, y)#0
					; HGRXORHLIN -> X068
; inc/hgrlib.plh: 0009:     predef hgrXorVLin(y1, y2, x)#0
					; HGRXORVLIN -> X069
; inc/hgrlib.plh: 0010:     predef hgrRect(x1, y1, x2, y2)#0
					; HGRRECT -> X070
; inc/hgrlib.plh: 0011:     predef hgrXorRect(x1, y1, x2, y2)#0
					; HGRXORRECT -> X071
; inc/hgrlib.plh: 0012:     predef hgrBLT(x, y, width, height, srcptr)#0
					; HGRBLT -> X072
; inc/hgrlib.plh: 0013:     predef hgrCopySrc(ofst, y, w, h, srcptr)#0
					; HGRCOPYSRC -> X073
; inc/hgrlib.plh: 0014:     predef hgrAndSrc(ofst, y, w, h, srcptr)#0
					; HGRANDSRC -> X074
; inc/hgrlib.plh: 0015:     predef hgrXorSrc(ofst, y, w, h, srcptr)#0
					; HGRXORSRC -> X075
; inc/hgrlib.plh: 0016:     predef hgrOrSrc(ofst, y, w, h, srcptr)#0
					; HGRORSRC -> X076
; inc/hgrlib.plh: 0017:     predef hgrCopyDst(ofst, y, w, h, dstptr)#0
					; HGRCOPYDST -> X077
; inc/hgrlib.plh: 0018:     predef hgrMode(mode)#1
					; HGRMODE -> X078
; inc/hgrlib.plh: 0019:     predef hgrClear#0
					; HGRCLEAR -> X079
; inc/hgrlib.plh: 0020:     predef hgrShow(page)#1
					; HGRSHOW -> X080
; inc/hgrlib.plh: 0021:     predef hgrSwap#1
					; HGRSWAP -> X081
; inc/hgrlib.plh: 0022:     predef hgrDrawBuf(page)#1
					; HGRDRAWBUF -> X082
; inc/hgrlib.plh: 0023:     predef hgrColor(clr)#0
					; HGRCOLOR -> X083
; inc/hgrlib.plh: 0024:     const  hgrPage1 =  0
					; hgrPage1 = 0
; inc/hgrlib.plh: 0025:     const  hgrPage2 =  1
					; hgrPage2 = 1
; inc/hgrlib.plh: 0026:     const  hgrOff   = -1
					; hgrOff = -1
; inc/hgrlib.plh: 0027: end
; samplesrc/maze.pla: 0005: 
; samplesrc/maze.pla: 0006: include "inc/hgrtile.plh"
; inc/hgrtile.plh: 0001: import hgrtile
	; DCI STRING: HGRTILE
	!BYTE	$C8,$C7,$D2,$D4,$C9,$CC,$45
					; HGRTILE -> X084
; inc/hgrtile.plh: 0002:     predef tileDraw(x, y, tileptr)#0
					; TILEDRAW -> X085
; inc/hgrtile.plh: 0003:     predef tileXorDraw(x, y, tileptr)#0
					; TILEXORDRAW -> X086
; inc/hgrtile.plh: 0004:     predef tileOrDraw(x, y, tileptr)#0
					; TILEORDRAW -> X087
; inc/hgrtile.plh: 0005:     predef tileAndDraw(x, y, tileptr)#0
					; TILEANDDRAW -> X088
; inc/hgrtile.plh: 0006:     predef tileDrawStr(x, y, strptr, strlen, tileset)#0
					; TILEDRAWSTR -> X089
; inc/hgrtile.plh: 0007:     predef tileFromText(txtpage, tileset)#0
					; TILEFROMTEXT -> X090
; inc/hgrtile.plh: 0008:     predef tileDrawBuf(page)#1
					; TILEDRAWBUF -> X091
; inc/hgrtile.plh: 0009: end
; samplesrc/maze.pla: 0006: 
; samplesrc/maze.pla: 0007: sysflags reshgr1 // Reserve HGR page 1
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_SYSFLAGS	=	$0010		; SYSTEM FLAGS
; samplesrc/maze.pla: 0008: 
; samplesrc/maze.pla: 0009: const rndnum        = $4E // ZP location of RND
					; rndnum = 78
; samplesrc/maze.pla: 0010: const WALL_NONE     = 0
					; WALL_NONE = 0
; samplesrc/maze.pla: 0011: const WALL_TOP      = 1
					; WALL_TOP = 1
; samplesrc/maze.pla: 0012: const WALL_LEFT     = 2
					; WALL_LEFT = 2
; samplesrc/maze.pla: 0013: const DIR_UP        = 1
					; DIR_UP = 1
; samplesrc/maze.pla: 0014: const DIR_LEFT      = 2
					; DIR_LEFT = 2
; samplesrc/maze.pla: 0015: const DIR_DOWN      = 4
					; DIR_DOWN = 4
; samplesrc/maze.pla: 0016: const DIR_RIGHT     = 8
					; DIR_RIGHT = 8
; samplesrc/maze.pla: 0017: const CELL_TRACED   = 16
					; CELL_TRACED = 16
; samplesrc/maze.pla: 0018: const CELL_SOLVED   = 32
					; CELL_SOLVED = 32
; samplesrc/maze.pla: 0019: const CELL_VISITED  = 4
					; CELL_VISITED = 4
; samplesrc/maze.pla: 0020: const SEEN_TOP      = 8
					; SEEN_TOP = 8
; samplesrc/maze.pla: 0021: const SEEN_LEFT     = 16
					; SEEN_LEFT = 16
; samplesrc/maze.pla: 0022: const CELL_SEEN     = 32
					; CELL_SEEN = 32
; samplesrc/maze.pla: 0023: const MAZE_WIDTH    = 39
					; MAZE_WIDTH = 39
; samplesrc/maze.pla: 0024: const MAZE_HEIGHT   = 23
					; MAZE_HEIGHT = 23
; samplesrc/maze.pla: 0025: const PLAYER        = 8*8
					; PLAYER = 64
; samplesrc/maze.pla: 0026: //const CRUMB         = 5*8
; samplesrc/maze.pla: 0027: 
; samplesrc/maze.pla: 0028: byte mazeTileSet = $00, $00, $00, $00, $00, $00, $00, $00 // No walls
_D092 					; mazeTileSet = $00, $00, $00, $00, $00, $00, $00, $00 // No walls
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; samplesrc/maze.pla: 0029: byte             = $7F, $00, $00, $00, $00, $00, $00, $00 // Top wall
	!BYTE	$7F
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; samplesrc/maze.pla: 0030: byte             = $03, $03, $03, $03, $03, $03, $03, $03 // Left wall
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
; samplesrc/maze.pla: 0031: byte             = $7F, $03, $03, $03, $03, $03, $03, $03 // Top & Left walls
	!BYTE	$7F
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
; samplesrc/maze.pla: 0032: byte             = $00, $00, $00, $00, $08, $00, $00, $00 // No walls + crumb
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$08
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; samplesrc/maze.pla: 0033: byte             = $7F, $00, $00, $00, $08, $00, $00, $00 // Top wall + crumb
	!BYTE	$7F
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$08
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; samplesrc/maze.pla: 0034: byte             = $03, $03, $03, $03, $0B, $03, $03, $03 // Left wall + crumb
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$0B
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
; samplesrc/maze.pla: 0035: byte             = $7F, $03, $03, $03, $0B, $03, $03, $03 // Top & Left walls + crumb
	!BYTE	$7F
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
	!BYTE	$0B
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
; samplesrc/maze.pla: 0036: byte             = $00, $00, $10, $54, $54, $54, $10, $00 // Player
	!BYTE	$00
	!BYTE	$00
	!BYTE	$10
	!BYTE	$54
	!BYTE	$54
	!BYTE	$54
	!BYTE	$10
	!BYTE	$00
; samplesrc/maze.pla: 0037: //byte             = $00, $00, $00, $00, $08, $00, $00, $00 // Bread crumb
; samplesrc/maze.pla: 0038: 
; samplesrc/maze.pla: 0039: word maze[] = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
_D093 					; maze[] = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
	!WORD	$0400
	!WORD	$0480
	!WORD	$0500
	!WORD	$0580
	!WORD	$0600
	!WORD	$0680
	!WORD	$0700
	!WORD	$0780
; samplesrc/maze.pla: 0040: word        = $0428,$04A8,$0528,$05A8,$0628,$06A8,$0728,$07A8
	!WORD	$0428
	!WORD	$04A8
	!WORD	$0528
	!WORD	$05A8
	!WORD	$0628
	!WORD	$06A8
	!WORD	$0728
	!WORD	$07A8
; samplesrc/maze.pla: 0041: word        = $0450,$04D0,$0550,$05D0,$0650,$06D0,$0750,$07D0
	!WORD	$0450
	!WORD	$04D0
	!WORD	$0550
	!WORD	$05D0
	!WORD	$0650
	!WORD	$06D0
	!WORD	$0750
	!WORD	$07D0
; samplesrc/maze.pla: 0042: 
; samplesrc/maze.pla: 0043: word arg, seed, moveCnt
_D094 	!FILL	2			; arg, seed, moveCnt
_D095 	!FILL	2			; seed, moveCnt
_D096 	!FILL	2			; moveCnt
; samplesrc/maze.pla: 0044: byte entry, exit, solved
_D097 	!FILL	1			; entry, exit, solved
_D098 	!FILL	1			; exit, solved
_D099 	!FILL	1			; solved
; samplesrc/maze.pla: 0045: byte viewFlag = TRUE
_D100 					; viewFlag = TRUE
	!BYTE	$FF
; samplesrc/maze.pla: 0046: res[4] tics
_D101 	!FILL	4			; tics
; samplesrc/maze.pla: 0047: 
; samplesrc/maze.pla: 0048: def cellSetFlags(x, y, flags)#0
_SUBSEG 				; BYTECODE STARTS
					; x -> [0]
					; y -> [2]
					; flags -> [4]
_C000 					; cellSetFlags()
; samplesrc/maze.pla: 0049:     maze.[y, x] = maze.[y, x] | flags
	!BYTE	$58,$06,$03		; ENTER	6,3
; samplesrc/maze.pla: 0050: end
	!BYTE	$26			; LA	_D093+0
_F000 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$96			; OR 
	!BYTE	$26			; LA	_D093+0
_F001 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$70			; SB
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/maze.pla: 0051: 
; samplesrc/maze.pla: 0052: def cellClearFlags(x, y, flags)#0
					; x -> [0]
					; y -> [2]
					; flags -> [4]
_C001 					; cellClearFlags()
; samplesrc/maze.pla: 0053:     maze.[y, x] = maze.[y, x] & ~flags
	!BYTE	$58,$06,$03		; ENTER	6,3
; samplesrc/maze.pla: 0054: end
	!BYTE	$26			; LA	_D093+0
_F002 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$92			; COMP
	!BYTE	$94			; AND 
	!BYTE	$26			; LA	_D093+0
_F003 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$70			; SB
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/maze.pla: 0055: 
; samplesrc/maze.pla: 0056: def branchUp(x, y)
					; x -> [0]
					; y -> [2]
_C002 					; branchUp()
; samplesrc/maze.pla: 0057:     byte flags
					; flags -> [4]
; samplesrc/maze.pla: 0058: 
; samplesrc/maze.pla: 0059:     if y > 0
	!BYTE	$58,$05,$02		; ENTER	5,2
; samplesrc/maze.pla: 0060:         flags = maze.[y - 1, x]
; samplesrc/maze.pla: 0061:         if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0062:             cellClearFlags(x, y, WALL_TOP)
; samplesrc/maze.pla: 0063:             tileDraw(x, y, @mazeTileSet + 8 * (maze.[y, x] & 3))
; samplesrc/maze.pla: 0064:             return TRUE
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B001
	!WORD	_B001-*
	!BYTE	$26			; LA	_D093+0
_F004 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B003
	!WORD	_B003-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B003 
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C001
_F005 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F006 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F007 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F008 	!WORD	0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0065:         fin
_B004 
_B005 
; samplesrc/maze.pla: 0066:     fin
_B001 
_B002 
; samplesrc/maze.pla: 0067:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0068: end
; samplesrc/maze.pla: 0069: 
; samplesrc/maze.pla: 0070: def branchLeft(x, y)
					; x -> [0]
					; y -> [2]
_C003 					; branchLeft()
; samplesrc/maze.pla: 0071:     byte flags
					; flags -> [4]
; samplesrc/maze.pla: 0072:     
; samplesrc/maze.pla: 0073:     if x > 0
	!BYTE	$58,$05,$02		; ENTER	5,2
; samplesrc/maze.pla: 0074:         flags = maze.[y, x - 1]
; samplesrc/maze.pla: 0075:         if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0076:             cellClearFlags(x, y, WALL_LEFT)
; samplesrc/maze.pla: 0077:             tileDraw(x, y, @mazeTileSet + 8 * (maze.[y, x] & 3))
; samplesrc/maze.pla: 0078:             return TRUE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$26			; LA	_D093+0
_F009 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B008
	!WORD	_B008-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B008 
	!BYTE	$4C			; BRFLS	_B009
	!WORD	_B009-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C001
_F010 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F011 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F012 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F013 	!WORD	0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0079:         fin
_B009 
_B010 
; samplesrc/maze.pla: 0080:     fin
_B006 
_B007 
; samplesrc/maze.pla: 0081:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0082: end
; samplesrc/maze.pla: 0083: 
; samplesrc/maze.pla: 0084: def branchDown(x, y)
					; x -> [0]
					; y -> [2]
_C004 					; branchDown()
; samplesrc/maze.pla: 0085:     byte flags
					; flags -> [4]
; samplesrc/maze.pla: 0086:     
; samplesrc/maze.pla: 0087:     if y < MAZE_HEIGHT-1
	!BYTE	$58,$05,$02		; ENTER	5,2
; samplesrc/maze.pla: 0088:         flags = maze.[y + 1, x]
; samplesrc/maze.pla: 0089:         if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0090:             cellClearFlags(x, y + 1, WALL_TOP)
; samplesrc/maze.pla: 0091:             tileDraw(x, y + 1, @mazeTileSet + 8 * (maze.[y + 1, x] & 3))
; samplesrc/maze.pla: 0092:             return TRUE
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$16			; CB	22
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B011
	!WORD	_B011-*
	!BYTE	$26			; LA	_D093+0
_F014 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B013
	!WORD	_B013-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B013 
	!BYTE	$4C			; BRFLS	_B014
	!WORD	_B014-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C001
_F015 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$26			; LA	_D092+0
_F016 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F017 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F018 	!WORD	0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0093:         fin
_B014 
_B015 
; samplesrc/maze.pla: 0094:     fin
_B011 
_B012 
; samplesrc/maze.pla: 0095:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0096: end
; samplesrc/maze.pla: 0097: 
; samplesrc/maze.pla: 0098: def branchRight(x, y)
					; x -> [0]
					; y -> [2]
_C005 					; branchRight()
; samplesrc/maze.pla: 0099:     byte flags
					; flags -> [4]
; samplesrc/maze.pla: 0100:     
; samplesrc/maze.pla: 0101:     if x < MAZE_WIDTH-1
	!BYTE	$58,$05,$02		; ENTER	5,2
; samplesrc/maze.pla: 0102:         flags = maze.[y, x + 1]
; samplesrc/maze.pla: 0103:         if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0104:             cellClearFlags(x + 1, y, WALL_LEFT)
; samplesrc/maze.pla: 0105:             tileDraw(x + 1, y, @mazeTileSet + 8 * (maze.[y, x + 1] & 3))
; samplesrc/maze.pla: 0106:             return TRUE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$26			; CB	38
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B016
	!WORD	_B016-*
	!BYTE	$26			; LA	_D093+0
_F019 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B018
	!WORD	_B018-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B018 
	!BYTE	$4C			; BRFLS	_B019
	!WORD	_B019-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C001
_F020 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F021 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F022 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F023 	!WORD	0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0107:         fin
_B019 
_B020 
; samplesrc/maze.pla: 0108:     fin
_B016 
_B017 
; samplesrc/maze.pla: 0109:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0110: end
; samplesrc/maze.pla: 0111: 
; samplesrc/maze.pla: 0112: def branchNew(x, y)
					; x -> [0]
					; y -> [2]
_C006 					; branchNew()
; samplesrc/maze.pla: 0113:     byte flags, dir, cnt
					; flags -> [4]
					; dir -> [5]
					; cnt -> [6]
; samplesrc/maze.pla: 0114: 
; samplesrc/maze.pla: 0115:     cnt = 0
	!BYTE	$58,$07,$02		; ENTER	7,2
; samplesrc/maze.pla: 0116:     dir = 1 << (conio:rnd() & 3)
; samplesrc/maze.pla: 0117:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X028+24
_F024 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9A			; SHL
	!BYTE	$74,$05			; SLB	[5]
_B022 
; samplesrc/maze.pla: 0118:         when dir
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$52			; SEL
	!WORD	_B025-*
; samplesrc/maze.pla: 0119:             is DIR_UP
_B026 
; samplesrc/maze.pla: 0120:                 if y > 0
; samplesrc/maze.pla: 0121:                     flags = maze.[y - 1, x]
; samplesrc/maze.pla: 0122:                     if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0123:                         return DIR_UP
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B027
	!WORD	_B027-*
	!BYTE	$26			; LA	_D093+0
_F025 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B029
	!WORD	_B029-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B029 
	!BYTE	$4C			; BRFLS	_B030
	!WORD	_B030-*
	!BYTE	$02			; CN	1
	!BYTE	$5A,$07			; LEAVE	7
; samplesrc/maze.pla: 0124:                     fin
_B030 
_B031 
; samplesrc/maze.pla: 0125:                 fin
_B027 
_B028 
; samplesrc/maze.pla: 0126:                 dir = DIR_DOWN
; samplesrc/maze.pla: 0127:                 cnt++
	!BYTE	$08			; CN	4
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0128:                 break
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B024
	!WORD	_B024-*
; samplesrc/maze.pla: 0129:             is DIR_LEFT
_B032 
; samplesrc/maze.pla: 0130:                 if x > 0
; samplesrc/maze.pla: 0131:                     flags = maze.[y, x - 1]
; samplesrc/maze.pla: 0132:                     if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0133:                         return DIR_LEFT
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$26			; LA	_D093+0
_F026 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B035
	!WORD	_B035-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B035 
	!BYTE	$4C			; BRFLS	_B036
	!WORD	_B036-*
	!BYTE	$04			; CN	2
	!BYTE	$5A,$07			; LEAVE	7
; samplesrc/maze.pla: 0134:                     fin
_B036 
_B037 
; samplesrc/maze.pla: 0135:                 fin
_B033 
_B034 
; samplesrc/maze.pla: 0136:                 dir = DIR_RIGHT
; samplesrc/maze.pla: 0137:                 cnt++
	!BYTE	$10			; CN	8
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0138:                 break
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B024
	!WORD	_B024-*
; samplesrc/maze.pla: 0139:             is DIR_DOWN
_B038 
; samplesrc/maze.pla: 0140:                 if y < MAZE_HEIGHT-1
; samplesrc/maze.pla: 0141:                     flags = maze.[y + 1, x]
; samplesrc/maze.pla: 0142:                     if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0143:                         return DIR_DOWN
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$16			; CB	22
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B039
	!WORD	_B039-*
	!BYTE	$26			; LA	_D093+0
_F027 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B041
	!WORD	_B041-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B041 
	!BYTE	$4C			; BRFLS	_B042
	!WORD	_B042-*
	!BYTE	$08			; CN	4
	!BYTE	$5A,$07			; LEAVE	7
; samplesrc/maze.pla: 0144:                     fin
_B042 
_B043 
; samplesrc/maze.pla: 0145:                 fin
_B039 
_B040 
; samplesrc/maze.pla: 0146:                 dir = DIR_LEFT
; samplesrc/maze.pla: 0147:                 cnt++
	!BYTE	$04			; CN	2
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0148:                 break
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B024
	!WORD	_B024-*
; samplesrc/maze.pla: 0149:             is DIR_RIGHT
_B044 
; samplesrc/maze.pla: 0150:                 if x < MAZE_WIDTH-1
; samplesrc/maze.pla: 0151:                     flags = maze.[y, x + 1]
; samplesrc/maze.pla: 0152:                     if (flags & CELL_SOLVED) or !(flags & CELL_TRACED)
; samplesrc/maze.pla: 0153:                         return DIR_RIGHT
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$26			; CB	38
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B045
	!WORD	_B045-*
	!BYTE	$26			; LA	_D093+0
_F028 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$AE			; BROR	_B047
	!WORD	_B047-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$80			; NOT
_B047 
	!BYTE	$4C			; BRFLS	_B048
	!WORD	_B048-*
	!BYTE	$10			; CN	8
	!BYTE	$5A,$07			; LEAVE	7
; samplesrc/maze.pla: 0154:                     fin
_B048 
_B049 
; samplesrc/maze.pla: 0155:                 fin
_B045 
_B046 
; samplesrc/maze.pla: 0156:                 dir = DIR_UP
; samplesrc/maze.pla: 0157:                 cnt++
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0158:                 break
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B024
	!WORD	_B024-*
; samplesrc/maze.pla: 0159:         wend
	!BYTE	$50			; BRNCH	_B024
	!WORD	_B024-*
_B025 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0001
	!WORD	_B026-*
	!WORD	$0002
	!WORD	_B032-*
	!WORD	$0004
	!WORD	_B038-*
	!WORD	$0008
	!WORD	_B044-*
_B024 
; samplesrc/maze.pla: 0160:     until cnt > 3
_B023 
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$06			; CN	3
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B022
	!WORD	_B022-*
_B021 
; samplesrc/maze.pla: 0161:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$07			; LEAVE	7
; samplesrc/maze.pla: 0162: end
; samplesrc/maze.pla: 0163: 
; samplesrc/maze.pla: 0164: def cellSolve(x, y)#0
					; x -> [0]
					; y -> [2]
_C007 					; cellSolve()
; samplesrc/maze.pla: 0165:     byte flags, moveDir, searchCnt
					; flags -> [4]
					; moveDir -> [5]
					; searchCnt -> [6]
; samplesrc/maze.pla: 0166:     word traceStart, traceEnd, traceLast, traceBack
					; traceStart -> [7]
					; traceEnd -> [9]
					; traceLast -> [11]
					; traceBack -> [13]
; samplesrc/maze.pla: 0167: 
; samplesrc/maze.pla: 0168:     traceStart = heapmark
	!BYTE	$58,$0F,$02		; ENTER	15,2
; samplesrc/maze.pla: 0169:     traceLast  = traceStart
; samplesrc/maze.pla: 0170:     searchCnt  = 0
; samplesrc/maze.pla: 0171:     while !(maze.[y, x] & CELL_SOLVED)
	!BYTE	$54			; CALL	_X012
_F029 	!WORD	0		
	!BYTE	$6E,$07			; DLW	[7]
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B052
	!WORD	_B052-*
_B050 
; samplesrc/maze.pla: 0172:         if searchCnt == 0
; samplesrc/maze.pla: 0173:             cellSetFlags(x, y, CELL_TRACED)
; samplesrc/maze.pla: 0174:             traceEnd  = heapalloc(2)
; samplesrc/maze.pla: 0175:             *traceEnd = x | (y << 8)
; samplesrc/maze.pla: 0176:             moveDir   = 1 << (conio:rnd() & 3)
; samplesrc/maze.pla: 0177:         fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$4E			; BRTRU	_B053
	!WORD	_B053-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C000
_F030 	!WORD	_C000		
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_X014
_F031 	!WORD	0		
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X028+24
_F032 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9A			; SHL
	!BYTE	$74,$05			; SLB	[5]
_B053 
_B054 
; samplesrc/maze.pla: 0178:         //
; samplesrc/maze.pla: 0179:         // Look for a possible direction to move
; samplesrc/maze.pla: 0180:         //
; samplesrc/maze.pla: 0181:         when moveDir
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$52			; SEL
	!WORD	_B056-*
; samplesrc/maze.pla: 0182:             is DIR_UP
_B057 
; samplesrc/maze.pla: 0183:                 if branchUp(x, y)
; samplesrc/maze.pla: 0184:                     searchCnt = 0
; samplesrc/maze.pla: 0185:                     y--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F033 	!WORD	_C002		
	!BYTE	$4C			; BRFLS	_B058
	!WORD	_B058-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0186:                 else
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B059
	!WORD	_B059-*
_B058 
; samplesrc/maze.pla: 0187:                     searchCnt++
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0188:                     moveDir = DIR_DOWN
; samplesrc/maze.pla: 0189:                 fin
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$08			; CN	4
	!BYTE	$74,$05			; SLB	[5]
_B059 
; samplesrc/maze.pla: 0190:                 break
	!BYTE	$50			; BRNCH	_B055
	!WORD	_B055-*
; samplesrc/maze.pla: 0191:             is DIR_LEFT
_B060 
; samplesrc/maze.pla: 0192:                 if branchLeft(x, y)
; samplesrc/maze.pla: 0193:                     searchCnt = 0
; samplesrc/maze.pla: 0194:                     x--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F034 	!WORD	_C003		
	!BYTE	$4C			; BRFLS	_B061
	!WORD	_B061-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0195:                 else
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
_B061 
; samplesrc/maze.pla: 0196:                     searchCnt++
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0197:                     moveDir = DIR_RIGHT
; samplesrc/maze.pla: 0198:                 fin
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$10			; CN	8
	!BYTE	$74,$05			; SLB	[5]
_B062 
; samplesrc/maze.pla: 0199:                 break
	!BYTE	$50			; BRNCH	_B055
	!WORD	_B055-*
; samplesrc/maze.pla: 0200:             is DIR_DOWN
_B063 
; samplesrc/maze.pla: 0201:                 if branchDown(x, y)
; samplesrc/maze.pla: 0202:                     searchCnt = 0
; samplesrc/maze.pla: 0203:                     y++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F035 	!WORD	_C004		
	!BYTE	$4C			; BRFLS	_B064
	!WORD	_B064-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0204:                 else
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B065
	!WORD	_B065-*
_B064 
; samplesrc/maze.pla: 0205:                     searchCnt++
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0206:                     moveDir = DIR_LEFT
; samplesrc/maze.pla: 0207:                 fin
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$04			; CN	2
	!BYTE	$74,$05			; SLB	[5]
_B065 
; samplesrc/maze.pla: 0208:                 break
	!BYTE	$50			; BRNCH	_B055
	!WORD	_B055-*
; samplesrc/maze.pla: 0209:             is DIR_RIGHT
_B066 
; samplesrc/maze.pla: 0210:                 if branchRight(x, y)
; samplesrc/maze.pla: 0211:                     searchCnt = 0
; samplesrc/maze.pla: 0212:                     x++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C005
_F036 	!WORD	_C005		
	!BYTE	$4C			; BRFLS	_B067
	!WORD	_B067-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0213:                 else
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B068
	!WORD	_B068-*
_B067 
; samplesrc/maze.pla: 0214:                     searchCnt++
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0215:                     moveDir = DIR_UP
; samplesrc/maze.pla: 0216:                 fin
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
_B068 
; samplesrc/maze.pla: 0217:                 break
	!BYTE	$50			; BRNCH	_B055
	!WORD	_B055-*
; samplesrc/maze.pla: 0218:             otherwise
_B056 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0001
	!WORD	_B057-*
	!WORD	$0002
	!WORD	_B060-*
	!WORD	$0004
	!WORD	_B063-*
	!WORD	$0008
	!WORD	_B066-*
; samplesrc/maze.pla: 0219:                 //
; samplesrc/maze.pla: 0220:                 // Shouldn't happen
; samplesrc/maze.pla: 0221:                 //
; samplesrc/maze.pla: 0222:                 heaprelease(traceStart)
; samplesrc/maze.pla: 0223:                 return
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$54			; CALL	_X015
_F037 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$0F			; LEAVE	15
; samplesrc/maze.pla: 0224:         wend
_B055 
; samplesrc/maze.pla: 0225:         if searchCnt > 3
; samplesrc/maze.pla: 0226:             //
; samplesrc/maze.pla: 0227:             // Dead end - restart and try new branch
; samplesrc/maze.pla: 0228:             //
; samplesrc/maze.pla: 0229:             moveDir   = 0
; samplesrc/maze.pla: 0230:             traceBack = traceLast
; samplesrc/maze.pla: 0231:             repeat
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$06			; CN	3
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B069
	!WORD	_B069-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$76,$0D			; SLW	[13]
_B072 
; samplesrc/maze.pla: 0232:                 x = traceBack->0
; samplesrc/maze.pla: 0233:                 y = traceBack->1
; samplesrc/maze.pla: 0234:                 traceBack = traceBack + 2
; samplesrc/maze.pla: 0235:                 moveDir = branchNew(x, y)
; samplesrc/maze.pla: 0236:             until moveDir or traceBack == traceStart
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$0D			; SLW	[13]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C006
_F038 	!WORD	_C006		
	!BYTE	$74,$05			; SLB	[5]
_B073 
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$AE			; BROR	_B074
	!WORD	_B074-*
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$40			; ISEQ
_B074 
	!BYTE	$4C			; BRFLS	_B072
	!WORD	_B072-*
_B071 
; samplesrc/maze.pla: 0237:             if not moveDir
; samplesrc/maze.pla: 0238:                 //
; samplesrc/maze.pla: 0239:                 // Shouldn't happen
; samplesrc/maze.pla: 0240:                 //
; samplesrc/maze.pla: 0241:                 heaprelease(traceStart)
; samplesrc/maze.pla: 0242:                 return
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$4E			; BRTRU	_B075
	!WORD	_B075-*
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$54			; CALL	_X015
_F039 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$0F			; LEAVE	15
; samplesrc/maze.pla: 0243:             fin
_B075 
_B076 
; samplesrc/maze.pla: 0244:             traceLast = traceBack
; samplesrc/maze.pla: 0245:         fin
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$76,$0B			; SLW	[11]
_B069 
_B070 
; samplesrc/maze.pla: 0246:     loop
_B052 
	!BYTE	$26			; LA	_D093+0
_F040 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B050
	!WORD	_B050-*
_B051 
; samplesrc/maze.pla: 0247:     //
; samplesrc/maze.pla: 0248:     // Mark all traced cells as solved
; samplesrc/maze.pla: 0249:     //
; samplesrc/maze.pla: 0250:     traceBack = traceEnd + 2
; samplesrc/maze.pla: 0251:     repeat
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$0D			; SLW	[13]
_B078 
; samplesrc/maze.pla: 0252:         traceBack = traceBack - 2
; samplesrc/maze.pla: 0253:         cellSetFlags(traceBack->0, traceBack->1, CELL_SOLVED)
; samplesrc/maze.pla: 0254:     until traceBack == traceStart
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$6E,$0D			; DLW	[13]
	!BYTE	$60			; LB
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F041 	!WORD	_C000		
_B079 
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$24			; BRNE	_B078
	!WORD	_B078-*
_B077 
; samplesrc/maze.pla: 0255:     heaprelease(traceStart)
; samplesrc/maze.pla: 0256: end
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$54			; CALL	_X015
_F042 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$0F			; LEAVE	15
; samplesrc/maze.pla: 0257: 
; samplesrc/maze.pla: 0258: def cellVis(x, y, dir)#0
					; x -> [0]
					; y -> [2]
					; dir -> [4]
_C008 					; cellVis()
; samplesrc/maze.pla: 0259:     if not (maze.[y, x] & CELL_SEEN)
	!BYTE	$58,$06,$03		; ENTER	6,3
; samplesrc/maze.pla: 0260:         if (dir & DIR_RIGHT) and (maze.[y, x] & WALL_LEFT)
; samplesrc/maze.pla: 0261:             cellSetFlags(x, y, SEEN_LEFT)
; samplesrc/maze.pla: 0262:             tileDraw(x, y, @mazeTileSet + 8 * ((maze.[y, x] & (maze.[y, x] >> 3)) & 7))
; samplesrc/maze.pla: 0263:             return
	!BYTE	$26			; LA	_D093+0
_F043 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4E			; BRTRU	_B080
	!WORD	_B080-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$AC			; BRAND	_B082
	!WORD	_B082-*
	!BYTE	$26			; LA	_D093+0
_F044 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
_B082 
	!BYTE	$4C			; BRFLS	_B083
	!WORD	_B083-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C000
_F045 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F046 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F047 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D093+0
_F048 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$94			; AND 
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F049 	!WORD	0		
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/maze.pla: 0264:         fin
_B083 
_B084 
; samplesrc/maze.pla: 0265:         if (dir & DIR_DOWN) and (maze.[y, x] & WALL_TOP)
; samplesrc/maze.pla: 0266:             cellSetFlags(x, y, SEEN_TOP)
; samplesrc/maze.pla: 0267:             tileDraw(x, y, @mazeTileSet + 8 * ((maze.[y, x] & (maze.[y, x] >> 3)) & 7))
; samplesrc/maze.pla: 0268:             return
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$AC			; BRAND	_B085
	!WORD	_B085-*
	!BYTE	$26			; LA	_D093+0
_F050 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
_B085 
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$10			; CN	8
	!BYTE	$54			; CALL	_C000
_F051 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F052 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F053 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D093+0
_F054 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$94			; AND 
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F055 	!WORD	0		
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/maze.pla: 0269:         fin
_B086 
_B087 
; samplesrc/maze.pla: 0270:         cellSetFlags(x, y, CELL_SEEN | SEEN_TOP | SEEN_LEFT)
; samplesrc/maze.pla: 0271:         tileDraw(x, y, @mazeTileSet + 8 * (maze.[y, x] & 7))
; samplesrc/maze.pla: 0272:         if maze.[y, x + 1] & WALL_LEFT
; samplesrc/maze.pla: 0273:             if not (maze.[y, x + 1] & CELL_SEEN)
; samplesrc/maze.pla: 0274:                 cellSetFlags(x + 1, y, SEEN_LEFT)
; samplesrc/maze.pla: 0275:                 tileDraw(x + 1, y, @mazeTileSet + 8 * ((maze.[y, x + 1] & (maze.[y, x + 1] >> 3)) & 7))
; samplesrc/maze.pla: 0276:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$28			; CB	40
	!BYTE	$3E,$10			; ORI	16
	!BYTE	$54			; CALL	_C000
_F056 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F057 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F058 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F059 	!WORD	0		
	!BYTE	$26			; LA	_D093+0
_F060 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B088
	!WORD	_B088-*
	!BYTE	$26			; LA	_D093+0
_F061 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4E			; BRTRU	_B090
	!WORD	_B090-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C000
_F062 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F063 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F064 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D093+0
_F065 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$94			; AND 
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F066 	!WORD	0		
_B090 
_B091 
; samplesrc/maze.pla: 0277:         fin
_B088 
_B089 
; samplesrc/maze.pla: 0278:         if maze.[y + 1, x] & WALL_TOP
; samplesrc/maze.pla: 0279:             if not (maze.[y + 1, x] & CELL_SEEN)
; samplesrc/maze.pla: 0280:                 cellSetFlags(x, y + 1, SEEN_TOP)
; samplesrc/maze.pla: 0281:                 tileDraw(x, y + 1, @mazeTileSet + 8 * ((maze.[y + 1, x] & (maze.[y + 1, x] >> 3)) & 7))
; samplesrc/maze.pla: 0282:             fin
	!BYTE	$26			; LA	_D093+0
_F067 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B092
	!WORD	_B092-*
	!BYTE	$26			; LA	_D093+0
_F068 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4E			; BRTRU	_B094
	!WORD	_B094-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$10			; CN	8
	!BYTE	$54			; CALL	_C000
_F069 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$26			; LA	_D092+0
_F070 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F071 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D093+0
_F072 	!WORD	_D093+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$94			; AND 
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F073 	!WORD	0		
_B094 
_B095 
; samplesrc/maze.pla: 0283:         fin
_B092 
_B093 
; samplesrc/maze.pla: 0284:     fin
_B080 
_B081 
; samplesrc/maze.pla: 0285: end
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/maze.pla: 0286: 
; samplesrc/maze.pla: 0287: def cellView(x, y)#0
					; x -> [0]
					; y -> [2]
_C009 					; cellView()
; samplesrc/maze.pla: 0288:     byte vis
					; vis -> [4]
; samplesrc/maze.pla: 0289: 
; samplesrc/maze.pla: 0290:     cellSetFlags(x, y, CELL_SEEN | SEEN_TOP | SEEN_LEFT | CELL_VISITED)
	!BYTE	$58,$05,$02		; ENTER	5,2
; samplesrc/maze.pla: 0291:     tileDraw(x, y, @mazeTileSet + 8 * (maze.[y, x] & 7))
; samplesrc/maze.pla: 0292:     if viewFlag
; samplesrc/maze.pla: 0293:         vis = x
; samplesrc/maze.pla: 0294:         while not (maze.[y, vis] & WALL_LEFT)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$28			; CB	40
	!BYTE	$3E,$10			; ORI	16
	!BYTE	$3E,$04			; ORI	4
	!BYTE	$54			; CALL	_C000
_F074 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D092+0
_F075 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F076 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F077 	!WORD	0		
	!BYTE	$68			; LAB	_D100+0
_F078 	!WORD	_D100+0		
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B100
	!WORD	_B100-*
_B098 
; samplesrc/maze.pla: 0295:             vis--
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0296:             cellVis(vis, y, DIR_LEFT)
; samplesrc/maze.pla: 0297:         loop
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C008
_F079 	!WORD	_C008		
_B100 
	!BYTE	$26			; LA	_D093+0
_F080 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B098
	!WORD	_B098-*
_B099 
; samplesrc/maze.pla: 0298:         vis = y
; samplesrc/maze.pla: 0299:         while not (maze.[vis, x] & WALL_TOP)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B103
	!WORD	_B103-*
_B101 
; samplesrc/maze.pla: 0300:             vis--
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0301:             cellVis(x, vis, DIR_UP)
; samplesrc/maze.pla: 0302:         loop
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F081 	!WORD	_C008		
_B103 
	!BYTE	$26			; LA	_D093+0
_F082 	!WORD	_D093+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B101
	!WORD	_B101-*
_B102 
; samplesrc/maze.pla: 0303:         vis = x
; samplesrc/maze.pla: 0304:         repeat
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$74,$04			; SLB	[4]
_B105 
; samplesrc/maze.pla: 0305:             vis++
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0306:             cellVis(vis, y, DIR_RIGHT)
; samplesrc/maze.pla: 0307:         until (vis >= MAZE_WIDTH) or (maze.[y, vis] & WALL_LEFT)
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$10			; CN	8
	!BYTE	$54			; CALL	_C008
_F083 	!WORD	_C008		
_B106 
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$2A,$27			; CB	39
	!BYTE	$48			; ISGE
	!BYTE	$AE			; BROR	_B107
	!WORD	_B107-*
	!BYTE	$26			; LA	_D093+0
_F084 	!WORD	_D093+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
_B107 
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
_B104 
; samplesrc/maze.pla: 0308:         vis = y
; samplesrc/maze.pla: 0309:         repeat
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$74,$04			; SLB	[4]
_B109 
; samplesrc/maze.pla: 0310:             vis++
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0311:             cellVis(x, vis, DIR_DOWN)
; samplesrc/maze.pla: 0312:         until maze.[vis, x] & WALL_TOP
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C008
_F085 	!WORD	_C008		
_B110 
	!BYTE	$26			; LA	_D093+0
_F086 	!WORD	_D093+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B109
	!WORD	_B109-*
_B108 
; samplesrc/maze.pla: 0313:     fin
_B096 
_B097 
; samplesrc/maze.pla: 0314: end
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/maze.pla: 0315: 
; samplesrc/maze.pla: 0316: def mazeGen#0
_C010 					; mazeGen()
; samplesrc/maze.pla: 0317:     byte x, y
					; x -> [0]
					; y -> [1]
; samplesrc/maze.pla: 0318: 
; samplesrc/maze.pla: 0319:     cellSetFlags(MAZE_WIDTH-1, exit, CELL_SOLVED)
	!BYTE	$58,$02,$00		; ENTER	2,0
; samplesrc/maze.pla: 0320:     cellSolve(0, entry)
; samplesrc/maze.pla: 0321:     for x = 0 to MAZE_WIDTH-1
	!BYTE	$2A,$26			; CB	38
	!BYTE	$68			; LAB	_D098+0
_F087 	!WORD	_D098+0		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F088 	!WORD	_C000		
	!BYTE	$00			; CN	0
	!BYTE	$68			; LAB	_D097+0
_F089 	!WORD	_D097+0		
	!BYTE	$54			; CALL	_C007
_F090 	!WORD	_C007		
	!BYTE	$2A,$26			; CB	38
	!BYTE	$00			; CN	0
_B112 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/maze.pla: 0322:         for y = 0 to MAZE_HEIGHT-1
	!BYTE	$2A,$16			; CB	22
	!BYTE	$00			; CN	0
_B115 
	!BYTE	$6C,$01			; DLB	[1]
; samplesrc/maze.pla: 0323:             if !(maze.[y, x] & CELL_SOLVED)
; samplesrc/maze.pla: 0324:                 cellSolve(x, y)
; samplesrc/maze.pla: 0325:             fin
	!BYTE	$26			; LA	_D093+0
_F091 	!WORD	_D093+0		
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4E			; BRTRU	_B117
	!WORD	_B117-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_C007
_F092 	!WORD	_C007		
_B117 
_B118 
; samplesrc/maze.pla: 0326:         next
_B116 
	!BYTE	$A4			; INCBRLE	_B115
	!WORD	_B115-*
_B114 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0327:     next
_B113 
	!BYTE	$A4			; INCBRLE	_B112
	!WORD	_B112-*
_B111 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0328:     //
; samplesrc/maze.pla: 0329:     // Clear all flags used to generate
; samplesrc/maze.pla: 0330:     //
; samplesrc/maze.pla: 0331:     for x = 0 to MAZE_WIDTH-1
	!BYTE	$2A,$26			; CB	38
	!BYTE	$00			; CN	0
_B120 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/maze.pla: 0332:         for y = 0 to MAZE_HEIGHT-1
	!BYTE	$2A,$16			; CB	22
	!BYTE	$00			; CN	0
_B123 
	!BYTE	$6C,$01			; DLB	[1]
; samplesrc/maze.pla: 0333:             cellClearFlags(x, y, CELL_SOLVED | CELL_TRACED)
; samplesrc/maze.pla: 0334:         next
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C001
_F093 	!WORD	_C001		
_B124 
	!BYTE	$A4			; INCBRLE	_B123
	!WORD	_B123-*
_B122 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0335:     next
_B121 
	!BYTE	$A4			; INCBRLE	_B120
	!WORD	_B120-*
_B119 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0336: end
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/maze.pla: 0337: 
; samplesrc/maze.pla: 0338: def mazeInit#0
_C011 					; mazeInit()
; samplesrc/maze.pla: 0339:     byte y
					; y -> [0]
; samplesrc/maze.pla: 0340: 
; samplesrc/maze.pla: 0341:     for y = 0 to MAZE_HEIGHT-1
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$2A,$16			; CB	22
	!BYTE	$00			; CN	0
_B126 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/maze.pla: 0342:         memset(maze[y], $0303, MAZE_WIDTH)
; samplesrc/maze.pla: 0343:         maze.[y, MAZE_WIDTH] = WALL_LEFT
; samplesrc/maze.pla: 0344:     next
	!BYTE	$26			; LA	_D093+0
_F094 	!WORD	_D093+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$2C,$03,$03		; CW	771
	!BYTE	$2A,$27			; CB	39
	!BYTE	$54			; CALL	_X017
_F095 	!WORD	0		
	!BYTE	$04			; CN	2
	!BYTE	$26			; LA	_D093+0
_F096 	!WORD	_D093+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$38,$27			; ADDI	39
	!BYTE	$70			; SB
_B127 
	!BYTE	$A4			; INCBRLE	_B126
	!WORD	_B126-*
_B125 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0345:     memset(maze[MAZE_HEIGHT], $0101, MAZE_WIDTH)
; samplesrc/maze.pla: 0346:     maze.[MAZE_HEIGHT, MAZE_WIDTH] = 0
; samplesrc/maze.pla: 0347:     entry = conio:rnd() % MAZE_HEIGHT
; samplesrc/maze.pla: 0348:     exit  = conio:rnd() % MAZE_HEIGHT
; samplesrc/maze.pla: 0349:     maze.[entry, 0]             = WALL_TOP
; samplesrc/maze.pla: 0350:     maze.[exit, MAZE_WIDTH]     = WALL_TOP
; samplesrc/maze.pla: 0351:     if exit < MAZE_HEIGHT
; samplesrc/maze.pla: 0352:         maze.[exit + 1, MAZE_WIDTH] = WALL_TOP|WALL_LEFT
; samplesrc/maze.pla: 0353:     else
	!BYTE	$6A			; LAW	_D093+46
_F097 	!WORD	_D093+46		
	!BYTE	$2C,$01,$01		; CW	257
	!BYTE	$2A,$27			; CB	39
	!BYTE	$54			; CALL	_X017
_F098 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D093+46
_F099 	!WORD	_D093+46		
	!BYTE	$38,$27			; ADDI	39
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_X028+24
_F100 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$2A,$17			; CB	23
	!BYTE	$8A			; MOD
	!BYTE	$78			; SAB	_D097+0
_F101 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_X028+24
_F102 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$2A,$17			; CB	23
	!BYTE	$8A			; MOD
	!BYTE	$78			; SAB	_D098+0
_F103 	!WORD	_D098+0		
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D093+0
_F104 	!WORD	_D093+0		
	!BYTE	$BC			; IDXAB	_D097+0
_F105 	!WORD	_D097+0		
	!BYTE	$62			; LW
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D093+0
_F106 	!WORD	_D093+0		
	!BYTE	$BC			; IDXAB	_D098+0
_F107 	!WORD	_D098+0		
	!BYTE	$62			; LW
	!BYTE	$38,$27			; ADDI	39
	!BYTE	$70			; SB
	!BYTE	$68			; LAB	_D098+0
_F108 	!WORD	_D098+0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B128
	!WORD	_B128-*
	!BYTE	$06			; CN	3
	!BYTE	$26			; LA	_D093+0
_F109 	!WORD	_D093+0		
	!BYTE	$68			; LAB	_D098+0
_F110 	!WORD	_D098+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$38,$27			; ADDI	39
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B128 
; samplesrc/maze.pla: 0354:         maze.[exit + 1, MAZE_WIDTH] = WALL_TOP
; samplesrc/maze.pla: 0355:     fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D093+0
_F111 	!WORD	_D093+0		
	!BYTE	$68			; LAB	_D098+0
_F112 	!WORD	_D098+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$38,$27			; ADDI	39
	!BYTE	$70			; SB
_B129 
; samplesrc/maze.pla: 0356: end
	!BYTE	$5A,$01			; LEAVE	1
; samplesrc/maze.pla: 0357: 
; samplesrc/maze.pla: 0358: def mazePlay
_C012 					; mazePlay()
; samplesrc/maze.pla: 0359:     byte x, y, quit, key
					; x -> [0]
					; y -> [1]
					; quit -> [2]
					; key -> [3]
; samplesrc/maze.pla: 0360: 
; samplesrc/maze.pla: 0361:     if viewFlag
	!BYTE	$58,$04,$00		; ENTER	4,0
; samplesrc/maze.pla: 0362:         hgrColor(0)
; samplesrc/maze.pla: 0363:         hgrRect(0, 0, 279, 191)
; samplesrc/maze.pla: 0364:     fin
	!BYTE	$68			; LAB	_D100+0
_F113 	!WORD	_D100+0		
	!BYTE	$4C			; BRFLS	_B130
	!WORD	_B130-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X083
_F114 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$2C,$17,$01		; CW	279
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$54			; CALL	_X070
_F115 	!WORD	0		
_B130 
_B131 
; samplesrc/maze.pla: 0365:     cellSetFlags(0, entry, WALL_LEFT) // Block off entry
; samplesrc/maze.pla: 0366:     x    = 0
; samplesrc/maze.pla: 0367:     y    = entry
; samplesrc/maze.pla: 0368:     zero32
; samplesrc/maze.pla: 0369:     while TRUE
	!BYTE	$00			; CN	0
	!BYTE	$68			; LAB	_D097+0
_F116 	!WORD	_D097+0		
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C000
_F117 	!WORD	_C000		
	!BYTE	$00			; CN	0
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$68			; LAB	_D097+0
_F118 	!WORD	_D097+0		
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$54			; CALL	_X033
_F119 	!WORD	0		
	!BYTE	$50			; BRNCH	_B134
	!WORD	_B134-*
_B132 
; samplesrc/maze.pla: 0370:         cellView(x, y)
; samplesrc/maze.pla: 0371:         tileOrDraw(x, y, @mazeTileSet + PLAYER)
; samplesrc/maze.pla: 0372:         while not conio:keypressed()
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_C009
_F120 	!WORD	_C009		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$26			; LA	_D092+64
_F121 	!WORD	_D092+64		
	!BYTE	$54			; CALL	_X087
_F122 	!WORD	0		
	!BYTE	$50			; BRNCH	_B137
	!WORD	_B137-*
_B135 
; samplesrc/maze.pla: 0373:             addi16(1)
; samplesrc/maze.pla: 0374:         loop
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_X040
_F123 	!WORD	0		
_B137 
	!BYTE	$6A			; LAW	_X028+0
_F124 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B135
	!WORD	_B135-*
_B136 
; samplesrc/maze.pla: 0375:         tileDraw(x, y, @mazeTileSet + 8 * (maze.[y, x] & 7))
; samplesrc/maze.pla: 0376:         key = toupper(conio:getkey() & $7F)
; samplesrc/maze.pla: 0377:         when key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$26			; LA	_D092+0
_F125 	!WORD	_D092+0		
	!BYTE	$10			; CN	8
	!BYTE	$26			; LA	_D093+0
_F126 	!WORD	_D093+0		
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X085
_F127 	!WORD	0		
	!BYTE	$6A			; LAW	_X028+2
_F128 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$54			; CALL	_X021
_F129 	!WORD	0		
	!BYTE	$6C,$03			; DLB	[3]
	!BYTE	$52			; SEL
	!WORD	_B139-*
; samplesrc/maze.pla: 0378:             is 'I'
_B140 
; samplesrc/maze.pla: 0379:                 if !(maze.[y, x] & WALL_TOP) 
; samplesrc/maze.pla: 0380:                     y--
	!BYTE	$26			; LA	_D093+0
_F130 	!WORD	_D093+0		
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4E			; BRTRU	_B141
	!WORD	_B141-*
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0381:                     moveCnt++
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D096+0
_F131 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0382:                 fin
	!BYTE	$7A			; SAW	_D096+0
_F132 	!WORD	_D096+0		
_B141 
_B142 
; samplesrc/maze.pla: 0383:                 break
	!BYTE	$50			; BRNCH	_B138
	!WORD	_B138-*
; samplesrc/maze.pla: 0384:             is 'M'
_B143 
; samplesrc/maze.pla: 0385:                 if !(maze.[y + 1, x] & WALL_TOP)
; samplesrc/maze.pla: 0386:                     y++
	!BYTE	$26			; LA	_D093+0
_F133 	!WORD	_D093+0		
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4E			; BRTRU	_B144
	!WORD	_B144-*
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0387:                     moveCnt++
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D096+0
_F134 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0388:                 fin
	!BYTE	$7A			; SAW	_D096+0
_F135 	!WORD	_D096+0		
_B144 
_B145 
; samplesrc/maze.pla: 0389:                 break
	!BYTE	$50			; BRNCH	_B138
	!WORD	_B138-*
; samplesrc/maze.pla: 0390:             is 'J'
_B146 
; samplesrc/maze.pla: 0391:                 if !(maze.[y, x] & WALL_LEFT)
; samplesrc/maze.pla: 0392:                     x--
	!BYTE	$26			; LA	_D093+0
_F136 	!WORD	_D093+0		
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4E			; BRTRU	_B147
	!WORD	_B147-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0393:                     moveCnt++
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D096+0
_F137 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0394:                 fin
	!BYTE	$7A			; SAW	_D096+0
_F138 	!WORD	_D096+0		
_B147 
_B148 
; samplesrc/maze.pla: 0395:                 break
	!BYTE	$50			; BRNCH	_B138
	!WORD	_B138-*
; samplesrc/maze.pla: 0396:             is 'K'
_B149 
; samplesrc/maze.pla: 0397:                 if !(maze.[y, x + 1] & WALL_LEFT)
; samplesrc/maze.pla: 0398:                     x++
	!BYTE	$26			; LA	_D093+0
_F139 	!WORD	_D093+0		
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4E			; BRTRU	_B150
	!WORD	_B150-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0399:                     moveCnt++
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D096+0
_F140 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0400:                     if x == MAZE_WIDTH; return TRUE; fin // Solved!
	!BYTE	$7A			; SAW	_D096+0
_F141 	!WORD	_D096+0		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$2A,$27			; CB	39
	!BYTE	$24			; BRNE	_B152
	!WORD	_B152-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
_B152 
_B153 
; samplesrc/maze.pla: 0401:                 fin
_B150 
_B151 
; samplesrc/maze.pla: 0402:                 break
	!BYTE	$50			; BRNCH	_B138
	!WORD	_B138-*
; samplesrc/maze.pla: 0403:             is 'Q'
_B154 
; samplesrc/maze.pla: 0404:                 return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/maze.pla: 0405:         wend
	!BYTE	$50			; BRNCH	_B138
	!WORD	_B138-*
_B139 
	!BYTE	$05			; CASEBLOCK
	!WORD	$0049
	!WORD	_B140-*
	!WORD	$004A
	!WORD	_B146-*
	!WORD	$004B
	!WORD	_B149-*
	!WORD	$004D
	!WORD	_B143-*
	!WORD	$0051
	!WORD	_B154-*
_B138 
; samplesrc/maze.pla: 0406:     loop
_B134 
	!BYTE	$50			; BRNCH	_B132
	!WORD	_B132-*
_B133 
; samplesrc/maze.pla: 0407:     return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/maze.pla: 0408: end
; samplesrc/maze.pla: 0409: 
; samplesrc/maze.pla: 0410: def atoi(strptr)#1
					; strptr -> [0]
_C013 					; atoi()
; samplesrc/maze.pla: 0411:     var num, len, sign
					; num -> [2]
					; len -> [4]
					; sign -> [6]
; samplesrc/maze.pla: 0412: 
; samplesrc/maze.pla: 0413:     sign = 1
	!BYTE	$58,$08,$01		; ENTER	8,1
; samplesrc/maze.pla: 0414:     num = 0
; samplesrc/maze.pla: 0415:     len = ^strptr
; samplesrc/maze.pla: 0416:     strptr++
	!BYTE	$02			; CN	1
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0417:     if ^strptr == '-'
; samplesrc/maze.pla: 0418:         sign = -1
; samplesrc/maze.pla: 0419:         strptr++
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$24			; BRNE	_B155
	!WORD	_B155-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0420:         len--
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0421:     elsif ^strptr == '+'
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B156
	!WORD	_B156-*
_B155 
; samplesrc/maze.pla: 0422:         strptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$24			; BRNE	_B157
	!WORD	_B157-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0423:         len--
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0424:     fin
	!BYTE	$76,$04			; SLW	[4]
_B157 
_B156 
; samplesrc/maze.pla: 0425:     while len and ^strptr >= '0' and ^strptr <= '9'
	!BYTE	$50			; BRNCH	_B160
	!WORD	_B160-*
_B158 
; samplesrc/maze.pla: 0426:         num = num * 10 + ^strptr - '0'
; samplesrc/maze.pla: 0427:         strptr++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; samplesrc/maze.pla: 0428:         len--
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8E			; DECR
; samplesrc/maze.pla: 0429:     loop
	!BYTE	$76,$04			; SLW	[4]
_B160 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$AC			; BRAND	_B161
	!WORD	_B161-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B162
	!WORD	_B162-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B162 
_B161 
	!BYTE	$4E			; BRTRU	_B158
	!WORD	_B158-*
_B159 
; samplesrc/maze.pla: 0430:     return num * sign
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$86			; MUL
	!BYTE	$5A,$08			; LEAVE	8
; samplesrc/maze.pla: 0431: end
; samplesrc/maze.pla: 0432: 
; samplesrc/maze.pla: 0433: arg = argNext(argFirst)
_INIT 
; samplesrc/maze.pla: 0434: if ^arg and ^(arg + 1) == 'V'
; samplesrc/maze.pla: 0435:     viewFlag = FALSE
; samplesrc/maze.pla: 0436:     arg = argNext(arg)
; samplesrc/maze.pla: 0437: fin
	!BYTE	$54			; CALL	_X030
_F142 	!WORD	0		
	!BYTE	$54			; CALL	_X031
_F143 	!WORD	0		
	!BYTE	$7A			; SAW	_D094+0
_F144 	!WORD	_D094+0		
	!BYTE	$6A			; LAW	_D094+0
_F145 	!WORD	_D094+0		
	!BYTE	$60			; LB
	!BYTE	$AC			; BRAND	_B163
	!WORD	_B163-*
	!BYTE	$6A			; LAW	_D094+0
_F146 	!WORD	_D094+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$56			; CB	86
	!BYTE	$40			; ISEQ
_B163 
	!BYTE	$4C			; BRFLS	_B164
	!WORD	_B164-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D100+0
_F147 	!WORD	_D100+0		
	!BYTE	$6A			; LAW	_D094+0
_F148 	!WORD	_D094+0		
	!BYTE	$54			; CALL	_X031
_F149 	!WORD	0		
	!BYTE	$7A			; SAW	_D094+0
_F150 	!WORD	_D094+0		
_B164 
_B165 
; samplesrc/maze.pla: 0438: if ^arg
; samplesrc/maze.pla: 0439:     *rndnum = atoi(arg)
; samplesrc/maze.pla: 0440: else
	!BYTE	$6A			; LAW	_D094+0
_F151 	!WORD	_D094+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B166
	!WORD	_B166-*
	!BYTE	$6A			; LAW	_D094+0
_F152 	!WORD	_D094+0		
	!BYTE	$54			; CALL	_C013
_F153 	!WORD	_C013		
	!BYTE	$7A,$4E,$00		; SAW	78
	!BYTE	$50			; BRNCH	_B167
	!WORD	_B167-*
_B166 
; samplesrc/maze.pla: 0441:     puts("I, J, K, M to move. Q to quit.\n")
	!BYTE	$2E			; CS
	!BYTE	$1F
	!BYTE	$49,$2C,$20,$4A,$2C,$20,$4B,$2C
	!BYTE	$20,$4D,$20,$74,$6F,$20,$6D,$6F
	!BYTE	$76,$65,$2E,$20,$51,$20,$74,$6F
	!BYTE	$20,$71,$75,$69,$74,$2E,$0D
	!BYTE	$54			; CALL	_X004
_F154 	!WORD	0		
; samplesrc/maze.pla: 0442:     puts("Add seed value to command line to replay maze.\n")
	!BYTE	$2E			; CS
	!BYTE	$2F
	!BYTE	$41,$64,$64,$20,$73,$65,$65,$64
	!BYTE	$20,$76,$61,$6C,$75,$65,$20,$74
	!BYTE	$6F,$20,$63,$6F,$6D,$6D,$61,$6E
	!BYTE	$64,$20,$6C,$69,$6E,$65,$20,$74
	!BYTE	$6F,$20,$72,$65,$70,$6C,$61,$79
	!BYTE	$20,$6D,$61,$7A,$65,$2E,$0D
	!BYTE	$54			; CALL	_X004
_F155 	!WORD	0		
; samplesrc/maze.pla: 0443:     puts("Press a key to generate the maze...")
	!BYTE	$2E			; CS
	!BYTE	$23
	!BYTE	$50,$72,$65,$73,$73,$20,$61,$20
	!BYTE	$6B,$65,$79,$20,$74,$6F,$20,$67
	!BYTE	$65,$6E,$65,$72,$61,$74,$65,$20
	!BYTE	$74,$68,$65,$20,$6D,$61,$7A,$65
	!BYTE	$2E,$2E,$2E
	!BYTE	$54			; CALL	_X004
_F156 	!WORD	0		
; samplesrc/maze.pla: 0444:     while not conio:keypressed()
	!BYTE	$50			; BRNCH	_B170
	!WORD	_B170-*
_B168 
; samplesrc/maze.pla: 0445:         conio:rnd()
; samplesrc/maze.pla: 0446:     loop
	!BYTE	$6A			; LAW	_X028+24
_F157 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B170 
	!BYTE	$6A			; LAW	_X028+0
_F158 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B168
	!WORD	_B168-*
_B169 
; samplesrc/maze.pla: 0447:     getc
; samplesrc/maze.pla: 0448: fin
	!BYTE	$54			; CALL	_X006
_F159 	!WORD	0		
	!BYTE	$30			; DROP 
_B167 
; samplesrc/maze.pla: 0449: repeat
_B172 
; samplesrc/maze.pla: 0450:     moveCnt = 0
; samplesrc/maze.pla: 0451:     seed = *rndnum
; samplesrc/maze.pla: 0452:     conio:textmode(40)
; samplesrc/maze.pla: 0453:     hgrMode(hgrPage1)
; samplesrc/maze.pla: 0454:     hgrDrawBuf(hgrPage1)
; samplesrc/maze.pla: 0455:     tileDrawBuf(hgrPage1)
; samplesrc/maze.pla: 0456:     mazeInit
; samplesrc/maze.pla: 0457:     tileFromText(0, @mazeTileSet)
; samplesrc/maze.pla: 0458:     mazeGen
; samplesrc/maze.pla: 0459:     solved = mazePlay
; samplesrc/maze.pla: 0460:     store32(@tics)
; samplesrc/maze.pla: 0461:     hgrMode(hgrOff)
; samplesrc/maze.pla: 0462:     if solved
; samplesrc/maze.pla: 0463:         puts("Solved!\n")
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D096+0
_F160 	!WORD	_D096+0		
	!BYTE	$6A,$4E,$00		; LAW	78
	!BYTE	$7A			; SAW	_D095+0
_F161 	!WORD	_D095+0		
	!BYTE	$2A,$28			; CB	40
	!BYTE	$6A			; LAW	_X028+14
_F162 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X078
_F163 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X082
_F164 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X091
_F165 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C011
_F166 	!WORD	_C011		
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D092+0
_F167 	!WORD	_D092+0		
	!BYTE	$54			; CALL	_X090
_F168 	!WORD	0		
	!BYTE	$54			; CALL	_C010
_F169 	!WORD	_C010		
	!BYTE	$54			; CALL	_C012
_F170 	!WORD	_C012		
	!BYTE	$78			; SAB	_D099+0
_F171 	!WORD	_D099+0		
	!BYTE	$26			; LA	_D101+0
_F172 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_X038
_F173 	!WORD	0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_X078
_F174 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D099+0
_F175 	!WORD	_D099+0		
	!BYTE	$4C			; BRFLS	_B174
	!WORD	_B174-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$53,$6F,$6C,$76,$65,$64,$21,$0D
	!BYTE	$54			; CALL	_X004
_F176 	!WORD	0		
; samplesrc/maze.pla: 0464:     fin
_B174 
_B175 
; samplesrc/maze.pla: 0465:     puts("Seed  = "); puti(seed); putln
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$53,$65,$65,$64,$20,$20,$3D,$20
	!BYTE	$54			; CALL	_X004
_F177 	!WORD	0		
; samplesrc/maze.pla: 0466:     puts("Moves = "); puti(moveCnt); putln
	!BYTE	$6A			; LAW	_D095+0
_F178 	!WORD	_D095+0		
	!BYTE	$54			; CALL	_X005
_F179 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F180 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$4D,$6F,$76,$65,$73,$20,$3D,$20
	!BYTE	$54			; CALL	_X004
_F181 	!WORD	0		
; samplesrc/maze.pla: 0467:     puts("Timer = "); puti32(@tics)
	!BYTE	$6A			; LAW	_D096+0
_F182 	!WORD	_D096+0		
	!BYTE	$54			; CALL	_X005
_F183 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F184 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$54,$69,$6D,$65,$72,$20,$3D,$20
	!BYTE	$54			; CALL	_X004
_F185 	!WORD	0		
; samplesrc/maze.pla: 0468:     load32(@tics); divi16(1085); store32(@tics)
; samplesrc/maze.pla: 0469:     puts(" ("); puti32(@tics); puts(" secs)\n")
	!BYTE	$26			; LA	_D101+0
_F186 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_X060
_F187 	!WORD	0		
	!BYTE	$26			; LA	_D101+0
_F188 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_X036
_F189 	!WORD	0		
	!BYTE	$2C,$3D,$04		; CW	1085
	!BYTE	$54			; CALL	_X048
_F190 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D101+0
_F191 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_X038
_F192 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$20,$28
	!BYTE	$54			; CALL	_X004
_F193 	!WORD	0		
	!BYTE	$26			; LA	_D101+0
_F194 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_X060
_F195 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$20,$73,$65,$63,$73,$29,$0D
	!BYTE	$54			; CALL	_X004
_F196 	!WORD	0		
; samplesrc/maze.pla: 0470:     for moveCnt = 0 to 1000
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$00			; CN	0
_B177 
	!BYTE	$7E			; DAW	_D096+0
_F197 	!WORD	_D096+0		
; samplesrc/maze.pla: 0471:         if conio:keypressed(); getc; fin
	!BYTE	$6A			; LAW	_X028+0
_F198 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B179
	!WORD	_B179-*
	!BYTE	$54			; CALL	_X006
_F199 	!WORD	0		
	!BYTE	$30			; DROP 
_B179 
_B180 
; samplesrc/maze.pla: 0472:     next
_B178 
	!BYTE	$A4			; INCBRLE	_B177
	!WORD	_B177-*
_B176 
	!BYTE	$7A			; SAW	_D096+0
_F200 	!WORD	_D096+0		
	!BYTE	$30			; DROP 
; samplesrc/maze.pla: 0473:     puts("Play again? (Y/N):")
	!BYTE	$2E			; CS
	!BYTE	$12
	!BYTE	$50,$6C,$61,$79,$20,$61,$67,$61
	!BYTE	$69,$6E,$3F,$20,$28,$59,$2F,$4E
	!BYTE	$29,$3A
	!BYTE	$54			; CALL	_X004
_F201 	!WORD	0		
; samplesrc/maze.pla: 0474: until toupper(conio:getkey()) <> 'Y'
_B173 
	!BYTE	$6A			; LAW	_X028+2
_F202 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_X021
_F203 	!WORD	0		
	!BYTE	$2A,$59			; CB	89
	!BYTE	$22			; BREQ	_B172
	!WORD	_B172-*
_B171 
; samplesrc/maze.pla: 0475: conio:textmode(0)
; samplesrc/maze.pla: 0476: done
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X028+14
_F204 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_DEFCNT	=	15
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	83			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	70			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	87			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	40			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	85			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	78			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	82			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	91			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	90			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	38			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	78			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	60			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	36			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	48			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	38			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	60			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTI
	!BYTE	$D0,$D5,$D4,$49
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	5			; ESD INDEX
	; DCI STRING: GETC
	!BYTE	$C7,$C5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	6			; ESD INDEX
	; DCI STRING: HEAPMARK
	!BYTE	$C8,$C5,$C1,$D0,$CD,$C1,$D2,$4B
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	12			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: ARGFIRST
	!BYTE	$C1,$D2,$C7,$C6,$C9,$D2,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: ARGNEXT
	!BYTE	$C1,$D2,$C7,$CE,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: ZERO32
	!BYTE	$DA,$C5,$D2,$CF,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	33			; ESD INDEX
	; DCI STRING: LOAD32
	!BYTE	$CC,$CF,$C1,$C4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	36			; ESD INDEX
	; DCI STRING: STORE32
	!BYTE	$D3,$D4,$CF,$D2,$C5,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	38			; ESD INDEX
	; DCI STRING: ADDI16
	!BYTE	$C1,$C4,$C4,$C9,$B1,$36
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	40			; ESD INDEX
	; DCI STRING: DIVI16
	!BYTE	$C4,$C9,$D6,$C9,$B1,$36
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	48			; ESD INDEX
	; DCI STRING: PUTI32
	!BYTE	$D0,$D5,$D4,$C9,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	60			; ESD INDEX
	; DCI STRING: HGRRECT
	!BYTE	$C8,$C7,$D2,$D2,$C5,$C3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	70			; ESD INDEX
	; DCI STRING: HGRMODE
	!BYTE	$C8,$C7,$D2,$CD,$CF,$C4,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	78			; ESD INDEX
	; DCI STRING: HGRDRAWBUF
	!BYTE	$C8,$C7,$D2,$C4,$D2,$C1,$D7,$C2,$D5,$46
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	82			; ESD INDEX
	; DCI STRING: HGRCOLOR
	!BYTE	$C8,$C7,$D2,$C3,$CF,$CC,$CF,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	83			; ESD INDEX
	; DCI STRING: TILEDRAW
	!BYTE	$D4,$C9,$CC,$C5,$C4,$D2,$C1,$57
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	85			; ESD INDEX
	; DCI STRING: TILEORDRAW
	!BYTE	$D4,$C9,$CC,$C5,$CF,$D2,$C4,$D2,$C1,$57
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	87			; ESD INDEX
	; DCI STRING: TILEFROMTEXT
	!BYTE	$D4,$C9,$CC,$C5,$C6,$D2,$CF,$CD,$D4,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	90			; ESD INDEX
	; DCI STRING: TILEDRAWBUF
	!BYTE	$D4,$C9,$CC,$C5,$C4,$D2,$C1,$D7,$C2,$D5,$46
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	91			; ESD INDEX
	!BYTE	$00			; END OF ESD
