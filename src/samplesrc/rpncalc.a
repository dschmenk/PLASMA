; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; samplesrc/rpncalc.pla: 0001: //
; samplesrc/rpncalc.pla: 0002: // Desktop RPN calculator
; samplesrc/rpncalc.pla: 0003: //
; samplesrc/rpncalc.pla: 0004: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; samplesrc/rpncalc.pla: 0004: 
; samplesrc/rpncalc.pla: 0005: include "inc/fpstr.plh"
; inc/fpstr.plh: 0001: import fpstr
	; DCI STRING: FPSTR
	!BYTE	$C6,$D0,$D3,$D4,$52
					; FPSTR -> X028
; inc/fpstr.plh: 0002: //
; inc/fpstr.plh: 0003: // String formatting bits
; inc/fpstr.plh: 0004: //
; inc/fpstr.plh: 0005: const FPSTR_FIXED = 1 // Fixed count of fractional digits
					; FPSTR_FIXED = 1
; inc/fpstr.plh: 0006: const FPSTR_FLOAT = 0 // Floating count of fractional digits
					; FPSTR_FLOAT = 0
; inc/fpstr.plh: 0007: const FPSTR_STRIP = 2 // Strip trailing fractional zeros
					; FPSTR_STRIP = 2
; inc/fpstr.plh: 0008: const FPSTR_EXP   = 4 // Force exponential format
					; FPSTR_EXP = 4
; inc/fpstr.plh: 0009: const FPSTR_FLEX  = 8 // Flexible switch to EXP format if over/underflow
					; FPSTR_FLEX = 8
; inc/fpstr.plh: 0010: //
; inc/fpstr.plh: 0011: // Parse string into decrecord, return SANE conversion output
; inc/fpstr.plh: 0012: //
; inc/fpstr.plh: 0013: predef str2ext(str, ext)#1
					; STR2EXT -> X029
; inc/fpstr.plh: 0014: //
; inc/fpstr.plh: 0015: // Convert extended FP to string using , return string
; inc/fpstr.plh: 0016: //
; inc/fpstr.plh: 0017: predef ext2str(ext, str, intdigits, fracdigits, format)#1
					; EXT2STR -> X030
; inc/fpstr.plh: 0018: end
; samplesrc/rpncalc.pla: 0005: 
; samplesrc/rpncalc.pla: 0006: include "inc/fpu.plh"
; inc/fpu.plh: 0001: import fpu
	; DCI STRING: FPU
	!BYTE	$C6,$D0,$55
					; FPU -> X031
; inc/fpu.plh: 0002: //
; inc/fpu.plh: 0003: // FPU register type
; inc/fpu.plh: 0004: //
; inc/fpu.plh: 0005: struc t_fpureg
; inc/fpu.plh: 0006:     byte[10] _regdata
					; _regdata = 0
; inc/fpu.plh: 0007: end
					; t_fpureg = 10
; inc/fpu.plh: 0008: //
; inc/fpu.plh: 0009: // RPN Register indeces
; inc/fpu.plh: 0010: //
; inc/fpu.plh: 0011: const X_REG = 0
					; X_REG = 0
; inc/fpu.plh: 0012: const Y_REG = 1
					; Y_REG = 1
; inc/fpu.plh: 0013: const Z_REG = 2
					; Z_REG = 2
; inc/fpu.plh: 0014: const T_REG = 3
					; T_REG = 3
; inc/fpu.plh: 0015: //
; inc/fpu.plh: 0016: // Comparison results
; inc/fpu.plh: 0017: //
; inc/fpu.plh: 0018: const FPUCMPGT = $4040      // Greater Than
					; FPUCMPGT = 16448
; inc/fpu.plh: 0019: const FPUCMPLT = $8080      // Less Than
					; FPUCMPLT = 32896
; inc/fpu.plh: 0020: const FPUCMPEQ = $0002      // EQual
					; FPUCMPEQ = 2
; inc/fpu.plh: 0021: const FPUCMPUN = $0101      // UNordered
					; FPUCMPUN = 257
; inc/fpu.plh: 0022: //
; inc/fpu.plh: 0023: // Exceptions
; inc/fpu.plh: 0024: //
; inc/fpu.plh: 0025: const FPUINVALID = $01
					; FPUINVALID = 1
; inc/fpu.plh: 0026: const FPUUFLOW   = $02
					; FPUUFLOW = 2
; inc/fpu.plh: 0027: const FPUOFLOW   = $04
					; FPUOFLOW = 4
; inc/fpu.plh: 0028: const FPUDIVZER  = $08
					; FPUDIVZER = 8
; inc/fpu.plh: 0029: const FPUINEXACT = $10
					; FPUINEXACT = 16
; inc/fpu.plh: 0030: //
; inc/fpu.plh: 0031: // FP type
; inc/fpu.plh: 0032: //
; inc/fpu.plh: 0033: const FPUSNAN    = $00FC    // -4: signaling NAN
					; FPUSNAN = 252
; inc/fpu.plh: 0034: const FPUQNAN    = $00FD    // -3: quiet NAN
					; FPUQNAN = 253
; inc/fpu.plh: 0035: const FPUINF     = $00FE    // -2: infinite
					; FPUINF = 254
; inc/fpu.plh: 0036: const FPUZERO    = $00FF    // -1: zero
					; FPUZERO = 255
; inc/fpu.plh: 0037: const FPUNORM    = $0000    //  0: normal
					; FPUNORM = 0
; inc/fpu.plh: 0038: const FPUDENORM  = $0001    //  1: denormal
					; FPUDENORM = 1
; inc/fpu.plh: 0039: const FPUNEG     = $8000
					; FPUNEG = 32768
; inc/fpu.plh: 0040: //
; inc/fpu.plh: 0041: // FPU API
; inc/fpu.plh: 0042: //
; inc/fpu.plh: 0043: struc t_fpu
; inc/fpu.plh: 0044:     word reset
					; reset = 0
; inc/fpu.plh: 0045:     word getEnv
					; getEnv = 2
; inc/fpu.plh: 0046:     word setEnv
					; setEnv = 4
; inc/fpu.plh: 0047:     word testExept
					; testExept = 6
; inc/fpu.plh: 0048:     word setExcept
					; setExcept = 8
; inc/fpu.plh: 0049:     word enterProc
					; enterProc = 10
; inc/fpu.plh: 0050:     word exitProc
					; exitProc = 12
; inc/fpu.plh: 0051:     word constPi
					; constPi = 14
; inc/fpu.plh: 0052:     word constE
					; constE = 16
; inc/fpu.plh: 0053:     word pushInt
					; pushInt = 18
; inc/fpu.plh: 0054:     word pushSgl
					; pushSgl = 20
; inc/fpu.plh: 0055:     word pushDbl
					; pushDbl = 22
; inc/fpu.plh: 0056:     word pushExt
					; pushExt = 24
; inc/fpu.plh: 0057:     word pushStr
					; pushStr = 26
; inc/fpu.plh: 0058:     word pullInt
					; pullInt = 28
; inc/fpu.plh: 0059:     word pullSgl
					; pullSgl = 30
; inc/fpu.plh: 0060:     word pullDbl
					; pullDbl = 32
; inc/fpu.plh: 0061:     word pullExt
					; pullExt = 34
; inc/fpu.plh: 0062:     word pullStr
					; pullStr = 36
; inc/fpu.plh: 0063:     word loadInt
					; loadInt = 38
; inc/fpu.plh: 0064:     word loadSgl
					; loadSgl = 40
; inc/fpu.plh: 0065:     word loadDbl
					; loadDbl = 42
; inc/fpu.plh: 0066:     word loadExt
					; loadExt = 44
; inc/fpu.plh: 0067:     word loadStr
					; loadStr = 46
; inc/fpu.plh: 0068:     word storInt
					; storInt = 48
; inc/fpu.plh: 0069:     word storSgl
					; storSgl = 50
; inc/fpu.plh: 0070:     word storDbl
					; storDbl = 52
; inc/fpu.plh: 0071:     word storExt
					; storExt = 54
; inc/fpu.plh: 0072:     word storStr
					; storStr = 56
; inc/fpu.plh: 0073:     word shiftUp
					; shiftUp = 58
; inc/fpu.plh: 0074:     word shiftDown // dropX
					; shiftDown = 60
; inc/fpu.plh: 0075:     word rotateUp
					; rotateUp = 62
; inc/fpu.plh: 0076:     word rotateDown
					; rotateDown = 64
; inc/fpu.plh: 0077:     word dupX
					; dupX = 66
; inc/fpu.plh: 0078:     word swapXY
					; swapXY = 68
; inc/fpu.plh: 0079:     word clearX
					; clearX = 70
; inc/fpu.plh: 0080:     word addXY
					; addXY = 72
; inc/fpu.plh: 0081:     word subXY
					; subXY = 74
; inc/fpu.plh: 0082:     word mulXY
					; mulXY = 76
; inc/fpu.plh: 0083:     word divXY
					; divXY = 78
; inc/fpu.plh: 0084:     word remXY
					; remXY = 80
; inc/fpu.plh: 0085:     word negX
					; negX = 82
; inc/fpu.plh: 0086:     word absX
					; absX = 84
; inc/fpu.plh: 0087:     word typeX
					; typeX = 86
; inc/fpu.plh: 0088:     word cmpXY
					; cmpXY = 88
; inc/fpu.plh: 0089:     word logbX
					; logbX = 90
; inc/fpu.plh: 0090:     word scalebXInt
					; scalebXInt = 92
; inc/fpu.plh: 0091:     word truncX
					; truncX = 94
; inc/fpu.plh: 0092:     word roundX
					; roundX = 96
; inc/fpu.plh: 0093:     word sqrtX
					; sqrtX = 98
; inc/fpu.plh: 0094:     word squareX
					; squareX = 100
; inc/fpu.plh: 0095:     word cosX
					; cosX = 102
; inc/fpu.plh: 0096:     word sinX
					; sinX = 104
; inc/fpu.plh: 0097:     word tanX
					; tanX = 106
; inc/fpu.plh: 0098:     word atanX
					; atanX = 108
; inc/fpu.plh: 0099:     word log2X
					; log2X = 110
; inc/fpu.plh: 0100:     word log21X
					; log21X = 112
; inc/fpu.plh: 0101:     word lnX
					; lnX = 114
; inc/fpu.plh: 0102:     word ln1X
					; ln1X = 116
; inc/fpu.plh: 0103:     word pow2X
					; pow2X = 118
; inc/fpu.plh: 0104:     word pow21X
					; pow21X = 120
; inc/fpu.plh: 0105:     word powEX
					; powEX = 122
; inc/fpu.plh: 0106:     word powE1X
					; powE1X = 124
; inc/fpu.plh: 0107:     word powE21X
					; powE21X = 126
; inc/fpu.plh: 0108:     word powXInt
					; powXInt = 128
; inc/fpu.plh: 0109:     word powXY
					; powXY = 130
; inc/fpu.plh: 0110:     word compXY
					; compXY = 132
; inc/fpu.plh: 0111:     word annuityXY
					; annuityXY = 134
; inc/fpu.plh: 0112:     word randNum
					; randNum = 136
; inc/fpu.plh: 0113: end
					; t_fpu = 138
; inc/fpu.plh: 0114: const dropX = shiftDown // Alias dropX and shiftDown
					; dropX = 60
; inc/fpu.plh: 0115: end
; samplesrc/rpncalc.pla: 0006: 
; samplesrc/rpncalc.pla: 0007: include "inc/conio.plh"
; inc/conio.plh: 0001: import conio
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
					; CONIO -> X032
; inc/conio.plh: 0002:     //
; inc/conio.plh: 0003:     // ASCII key values
; inc/conio.plh: 0004:     //
; inc/conio.plh: 0005:     const keyarrowdown  = $0A
					; keyarrowdown = 10
; inc/conio.plh: 0006:     const keyarrowup    = $0B
					; keyarrowup = 11
; inc/conio.plh: 0007:     const keyarrowleft  = $08
					; keyarrowleft = 8
; inc/conio.plh: 0008:     const keyarrowright = $15
					; keyarrowright = 21
; inc/conio.plh: 0009:     const keyenter      = $0D
					; keyenter = 13
; inc/conio.plh: 0010:     const keyescape     = $1B
					; keyescape = 27
; inc/conio.plh: 0011:     const keyctrla      = $01
					; keyctrla = 1
; inc/conio.plh: 0012:     const keyctrlb      = $02
					; keyctrlb = 2
; inc/conio.plh: 0013:     const keyctrlc      = $03
					; keyctrlc = 3
; inc/conio.plh: 0014:     const keyctrld      = $04
					; keyctrld = 4
; inc/conio.plh: 0015:     const keyctrle      = $05
					; keyctrle = 5
; inc/conio.plh: 0016:     const keyctrlf      = $06
					; keyctrlf = 6
; inc/conio.plh: 0017:     const keyctrlg      = $07
					; keyctrlg = 7
; inc/conio.plh: 0018:     const keyctrli      = $09
					; keyctrli = 9
; inc/conio.plh: 0019:     const keyctrlk      = $0B
					; keyctrlk = 11
; inc/conio.plh: 0020:     const keyctrll      = $0C
					; keyctrll = 12
; inc/conio.plh: 0021:     const keyctrln      = $0E
					; keyctrln = 14
; inc/conio.plh: 0022:     const keyctrlo      = $0F
					; keyctrlo = 15
; inc/conio.plh: 0023:     const keyctrlp      = $10
					; keyctrlp = 16
; inc/conio.plh: 0024:     const keyctrlq      = $11
					; keyctrlq = 17
; inc/conio.plh: 0025:     const keyctrlr      = $12
					; keyctrlr = 18
; inc/conio.plh: 0026:     const keyctrls      = $13
					; keyctrls = 19
; inc/conio.plh: 0027:     const keyctrlt      = $14
					; keyctrlt = 20
; inc/conio.plh: 0028:     const keyctrlu      = $15
					; keyctrlu = 21
; inc/conio.plh: 0029:     const keyctrlv      = $16
					; keyctrlv = 22
; inc/conio.plh: 0030:     const keyctrlw      = $17
					; keyctrlw = 23
; inc/conio.plh: 0031:     const keyctrlx      = $18
					; keyctrlx = 24
; inc/conio.plh: 0032:     const keyctrly      = $19
					; keyctrly = 25
; inc/conio.plh: 0033:     const keyctrlz      = $1A
					; keyctrlz = 26
; inc/conio.plh: 0034:     const keytab        = keyctrli
					; keytab = 9
; inc/conio.plh: 0035:     const keydetab      = $1D
					; keydetab = 29
; inc/conio.plh: 0036:     const keyspace      = $20
					; keyspace = 32
; inc/conio.plh: 0037:     const keydelete     = $7F
					; keydelete = 127
; inc/conio.plh: 0038:     //
; inc/conio.plh: 0039:     // Option/Solid-Apple key modifier
; inc/conio.plh: 0040:     //
; inc/conio.plh: 0041:     const keyoptmod     = $80
					; keyoptmod = 128
; inc/conio.plh: 0042:     //
; inc/conio.plh: 0043:     // Clear optioms
; inc/conio.plh: 0044:     //
; inc/conio.plh: 0045:     const cleol         = 1
					; cleol = 1
; inc/conio.plh: 0046:     const cleos         = 2
					; cleos = 2
; inc/conio.plh: 0047:     const cls           = 3
					; cls = 3
; inc/conio.plh: 0048:     //
; inc/conio.plh: 0049:     // Control Codes
; inc/conio.plh: 0050:     //
; inc/conio.plh: 0051:     const ctrlattr      = 1
					; ctrlattr = 1
; inc/conio.plh: 0052:     const ctrlecho      = 2
					; ctrlecho = 2
; inc/conio.plh: 0053:     const ctrlcursor    = 3
					; ctrlcursor = 3
; inc/conio.plh: 0054:     const ctrlcase      = 4
					; ctrlcase = 4
; inc/conio.plh: 0055:     const ctrlscroll    = 5
					; ctrlscroll = 5
; inc/conio.plh: 0056:     //
; inc/conio.plh: 0057:     // Control parameters
; inc/conio.plh: 0058:     //
; inc/conio.plh: 0059:     const OFF           = 0
					; OFF = 0
; inc/conio.plh: 0060:     const ON            = 1
					; ON = 1
; inc/conio.plh: 0061:     const NORMAL        = $FF
					; NORMAL = 255
; inc/conio.plh: 0062:     const INVERSE       = $3F
					; INVERSE = 63
; inc/conio.plh: 0063:     const FLASH         = $7F
					; FLASH = 127
; inc/conio.plh: 0064:     const UP            = 1
					; UP = 1
; inc/conio.plh: 0065:     const DOWN          = -1
					; DOWN = -1
; inc/conio.plh: 0066:     //
; inc/conio.plh: 0067:     // Additional modes available on VIDEX UltraTerm
; inc/conio.plh: 0068:     //
; inc/conio.plh: 0069:     const UTmode80x24   = 1
					; UTmode80x24 = 1
; inc/conio.plh: 0070:     const UTmode96x24   = 2
					; UTmode96x24 = 2
; inc/conio.plh: 0071:     const UTmode160x24  = 3
					; UTmode160x24 = 3
; inc/conio.plh: 0072:     const UTmode80x24I  = 4
					; UTmode80x24I = 4
; inc/conio.plh: 0073:     const UTmode80x32I  = 5
					; UTmode80x32I = 5
; inc/conio.plh: 0074:     const UTmode80x48I  = 6
					; UTmode80x48I = 6
; inc/conio.plh: 0075:     const UTmode132x24I = 7
					; UTmode132x24I = 7
; inc/conio.plh: 0076:     const UTmode128x32I = 8
					; UTmode128x32I = 8
; inc/conio.plh: 0077:     //
; inc/conio.plh: 0078:     // API
; inc/conio.plh: 0079:     //
; inc/conio.plh: 0080:     struc t_conio
; inc/conio.plh: 0081:         word keypressed
					; keypressed = 0
; inc/conio.plh: 0082:         word getkey
					; getkey = 2
; inc/conio.plh: 0083:         word putchars
					; putchars = 4
; inc/conio.plh: 0084:         word clear
					; clear = 6
; inc/conio.plh: 0085:         word gotoxy
					; gotoxy = 8
; inc/conio.plh: 0086:         word viewport
					; viewport = 10
; inc/conio.plh: 0087:         word textctrl
					; textctrl = 12
; inc/conio.plh: 0088:         word textmode
					; textmode = 14
; inc/conio.plh: 0089:         word grmode
					; grmode = 16
; inc/conio.plh: 0090:         word grcolor
					; grcolor = 18
; inc/conio.plh: 0091:         word grplot
					; grplot = 20
; inc/conio.plh: 0092:         word tone
					; tone = 22
; inc/conio.plh: 0093:         word rnd
					; rnd = 24
; inc/conio.plh: 0094:     end
					; t_conio = 26
; inc/conio.plh: 0095: end
; samplesrc/rpncalc.pla: 0007: 
; samplesrc/rpncalc.pla: 0008: const displayWidth = 15
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; displayWidth = 15
; samplesrc/rpncalc.pla: 0009: const displayDefFix = 6
					; displayDefFix = 6
; samplesrc/rpncalc.pla: 0010: const inputLen = displayWidth+1
					; inputLen = 16
; samplesrc/rpncalc.pla: 0011: const ZEROSTR = $3001
					; ZEROSTR = 12289
; samplesrc/rpncalc.pla: 0012: //
; samplesrc/rpncalc.pla: 0013: // Keypad structure
; samplesrc/rpncalc.pla: 0014: //
; samplesrc/rpncalc.pla: 0015: struc t_keypad
; samplesrc/rpncalc.pla: 0016:   byte keychar
					; keychar = 0
; samplesrc/rpncalc.pla: 0017:   byte xpos
					; xpos = 1
; samplesrc/rpncalc.pla: 0018:   byte ypos
					; ypos = 2
; samplesrc/rpncalc.pla: 0019:   byte keystr[8]
					; keystr = 3
; samplesrc/rpncalc.pla: 0020: end
					; t_keypad = 11
; samplesrc/rpncalc.pla: 0021: struc t_keyinput
; samplesrc/rpncalc.pla: 0022:   byte keyinfo[t_keypad]
					; keyinfo = 0
; samplesrc/rpncalc.pla: 0023:   word phandler
					; phandler = 11
; samplesrc/rpncalc.pla: 0024: end
					; t_keyinput = 13
; samplesrc/rpncalc.pla: 0025: predef delKey(pkey)#0, cmdKey(pkey)#0, dropKey(pkey)#0, clearKey(pkey)#0
; samplesrc/rpncalc.pla: 0026: predef digitKey(pkey)#0, pointKey(pkey)#0, opKey(pkey)#0
; samplesrc/rpncalc.pla: 0027: predef enterKey(pkey)#0, copyKey(pkey)#0, chsKey(pkey)#0, memKey(pkey)#0
; samplesrc/rpncalc.pla: 0028: predef elemsKey(pkey)#0
; samplesrc/rpncalc.pla: 0029: //
; samplesrc/rpncalc.pla: 0030: // Run state
; samplesrc/rpncalc.pla: 0031: //
; samplesrc/rpncalc.pla: 0032: byte quit = FALSE
_D045 					; quit = FALSE
	!BYTE	$00
; samplesrc/rpncalc.pla: 0033: //
; samplesrc/rpncalc.pla: 0034: // Current input
; samplesrc/rpncalc.pla: 0035: //
; samplesrc/rpncalc.pla: 0036: byte inputStr[32] = ""
_D046 					; inputStr[32] = ""
	!BYTE	$00
	!FILL	$1F
; samplesrc/rpncalc.pla: 0037: //
; samplesrc/rpncalc.pla: 0038: // Display format state
; samplesrc/rpncalc.pla: 0039: //
; samplesrc/rpncalc.pla: 0040: byte displayFix = displayDefFix
_D047 					; displayFix = displayDefFix
	!BYTE	$06
; samplesrc/rpncalc.pla: 0041: byte displayInt = displayWidth - displayDefFix - 2
_D048 					; displayInt = displayWidth - displayDefFix - 2
	!BYTE	$07
; samplesrc/rpncalc.pla: 0042: //
; samplesrc/rpncalc.pla: 0043: // Store/load memory
; samplesrc/rpncalc.pla: 0044: //
; samplesrc/rpncalc.pla: 0045: byte memory[10*t_fpureg]
_D049 	!FILL	100			; memory[10*t_fpureg]
; samplesrc/rpncalc.pla: 0046: //
; samplesrc/rpncalc.pla: 0047: // Key values
; samplesrc/rpncalc.pla: 0048: //
; samplesrc/rpncalc.pla: 0049: byte[t_keypad] keypad = $08, 0, 0, ""
_D050 					; keypad = $08, 0, 0, ""
	!BYTE	$08
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!FILL	$07
; samplesrc/rpncalc.pla: 0050: word          = @delKey
_F000 	!WORD	_P000
; samplesrc/rpncalc.pla: 0051: byte[t_keypad]    = $1B, 0, 0, ""
	!BYTE	$1B
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!FILL	$07
; samplesrc/rpncalc.pla: 0052: word          = @cmdKey
_F001 	!WORD	_P001
; samplesrc/rpncalc.pla: 0053: byte[t_keypad]    = '=', 0, 0, ""
	!BYTE	$3D
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!FILL	$07
; samplesrc/rpncalc.pla: 0054: word          = @copyKey
_F002 	!WORD	_P008
; samplesrc/rpncalc.pla: 0055: byte[t_keypad]    = 'Z', 0, 0, ""
	!BYTE	$5A
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!FILL	$07
; samplesrc/rpncalc.pla: 0056: word          = @clearKey
_F003 	!WORD	_P003
; samplesrc/rpncalc.pla: 0057: byte[t_keypad]    = '7',  3, 10, "[7]"
	!BYTE	$37
	!BYTE	$03
	!BYTE	$0A
	!BYTE	$03
	!BYTE	$5B,$37,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0058: word          = @digitKey
_F004 	!WORD	_P004
; samplesrc/rpncalc.pla: 0059: byte[t_keypad]    = '8',  7, 10, "[8]"
	!BYTE	$38
	!BYTE	$07
	!BYTE	$0A
	!BYTE	$03
	!BYTE	$5B,$38,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0060: word          = @digitKey
_F005 	!WORD	_P004
; samplesrc/rpncalc.pla: 0061: byte[t_keypad]    = '9', 11, 10, "[9]"
	!BYTE	$39
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$03
	!BYTE	$5B,$39,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0062: word          = @digitKey
_F006 	!WORD	_P004
; samplesrc/rpncalc.pla: 0063: byte[t_keypad]    = '/', 15, 10, "[/]"
	!BYTE	$2F
	!BYTE	$0F
	!BYTE	$0A
	!BYTE	$03
	!BYTE	$5B,$2F,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0064: word          = @opKey
_F007 	!WORD	_P006
; samplesrc/rpncalc.pla: 0065: byte[t_keypad]    = '4',  3, 12, "[4]"
	!BYTE	$34
	!BYTE	$03
	!BYTE	$0C
	!BYTE	$03
	!BYTE	$5B,$34,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0066: word          = @digitKey
_F008 	!WORD	_P004
; samplesrc/rpncalc.pla: 0067: byte[t_keypad]    = '5',  7, 12, "[5]"
	!BYTE	$35
	!BYTE	$07
	!BYTE	$0C
	!BYTE	$03
	!BYTE	$5B,$35,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0068: word          = @digitKey
_F009 	!WORD	_P004
; samplesrc/rpncalc.pla: 0069: byte[t_keypad]    = '6', 11, 12, "[6]"
	!BYTE	$36
	!BYTE	$0B
	!BYTE	$0C
	!BYTE	$03
	!BYTE	$5B,$36,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0070: word          = @digitKey
_F010 	!WORD	_P004
; samplesrc/rpncalc.pla: 0071: byte[t_keypad]    = '*', 15, 12, "[*]"
	!BYTE	$2A
	!BYTE	$0F
	!BYTE	$0C
	!BYTE	$03
	!BYTE	$5B,$2A,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0072: word          = @opKey
_F011 	!WORD	_P006
; samplesrc/rpncalc.pla: 0073: byte[t_keypad]    = '1',  3, 14, "[1]"
	!BYTE	$31
	!BYTE	$03
	!BYTE	$0E
	!BYTE	$03
	!BYTE	$5B,$31,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0074: word          = @digitKey
_F012 	!WORD	_P004
; samplesrc/rpncalc.pla: 0075: byte[t_keypad]    = '2',  7, 14, "[2]"
	!BYTE	$32
	!BYTE	$07
	!BYTE	$0E
	!BYTE	$03
	!BYTE	$5B,$32,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0076: word          = @digitKey
_F013 	!WORD	_P004
; samplesrc/rpncalc.pla: 0077: byte[t_keypad]    = '3', 11, 14, "[3]"
	!BYTE	$33
	!BYTE	$0B
	!BYTE	$0E
	!BYTE	$03
	!BYTE	$5B,$33,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0078: word          = @digitKey
_F014 	!WORD	_P004
; samplesrc/rpncalc.pla: 0079: byte[t_keypad]    = '-', 15, 14, "[-]"
	!BYTE	$2D
	!BYTE	$0F
	!BYTE	$0E
	!BYTE	$03
	!BYTE	$5B,$2D,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0080: word          = @opKey
_F015 	!WORD	_P006
; samplesrc/rpncalc.pla: 0081: byte[t_keypad]    = '0',  3, 16, "[0]"
	!BYTE	$30
	!BYTE	$03
	!BYTE	$10
	!BYTE	$03
	!BYTE	$5B,$30,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0082: word          = @digitKey
_F016 	!WORD	_P004
; samplesrc/rpncalc.pla: 0083: byte[t_keypad]    = '.',  7, 16, "[.]"
	!BYTE	$2E
	!BYTE	$07
	!BYTE	$10
	!BYTE	$03
	!BYTE	$5B,$2E,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0084: word          = @pointKey
_F017 	!WORD	_P005
; samplesrc/rpncalc.pla: 0085: byte[t_keypad]    = 'X', 11, 16, "[X]"
	!BYTE	$58
	!BYTE	$0B
	!BYTE	$10
	!BYTE	$03
	!BYTE	$5B,$58,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0086: word          = @dropKey
_F018 	!WORD	_P002
; samplesrc/rpncalc.pla: 0087: byte[t_keypad]    = '+', 15, 16, "[+]"
	!BYTE	$2B
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$03
	!BYTE	$5B,$2B,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0088: word          = @opKey
_F019 	!WORD	_P006
; samplesrc/rpncalc.pla: 0089: byte[t_keypad]    = $0D,  3, 18, "[ENTER]"
	!BYTE	$0D
	!BYTE	$03
	!BYTE	$12
	!BYTE	$07
	!BYTE	$5B,$45,$4E,$54,$45,$52,$5D
; samplesrc/rpncalc.pla: 0090: word          = @enterKey
_F020 	!WORD	_P007
; samplesrc/rpncalc.pla: 0091: byte[t_keypad]    = '<', 11, 18, "[<]"
	!BYTE	$3C
	!BYTE	$0B
	!BYTE	$12
	!BYTE	$03
	!BYTE	$5B,$3C,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0092: word          = @memKey
_F021 	!WORD	_P010
; samplesrc/rpncalc.pla: 0093: byte[t_keypad]    = '>', 15, 18, "[>]"
	!BYTE	$3E
	!BYTE	$0F
	!BYTE	$12
	!BYTE	$03
	!BYTE	$5B,$3E,$5D
	!FILL	$04
; samplesrc/rpncalc.pla: 0094: word          = @memKey
_F022 	!WORD	_P010
; samplesrc/rpncalc.pla: 0095: byte[t_keypad]    = 'R', 3, 20, "[SQ(R)]"
	!BYTE	$52
	!BYTE	$03
	!BYTE	$14
	!BYTE	$07
	!BYTE	$5B,$53,$51,$28,$52,$29,$5D
; samplesrc/rpncalc.pla: 0096: word          = @opKey
_F023 	!WORD	_P006
; samplesrc/rpncalc.pla: 0097: byte[t_keypad]    = 'H', 11, 20, "[C(H)S]"
	!BYTE	$48
	!BYTE	$0B
	!BYTE	$14
	!BYTE	$07
	!BYTE	$5B,$43,$28,$48,$29,$53,$5D
; samplesrc/rpncalc.pla: 0098: word          = @chsKey
_F024 	!WORD	_P009
; samplesrc/rpncalc.pla: 0099: byte[t_keypad]    = 'C', 22, 14, "[(C)OS]"
	!BYTE	$43
	!BYTE	$16
	!BYTE	$0E
	!BYTE	$07
	!BYTE	$5B,$28,$43,$29,$4F,$53,$5D
; samplesrc/rpncalc.pla: 0100: word          = @elemsKey
_F025 	!WORD	_P011
; samplesrc/rpncalc.pla: 0101: byte[t_keypad]    = 'S', 22, 16, "[(S)IN]"
	!BYTE	$53
	!BYTE	$16
	!BYTE	$10
	!BYTE	$07
	!BYTE	$5B,$28,$53,$29,$49,$4E,$5D
; samplesrc/rpncalc.pla: 0102: word          = @elemsKey
_F026 	!WORD	_P011
; samplesrc/rpncalc.pla: 0103: byte[t_keypad]    = 'T', 22, 18, "[(T)AN]"
	!BYTE	$54
	!BYTE	$16
	!BYTE	$12
	!BYTE	$07
	!BYTE	$5B,$28,$54,$29,$41,$4E,$5D
; samplesrc/rpncalc.pla: 0104: word          = @elemsKey
_F027 	!WORD	_P011
; samplesrc/rpncalc.pla: 0105: byte[t_keypad]    = 'A', 22, 20, "[(A)TN]"
	!BYTE	$41
	!BYTE	$16
	!BYTE	$14
	!BYTE	$07
	!BYTE	$5B,$28,$41,$29,$54,$4E,$5D
; samplesrc/rpncalc.pla: 0106: word          = @elemsKey
_F028 	!WORD	_P011
; samplesrc/rpncalc.pla: 0107: byte[t_keypad]    = '^', 30, 14, "[X(^)Y]"
	!BYTE	$5E
	!BYTE	$1E
	!BYTE	$0E
	!BYTE	$07
	!BYTE	$5B,$58,$28,$5E,$29,$59,$5D
; samplesrc/rpncalc.pla: 0108: word          = @elemsKey
_F029 	!WORD	_P011
; samplesrc/rpncalc.pla: 0109: byte[t_keypad]    = 'L', 30, 16, "[(L)G2]"
	!BYTE	$4C
	!BYTE	$1E
	!BYTE	$10
	!BYTE	$07
	!BYTE	$5B,$28,$4C,$29,$47,$32,$5D
; samplesrc/rpncalc.pla: 0110: word          = @elemsKey
_F030 	!WORD	_P011
; samplesrc/rpncalc.pla: 0111: byte[t_keypad]    = 'E', 30, 18, "[(E)^X]"
	!BYTE	$45
	!BYTE	$1E
	!BYTE	$12
	!BYTE	$07
	!BYTE	$5B,$28,$45,$29,$5E,$58,$5D
; samplesrc/rpncalc.pla: 0112: word          = @elemsKey
_F031 	!WORD	_P011
; samplesrc/rpncalc.pla: 0113: byte[t_keypad]    = 'N', 30, 20, "[L(N)X]"
	!BYTE	$4E
	!BYTE	$1E
	!BYTE	$14
	!BYTE	$07
	!BYTE	$5B,$4C,$28,$4E,$29,$58,$5D
; samplesrc/rpncalc.pla: 0114: word          = @elemsKey
_F032 	!WORD	_P011
; samplesrc/rpncalc.pla: 0115: byte          = 0
	!BYTE	$00
; samplesrc/rpncalc.pla: 0116: //
; samplesrc/rpncalc.pla: 0117: // Utility routines
; samplesrc/rpncalc.pla: 0118: //
; samplesrc/rpncalc.pla: 0119: def repc(rep, c)#0
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
					; rep -> [0]
					; c -> [2]
_C000 					; repc()
; samplesrc/rpncalc.pla: 0120:   while rep > 0
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$50			; BRNCH	_B003
	!WORD	_B003-*
_B001 
; samplesrc/rpncalc.pla: 0121:     putc(c)
; samplesrc/rpncalc.pla: 0122:     rep--
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X002
_F033 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0123:   loop
	!BYTE	$76,$00			; SLW	[0]
_B003 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
_B002 
; samplesrc/rpncalc.pla: 0124: end
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/rpncalc.pla: 0125: def rect(x, y, width, height, frame, title)#0
					; x -> [0]
					; y -> [2]
					; width -> [4]
					; height -> [6]
					; frame -> [8]
					; title -> [10]
_C001 					; rect()
; samplesrc/rpncalc.pla: 0126:   byte i
					; i -> [12]
; samplesrc/rpncalc.pla: 0127: 
; samplesrc/rpncalc.pla: 0128:   conio:gotoxy(x + 1, y)
	!BYTE	$58,$0D,$06		; ENTER	13,6
; samplesrc/rpncalc.pla: 0129:   repc(width - 2, frame ?? '#' :: '-')
; samplesrc/rpncalc.pla: 0130:   conio:gotoxy(x + 1, y + height - 1)
; samplesrc/rpncalc.pla: 0131:   repc(width - 2, frame ?? '#' :: '-')
; samplesrc/rpncalc.pla: 0132:   for i = 1 to height - 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_X032+8
_F034 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$2A,$23			; CB	35
	!BYTE	$50			; BRNCH	_B007
	!WORD	_B007-*
_B006 
	!BYTE	$2A,$2D			; CB	45
_B007 
	!BYTE	$54			; CALL	_C000
_F035 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_X032+8
_F036 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B010
	!WORD	_B010-*
	!BYTE	$2A,$23			; CB	35
	!BYTE	$50			; BRNCH	_B011
	!WORD	_B011-*
_B010 
	!BYTE	$2A,$2D			; CB	45
_B011 
	!BYTE	$54			; CALL	_C000
_F037 	!WORD	_C000		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8E			; DECR
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B012
	!WORD	_B012-*
_B013 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rpncalc.pla: 0133:     conio:gotoxy(x, y + i)
; samplesrc/rpncalc.pla: 0134:     putc(frame ?? '#' :: '!')
; samplesrc/rpncalc.pla: 0135:     conio:gotoxy(x + width - 1, y + i)
; samplesrc/rpncalc.pla: 0136:     putc(frame ?? '#' :: '!')
; samplesrc/rpncalc.pla: 0137:   next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$6A			; LAW	_X032+8
_F038 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B017
	!WORD	_B017-*
	!BYTE	$2A,$23			; CB	35
	!BYTE	$50			; BRNCH	_B018
	!WORD	_B018-*
_B017 
	!BYTE	$2A,$21			; CB	33
_B018 
	!BYTE	$54			; CALL	_X002
_F039 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$8E			; DECR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$6A			; LAW	_X032+8
_F040 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B021
	!WORD	_B021-*
	!BYTE	$2A,$23			; CB	35
	!BYTE	$50			; BRNCH	_B022
	!WORD	_B022-*
_B021 
	!BYTE	$2A,$21			; CB	33
_B022 
	!BYTE	$54			; CALL	_X002
_F041 	!WORD	0		
_B014 
	!BYTE	$A4			; INCBRLE	_B013
	!WORD	_B013-*
_B012 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0138:   conio:gotoxy(x, y)
; samplesrc/rpncalc.pla: 0139:   putc(frame ?? '/' :: '+')
; samplesrc/rpncalc.pla: 0140:   conio:gotoxy(x + width - 1, y)
; samplesrc/rpncalc.pla: 0141:   putc(frame ?? '\\' :: '+')
; samplesrc/rpncalc.pla: 0142:   conio:gotoxy(x, y + height - 1)
; samplesrc/rpncalc.pla: 0143:   putc(frame ?? '\\' :: '+')
; samplesrc/rpncalc.pla: 0144:   conio:gotoxy(x + width - 1, y + height - 1)
; samplesrc/rpncalc.pla: 0145:   putc(frame ?? '/' :: '+')
; samplesrc/rpncalc.pla: 0146:   if title
; samplesrc/rpncalc.pla: 0147:     conio:gotoxy(x + (width - ^title) / 2, y)
; samplesrc/rpncalc.pla: 0148:     puts(title)
; samplesrc/rpncalc.pla: 0149:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_X032+8
_F042 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B025
	!WORD	_B025-*
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$50			; BRNCH	_B026
	!WORD	_B026-*
_B025 
	!BYTE	$2A,$2B			; CB	43
_B026 
	!BYTE	$54			; CALL	_X002
_F043 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$8E			; DECR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_X032+8
_F044 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B029
	!WORD	_B029-*
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$50			; BRNCH	_B030
	!WORD	_B030-*
_B029 
	!BYTE	$2A,$2B			; CB	43
_B030 
	!BYTE	$54			; CALL	_X002
_F045 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_X032+8
_F046 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$50			; BRNCH	_B034
	!WORD	_B034-*
_B033 
	!BYTE	$2A,$2B			; CB	43
_B034 
	!BYTE	$54			; CALL	_X002
_F047 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$8E			; DECR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_X032+8
_F048 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B037
	!WORD	_B037-*
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$50			; BRNCH	_B038
	!WORD	_B038-*
_B037 
	!BYTE	$2A,$2B			; CB	43
_B038 
	!BYTE	$54			; CALL	_X002
_F049 	!WORD	0		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$4C			; BRFLS	_B039
	!WORD	_B039-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$82			; ADD 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_X032+8
_F050 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_X004
_F051 	!WORD	0		
_B039 
_B040 
; samplesrc/rpncalc.pla: 0150: end
	!BYTE	$5A,$0D			; LEAVE	13
; samplesrc/rpncalc.pla: 0151: def showStack#0
_C002 					; showStack()
; samplesrc/rpncalc.pla: 0152:   byte s
					; s -> [0]
; samplesrc/rpncalc.pla: 0153:   byte strFP[displayWidth+1]
					; strFP -> [1]
; samplesrc/rpncalc.pla: 0154: 
; samplesrc/rpncalc.pla: 0155:   for s = 0 to 3
	!BYTE	$58,$11,$00		; ENTER	17,0
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B042 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rpncalc.pla: 0156:     fpu:storStr(@strFP, displayInt, displayFix, FPSTR_FIXED|FPSTR_FLEX, s)
; samplesrc/rpncalc.pla: 0157:     conio:gotoxy(4, 5 - s)
; samplesrc/rpncalc.pla: 0158:     //repc(displayWidth - strFP - 1, ' ')
; samplesrc/rpncalc.pla: 0159:     repc(displayWidth - strFP, ' ')
; samplesrc/rpncalc.pla: 0160:     puts(@strFP)
; samplesrc/rpncalc.pla: 0161:   next
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$68			; LAB	_D048+0
_F052 	!WORD	_D048+0		
	!BYTE	$68			; LAB	_D047+0
_F053 	!WORD	_D047+0		
	!BYTE	$12			; CN	9
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$6A			; LAW	_X031+56
_F054 	!WORD	0+56		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$0A			; CN	5
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_X032+8
_F055 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1E			; CN	15
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$84			; SUB 
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F056 	!WORD	_C000		
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$54			; CALL	_X004
_F057 	!WORD	0		
_B043 
	!BYTE	$A4			; INCBRLE	_B042
	!WORD	_B042-*
_B041 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0162: end
	!BYTE	$5A,$11			; LEAVE	17
; samplesrc/rpncalc.pla: 0163: def showMem#0
_C003 					; showMem()
; samplesrc/rpncalc.pla: 0164:   byte m
					; m -> [0]
; samplesrc/rpncalc.pla: 0165:   byte strFP[displayWidth+1]
					; strFP -> [1]
; samplesrc/rpncalc.pla: 0166: 
; samplesrc/rpncalc.pla: 0167:   for m = 0 to 9
	!BYTE	$58,$11,$00		; ENTER	17,0
	!BYTE	$12			; CN	9
	!BYTE	$00			; CN	0
_B045 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rpncalc.pla: 0168:     ext2str(@memory[m*t_fpureg], @strFP, displayInt, displayFix, FPSTR_FIXED|FPSTR_FLEX)
; samplesrc/rpncalc.pla: 0169:     conio:gotoxy(23, 2 + m)
; samplesrc/rpncalc.pla: 0170:     repc(displayWidth - strFP - 1, ' ')
; samplesrc/rpncalc.pla: 0171:     puts(@strFP)
; samplesrc/rpncalc.pla: 0172:   next
	!BYTE	$26			; LA	_D049+0
_F058 	!WORD	_D049+0		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$68			; LAB	_D048+0
_F059 	!WORD	_D048+0		
	!BYTE	$68			; LAB	_D047+0
_F060 	!WORD	_D047+0		
	!BYTE	$12			; CN	9
	!BYTE	$54			; CALL	_X030
_F061 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$17			; CB	23
	!BYTE	$04			; CN	2
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$6A			; LAW	_X032+8
_F062 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1E			; CN	15
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F063 	!WORD	_C000		
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$54			; CALL	_X004
_F064 	!WORD	0		
_B046 
	!BYTE	$A4			; INCBRLE	_B045
	!WORD	_B045-*
_B044 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0173: end
	!BYTE	$5A,$11			; LEAVE	17
; samplesrc/rpncalc.pla: 0174: def showInput#0
_C004 					; showInput()
; samplesrc/rpncalc.pla: 0175:   conio:gotoxy(2,7)
; samplesrc/rpncalc.pla: 0176:   repc(17 - inputStr, ' ')
; samplesrc/rpncalc.pla: 0177:   puts(@inputStr)
; samplesrc/rpncalc.pla: 0178: end
	!BYTE	$04			; CN	2
	!BYTE	$0E			; CN	7
	!BYTE	$6A			; LAW	_X032+8
_F065 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$11			; CB	17
	!BYTE	$68			; LAB	_D046+0
_F066 	!WORD	_D046+0		
	!BYTE	$84			; SUB 
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F067 	!WORD	_C000		
	!BYTE	$26			; LA	_D046+0
_F068 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_X004
_F069 	!WORD	0		
	!BYTE	$5C			; RET
; samplesrc/rpncalc.pla: 0179: def showStatus(pstr)#0
					; pstr -> [0]
_C005 					; showStatus()
; samplesrc/rpncalc.pla: 0180:   conio:gotoxy(0,23)
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0181:   puts(pstr)
; samplesrc/rpncalc.pla: 0182: end
	!BYTE	$00			; CN	0
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X032+8
_F070 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F071 	!WORD	0		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0183: def clearStatus#0
_C006 					; clearStatus()
; samplesrc/rpncalc.pla: 0184:   conio:gotoxy(0,23)
; samplesrc/rpncalc.pla: 0185:   repc(39, ' ')
; samplesrc/rpncalc.pla: 0186: end
	!BYTE	$00			; CN	0
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X032+8
_F072 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$27			; CB	39
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C000
_F073 	!WORD	_C000		
	!BYTE	$5C			; RET
; samplesrc/rpncalc.pla: 0187: def initInput#0
_C007 					; initInput()
; samplesrc/rpncalc.pla: 0188:   inputStr   = 0
; samplesrc/rpncalc.pla: 0189: end
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D046+0
_F074 	!WORD	_D046+0		
	!BYTE	$5C			; RET
; samplesrc/rpncalc.pla: 0190: def updateInput#0
_C008 					; updateInput()
; samplesrc/rpncalc.pla: 0191:   //
; samplesrc/rpncalc.pla: 0192:   // Lift stack if something input
; samplesrc/rpncalc.pla: 0193:   //
; samplesrc/rpncalc.pla: 0194:   if inputStr
; samplesrc/rpncalc.pla: 0195:     fpu:pushStr(@inputStr)
; samplesrc/rpncalc.pla: 0196:   fin
	!BYTE	$68			; LAB	_D046+0
_F075 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B047
	!WORD	_B047-*
	!BYTE	$26			; LA	_D046+0
_F076 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_X031+26
_F077 	!WORD	0+26		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B047 
_B048 
; samplesrc/rpncalc.pla: 0197:   initInput
; samplesrc/rpncalc.pla: 0198:   showInput
; samplesrc/rpncalc.pla: 0199: end
	!BYTE	$54			; CALL	_C007
_F078 	!WORD	_C007		
	!BYTE	$54			; CALL	_C004
_F079 	!WORD	_C004		
	!BYTE	$5C			; RET
; samplesrc/rpncalc.pla: 0200: def initDisplay#0
_C009 					; initDisplay()
; samplesrc/rpncalc.pla: 0201:   byte i
					; i -> [0]
; samplesrc/rpncalc.pla: 0202:   word pkeys
					; pkeys -> [1]
; samplesrc/rpncalc.pla: 0203: 
; samplesrc/rpncalc.pla: 0204:   conio:textmode(40)
	!BYTE	$58,$03,$00		; ENTER	3,0
; samplesrc/rpncalc.pla: 0205:   conio:clear(cls)
; samplesrc/rpncalc.pla: 0206:   rect(0, 0, 40, 23, 1, "<RPN Calculator>")
	!BYTE	$2A,$28			; CB	40
	!BYTE	$6A			; LAW	_X032+14
_F080 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X032+6
_F081 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$2A,$28			; CB	40
	!BYTE	$2A,$17			; CB	23
	!BYTE	$02			; CN	1
	!BYTE	$2E			; CS
	!BYTE	$10
	!BYTE	$3C,$52,$50,$4E,$20,$43,$61,$6C
	!BYTE	$63,$75,$6C,$61,$74,$6F,$72,$3E
	!BYTE	$54			; CALL	_C001
_F082 	!WORD	_C001		
; samplesrc/rpncalc.pla: 0207:   rect(1, 1, 19, 6, 0, ":Stack:")
	!BYTE	$02			; CN	1
	!BYTE	$34			; DUP
	!BYTE	$2A,$13			; CB	19
	!BYTE	$0C			; CN	6
	!BYTE	$00			; CN	0
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$3A,$53,$74,$61,$63,$6B,$3A
	!BYTE	$54			; CALL	_C001
_F083 	!WORD	_C001		
; samplesrc/rpncalc.pla: 0208:   rect(1, 6, 19, 3, 0, 0)
; samplesrc/rpncalc.pla: 0209:   conio:gotoxy(2, 2); puts("T:")
	!BYTE	$02			; CN	1
	!BYTE	$0C			; CN	6
	!BYTE	$2A,$13			; CB	19
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C001
_F084 	!WORD	_C001		
	!BYTE	$04			; CN	2
	!BYTE	$34			; DUP
	!BYTE	$6A			; LAW	_X032+8
_F085 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$54,$3A
	!BYTE	$54			; CALL	_X004
_F086 	!WORD	0		
; samplesrc/rpncalc.pla: 0210:   conio:gotoxy(2, 3); puts("Z:")
	!BYTE	$04			; CN	2
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X032+8
_F087 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$5A,$3A
	!BYTE	$54			; CALL	_X004
_F088 	!WORD	0		
; samplesrc/rpncalc.pla: 0211:   conio:gotoxy(2, 4); puts("Y:")
	!BYTE	$04			; CN	2
	!BYTE	$08			; CN	4
	!BYTE	$6A			; LAW	_X032+8
_F089 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$59,$3A
	!BYTE	$54			; CALL	_X004
_F090 	!WORD	0		
; samplesrc/rpncalc.pla: 0212:   conio:gotoxy(2, 5); puts("X:")
	!BYTE	$04			; CN	2
	!BYTE	$0A			; CN	5
	!BYTE	$6A			; LAW	_X032+8
_F091 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$58,$3A
	!BYTE	$54			; CALL	_X004
_F092 	!WORD	0		
; samplesrc/rpncalc.pla: 0213:   rect(20, 1, 19, 12, 0, ":Memory:")
	!BYTE	$2A,$14			; CB	20
	!BYTE	$02			; CN	1
	!BYTE	$2A,$13			; CB	19
	!BYTE	$18			; CN	12
	!BYTE	$00			; CN	0
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$3A,$4D,$65,$6D,$6F,$72,$79,$3A
	!BYTE	$54			; CALL	_C001
_F093 	!WORD	_C001		
; samplesrc/rpncalc.pla: 0214:   for i = 0 to 9
	!BYTE	$12			; CN	9
	!BYTE	$00			; CN	0
_B050 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rpncalc.pla: 0215:     conio:gotoxy(21, 2 + i); puti(i); putc(':')
; samplesrc/rpncalc.pla: 0216:   next
	!BYTE	$2A,$15			; CB	21
	!BYTE	$04			; CN	2
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$6A			; LAW	_X032+8
_F094 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X005
_F095 	!WORD	0		
	!BYTE	$2A,$3A			; CB	58
	!BYTE	$54			; CALL	_X002
_F096 	!WORD	0		
_B051 
	!BYTE	$A4			; INCBRLE	_B050
	!WORD	_B050-*
_B049 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0217:   pkeys = @keypad
; samplesrc/rpncalc.pla: 0218:   while ^pkeys
	!BYTE	$26			; LA	_D050+0
_F097 	!WORD	_D050+0		
	!BYTE	$76,$01			; SLW	[1]
	!BYTE	$50			; BRNCH	_B054
	!WORD	_B054-*
_B052 
; samplesrc/rpncalc.pla: 0219:     conio:gotoxy(pkeys->xpos, pkeys->ypos)
; samplesrc/rpncalc.pla: 0220:     puts(pkeys + keystr)
; samplesrc/rpncalc.pla: 0221:     pkeys = pkeys + t_keyinput
; samplesrc/rpncalc.pla: 0222:   loop
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_X032+8
_F098 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X004
_F099 	!WORD	0		
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$76,$01			; SLW	[1]
_B054 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B052
	!WORD	_B052-*
_B053 
; samplesrc/rpncalc.pla: 0223: end
	!BYTE	$5A,$03			; LEAVE	3
; samplesrc/rpncalc.pla: 0224: def initState#0
_C010 					; initState()
; samplesrc/rpncalc.pla: 0225:   byte m
					; m -> [0]
; samplesrc/rpncalc.pla: 0226: 
; samplesrc/rpncalc.pla: 0227:   //
; samplesrc/rpncalc.pla: 0228:   // Init FPU
; samplesrc/rpncalc.pla: 0229:   //
; samplesrc/rpncalc.pla: 0230:   fpu:reset()
	!BYTE	$58,$01,$00		; ENTER	1,0
; samplesrc/rpncalc.pla: 0231:   //
; samplesrc/rpncalc.pla: 0232:   // Fill memory
; samplesrc/rpncalc.pla: 0233:   //
; samplesrc/rpncalc.pla: 0234:   for m = 2 to 9
	!BYTE	$6A			; LAW	_X031+0
_F100 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$12			; CN	9
	!BYTE	$04			; CN	2
_B056 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rpncalc.pla: 0235:     fpu:storExt(@memory[m*t_fpureg], X_REG)
; samplesrc/rpncalc.pla: 0236:   next
	!BYTE	$26			; LA	_D049+0
_F101 	!WORD	_D049+0		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X031+54
_F102 	!WORD	0+54		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B057 
	!BYTE	$A4			; INCBRLE	_B056
	!WORD	_B056-*
_B055 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0237:   //
; samplesrc/rpncalc.pla: 0238:   // Put some useful constants in there
; samplesrc/rpncalc.pla: 0239:   //
; samplesrc/rpncalc.pla: 0240:   fpu:constPi()
; samplesrc/rpncalc.pla: 0241:   fpu:pullExt(@memory[0*t_fpureg])
; samplesrc/rpncalc.pla: 0242:   fpu:constE()
; samplesrc/rpncalc.pla: 0243:   fpu:pullExt(@memory[1*t_fpureg])
; samplesrc/rpncalc.pla: 0244: end
	!BYTE	$6A			; LAW	_X031+14
_F103 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D049+0
_F104 	!WORD	_D049+0		
	!BYTE	$6A			; LAW	_X031+34
_F105 	!WORD	0+34		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X031+16
_F106 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D049+10
_F107 	!WORD	_D049+10		
	!BYTE	$6A			; LAW	_X031+34
_F108 	!WORD	0+34		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5A,$01			; LEAVE	1
; samplesrc/rpncalc.pla: 0245: //
; samplesrc/rpncalc.pla: 0246: // Keypress input handlers
; samplesrc/rpncalc.pla: 0247: //
; samplesrc/rpncalc.pla: 0248: def delKey(pkey)#0
					; pkey -> [0]
_P000 					; delKey(pkey)#0()
_C011 					; delKey()
; samplesrc/rpncalc.pla: 0249:   if inputStr
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0250:     inputStr--
	!BYTE	$68			; LAB	_D046+0
_F109 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B058
	!WORD	_B058-*
	!BYTE	$68			; LAB	_D046+0
_F110 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0251:   fin
	!BYTE	$78			; SAB	_D046+0
_F111 	!WORD	_D046+0		
_B058 
_B059 
; samplesrc/rpncalc.pla: 0252:   if inputStr:0 == 1 | ('-' << 8) //inputStr == 1 and inputStr.1 == '-'
; samplesrc/rpncalc.pla: 0253:     inputStr--
	!BYTE	$6A			; LAW	_D046+0
_F112 	!WORD	_D046+0		
	!BYTE	$2C,$01,$2D		; CW	11521
	!BYTE	$24			; BRNE	_B060
	!WORD	_B060-*
	!BYTE	$68			; LAB	_D046+0
_F113 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0254:   fin
	!BYTE	$78			; SAB	_D046+0
_F114 	!WORD	_D046+0		
_B060 
_B061 
; samplesrc/rpncalc.pla: 0255:   showInput
; samplesrc/rpncalc.pla: 0256: end
	!BYTE	$54			; CALL	_C004
_F115 	!WORD	_C004		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0257: def dropKey(pkey)#0
					; pkey -> [0]
_P002 					; dropKey(pkey)#0()
_C012 					; dropKey()
; samplesrc/rpncalc.pla: 0258:   fpu:pullStr(@inputStr, displayInt, displayFix, FPSTR_STRIP|FPSTR_FLOAT|FPSTR_FLEX)
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0259:   if inputStr.1 == ' '
; samplesrc/rpncalc.pla: 0260:     inputStr--
	!BYTE	$26			; LA	_D046+0
_F116 	!WORD	_D046+0		
	!BYTE	$68			; LAB	_D048+0
_F117 	!WORD	_D048+0		
	!BYTE	$68			; LAB	_D047+0
_F118 	!WORD	_D047+0		
	!BYTE	$04			; CN	2
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$6A			; LAW	_X031+36
_F119 	!WORD	0+36		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D046+1
_F120 	!WORD	_D046+1		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B062
	!WORD	_B062-*
	!BYTE	$68			; LAB	_D046+0
_F121 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0261:     memcpy(@inputStr.1, @inputStr.2, inputStr)
; samplesrc/rpncalc.pla: 0262:   fin
	!BYTE	$78			; SAB	_D046+0
_F122 	!WORD	_D046+0		
	!BYTE	$26			; LA	_D046+1
_F123 	!WORD	_D046+1		
	!BYTE	$26			; LA	_D046+2
_F124 	!WORD	_D046+2		
	!BYTE	$68			; LAB	_D046+0
_F125 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_X018
_F126 	!WORD	0		
_B062 
_B063 
; samplesrc/rpncalc.pla: 0263:   showInput
; samplesrc/rpncalc.pla: 0264:   showStack
; samplesrc/rpncalc.pla: 0265: end
	!BYTE	$54			; CALL	_C004
_F127 	!WORD	_C004		
	!BYTE	$54			; CALL	_C002
_F128 	!WORD	_C002		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0266: def copyKey(pkey)#0
					; pkey -> [0]
_P008 					; copyKey(pkey)#0()
_C013 					; copyKey()
; samplesrc/rpncalc.pla: 0267:   fpu:storStr(@inputStr, displayInt, displayFix, FPSTR_STRIP|FPSTR_FLOAT|FPSTR_FLEX, X_REG)
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0268:   if inputStr.1 == ' '
; samplesrc/rpncalc.pla: 0269:     inputStr--
	!BYTE	$26			; LA	_D046+0
_F129 	!WORD	_D046+0		
	!BYTE	$68			; LAB	_D048+0
_F130 	!WORD	_D048+0		
	!BYTE	$68			; LAB	_D047+0
_F131 	!WORD	_D047+0		
	!BYTE	$04			; CN	2
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X031+56
_F132 	!WORD	0+56		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D046+1
_F133 	!WORD	_D046+1		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B064
	!WORD	_B064-*
	!BYTE	$68			; LAB	_D046+0
_F134 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0270:     memcpy(@inputStr.1, @inputStr.2, inputStr)
; samplesrc/rpncalc.pla: 0271:   fin
	!BYTE	$78			; SAB	_D046+0
_F135 	!WORD	_D046+0		
	!BYTE	$26			; LA	_D046+1
_F136 	!WORD	_D046+1		
	!BYTE	$26			; LA	_D046+2
_F137 	!WORD	_D046+2		
	!BYTE	$68			; LAB	_D046+0
_F138 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_X018
_F139 	!WORD	0		
_B064 
_B065 
; samplesrc/rpncalc.pla: 0272:   showInput
; samplesrc/rpncalc.pla: 0273: end
	!BYTE	$54			; CALL	_C004
_F140 	!WORD	_C004		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0274: def clearKey(pkey)#0
					; pkey -> [0]
_P003 					; clearKey(pkey)#0()
_C014 					; clearKey()
; samplesrc/rpncalc.pla: 0275:   initInput
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0276:   showInput
; samplesrc/rpncalc.pla: 0277: end
	!BYTE	$54			; CALL	_C007
_F141 	!WORD	_C007		
	!BYTE	$54			; CALL	_C004
_F142 	!WORD	_C004		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0278: def digitKey(pkey)#0
					; pkey -> [0]
_P004 					; digitKey(pkey)#0()
_C015 					; digitKey()
; samplesrc/rpncalc.pla: 0279:   if inputStr < inputLen
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0280:     if inputStr:0 <> ZEROSTR
; samplesrc/rpncalc.pla: 0281:       inputStr++
	!BYTE	$68			; LAB	_D046+0
_F143 	!WORD	_D046+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B066
	!WORD	_B066-*
	!BYTE	$6A			; LAW	_D046+0
_F144 	!WORD	_D046+0		
	!BYTE	$2C,$01,$30		; CW	12289
	!BYTE	$22			; BREQ	_B068
	!WORD	_B068-*
	!BYTE	$68			; LAB	_D046+0
_F145 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; samplesrc/rpncalc.pla: 0282:     fin
	!BYTE	$78			; SAB	_D046+0
_F146 	!WORD	_D046+0		
_B068 
_B069 
; samplesrc/rpncalc.pla: 0283:     inputStr[inputStr] = ^pkey
; samplesrc/rpncalc.pla: 0284:     showInput
; samplesrc/rpncalc.pla: 0285:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D046+0
_F147 	!WORD	_D046+0		
	!BYTE	$B4			; ADDAB	_D046+0
_F148 	!WORD	_D046+0		
	!BYTE	$70			; SB
	!BYTE	$54			; CALL	_C004
_F149 	!WORD	_C004		
_B066 
_B067 
; samplesrc/rpncalc.pla: 0286: end
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0287: def pointKey(pkey)#0
					; pkey -> [0]
_P005 					; pointKey(pkey)#0()
_C016 					; pointKey()
; samplesrc/rpncalc.pla: 0288:   byte c
					; c -> [2]
; samplesrc/rpncalc.pla: 0289: 
; samplesrc/rpncalc.pla: 0290:   if !inputStr
	!BYTE	$58,$03,$01		; ENTER	3,1
; samplesrc/rpncalc.pla: 0291:     //
; samplesrc/rpncalc.pla: 0292:     // Start off with '0' if blank input
; samplesrc/rpncalc.pla: 0293:     //
; samplesrc/rpncalc.pla: 0294:     inputStr:0 = ZEROSTR
; samplesrc/rpncalc.pla: 0295:   else
	!BYTE	$68			; LAB	_D046+0
_F150 	!WORD	_D046+0		
	!BYTE	$4E			; BRTRU	_B070
	!WORD	_B070-*
	!BYTE	$2C,$01,$30		; CW	12289
	!BYTE	$7A			; SAW	_D046+0
_F151 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B071
	!WORD	_B071-*
_B070 
; samplesrc/rpncalc.pla: 0296:     //
; samplesrc/rpncalc.pla: 0297:     // Check for existing decimal point
; samplesrc/rpncalc.pla: 0298:     //
; samplesrc/rpncalc.pla: 0299:     for c = 1 to inputStr
	!BYTE	$68			; LAB	_D046+0
_F152 	!WORD	_D046+0		
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B072
	!WORD	_B072-*
_B073 
	!BYTE	$6C,$02			; DLB	[2]
; samplesrc/rpncalc.pla: 0300:       if inputStr[c] == '.'
; samplesrc/rpncalc.pla: 0301:         return
	!BYTE	$26			; LA	_D046+0
_F153 	!WORD	_D046+0		
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$24			; BRNE	_B075
	!WORD	_B075-*
	!BYTE	$32			; DROP2
	!BYTE	$5A,$03			; LEAVE	3
; samplesrc/rpncalc.pla: 0302:       fin
_B075 
_B076 
; samplesrc/rpncalc.pla: 0303:     next
_B074 
	!BYTE	$A4			; INCBRLE	_B073
	!WORD	_B073-*
_B072 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; samplesrc/rpncalc.pla: 0304:   fin
_B071 
; samplesrc/rpncalc.pla: 0305:   inputStr++
	!BYTE	$68			; LAB	_D046+0
_F154 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; samplesrc/rpncalc.pla: 0306:   inputStr[inputStr] = '.'
; samplesrc/rpncalc.pla: 0307:   showInput
; samplesrc/rpncalc.pla: 0308: end
	!BYTE	$78			; SAB	_D046+0
_F155 	!WORD	_D046+0		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$26			; LA	_D046+0
_F156 	!WORD	_D046+0		
	!BYTE	$B4			; ADDAB	_D046+0
_F157 	!WORD	_D046+0		
	!BYTE	$70			; SB
	!BYTE	$54			; CALL	_C004
_F158 	!WORD	_C004		
	!BYTE	$5A,$03			; LEAVE	3
; samplesrc/rpncalc.pla: 0309: def chsKey(pkey)#0
					; pkey -> [0]
_P009 					; chsKey(pkey)#0()
_C017 					; chsKey()
; samplesrc/rpncalc.pla: 0310:   if inputStr
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0311:     if inputStr.1 <> '-'
; samplesrc/rpncalc.pla: 0312:       memcpy(@inputStr.2, @inputStr.1, inputStr)
; samplesrc/rpncalc.pla: 0313:       inputStr++
	!BYTE	$68			; LAB	_D046+0
_F159 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B077
	!WORD	_B077-*
	!BYTE	$68			; LAB	_D046+1
_F160 	!WORD	_D046+1		
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$22			; BREQ	_B079
	!WORD	_B079-*
	!BYTE	$26			; LA	_D046+2
_F161 	!WORD	_D046+2		
	!BYTE	$26			; LA	_D046+1
_F162 	!WORD	_D046+1		
	!BYTE	$68			; LAB	_D046+0
_F163 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_X018
_F164 	!WORD	0		
	!BYTE	$68			; LAB	_D046+0
_F165 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; samplesrc/rpncalc.pla: 0314:       inputStr.1 = '-'
; samplesrc/rpncalc.pla: 0315:     else
	!BYTE	$78			; SAB	_D046+0
_F166 	!WORD	_D046+0		
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$78			; SAB	_D046+1
_F167 	!WORD	_D046+1		
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B079 
; samplesrc/rpncalc.pla: 0316:       inputStr--
	!BYTE	$68			; LAB	_D046+0
_F168 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
; samplesrc/rpncalc.pla: 0317:       memcpy(@inputStr.1, @inputStr.2, inputStr)
; samplesrc/rpncalc.pla: 0318:     fin
	!BYTE	$78			; SAB	_D046+0
_F169 	!WORD	_D046+0		
	!BYTE	$26			; LA	_D046+1
_F170 	!WORD	_D046+1		
	!BYTE	$26			; LA	_D046+2
_F171 	!WORD	_D046+2		
	!BYTE	$68			; LAB	_D046+0
_F172 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_X018
_F173 	!WORD	0		
_B080 
; samplesrc/rpncalc.pla: 0319:     showInput
; samplesrc/rpncalc.pla: 0320:   fin
	!BYTE	$54			; CALL	_C004
_F174 	!WORD	_C004		
_B077 
_B078 
; samplesrc/rpncalc.pla: 0321: end
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0322: def enterKey(pkey)#0
					; pkey -> [0]
_P007 					; enterKey(pkey)#0()
_C018 					; enterKey()
; samplesrc/rpncalc.pla: 0323:   fpu:pushStr(@inputStr)
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0324:   showStack
; samplesrc/rpncalc.pla: 0325:   initInput
; samplesrc/rpncalc.pla: 0326:   showInput
; samplesrc/rpncalc.pla: 0327: end
	!BYTE	$26			; LA	_D046+0
_F175 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_X031+26
_F176 	!WORD	0+26		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C002
_F177 	!WORD	_C002		
	!BYTE	$54			; CALL	_C007
_F178 	!WORD	_C007		
	!BYTE	$54			; CALL	_C004
_F179 	!WORD	_C004		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0328: def opKey(pkey)#0
					; pkey -> [0]
_P006 					; opKey(pkey)#0()
_C019 					; opKey()
; samplesrc/rpncalc.pla: 0329:   updateInput
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0330:   when ^pkey
	!BYTE	$54			; CALL	_C008
_F180 	!WORD	_C008		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B082-*
; samplesrc/rpncalc.pla: 0331:     is '+'
_B083 
; samplesrc/rpncalc.pla: 0332:       fpu:addXY()
; samplesrc/rpncalc.pla: 0333:       break
	!BYTE	$6A			; LAW	_X031+72
_F181 	!WORD	0+72		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; samplesrc/rpncalc.pla: 0334:     is '-'
_B084 
; samplesrc/rpncalc.pla: 0335:       fpu:subXY()
; samplesrc/rpncalc.pla: 0336:       break
	!BYTE	$6A			; LAW	_X031+74
_F182 	!WORD	0+74		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; samplesrc/rpncalc.pla: 0337:     is '*'
_B085 
; samplesrc/rpncalc.pla: 0338:       fpu:mulXY()
; samplesrc/rpncalc.pla: 0339:       break
	!BYTE	$6A			; LAW	_X031+76
_F183 	!WORD	0+76		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; samplesrc/rpncalc.pla: 0340:     is '/'
_B086 
; samplesrc/rpncalc.pla: 0341:       fpu:divXY()
; samplesrc/rpncalc.pla: 0342:       break
	!BYTE	$6A			; LAW	_X031+78
_F184 	!WORD	0+78		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; samplesrc/rpncalc.pla: 0343:     is 'R'
_B087 
; samplesrc/rpncalc.pla: 0344:       fpu:sqrtX()
; samplesrc/rpncalc.pla: 0345:       break
	!BYTE	$6A			; LAW	_X031+98
_F185 	!WORD	0+98		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; samplesrc/rpncalc.pla: 0346:   wend
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
_B082 
	!BYTE	$05			; CASEBLOCK
	!WORD	$002A
	!WORD	_B085-*
	!WORD	$002B
	!WORD	_B083-*
	!WORD	$002D
	!WORD	_B084-*
	!WORD	$002F
	!WORD	_B086-*
	!WORD	$0052
	!WORD	_B087-*
_B081 
; samplesrc/rpncalc.pla: 0347:   showStack
; samplesrc/rpncalc.pla: 0348: end
	!BYTE	$54			; CALL	_C002
_F186 	!WORD	_C002		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0349: def memKey(pkey)#0
					; pkey -> [0]
_P010 					; memKey(pkey)#0()
_C020 					; memKey()
; samplesrc/rpncalc.pla: 0350:   word r
					; r -> [2]
; samplesrc/rpncalc.pla: 0351: 
; samplesrc/rpncalc.pla: 0352:   showStatus("Press 0-9 for memory register:")
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$2E			; CS
	!BYTE	$1E
	!BYTE	$50,$72,$65,$73,$73,$20,$30,$2D
	!BYTE	$39,$20,$66,$6F,$72,$20,$6D,$65
	!BYTE	$6D,$6F,$72,$79,$20,$72,$65,$67
	!BYTE	$69,$73,$74,$65,$72,$3A
	!BYTE	$54			; CALL	_C005
_F187 	!WORD	_C005		
; samplesrc/rpncalc.pla: 0353:   r = getc - '0'
; samplesrc/rpncalc.pla: 0354:   clearStatus
; samplesrc/rpncalc.pla: 0355:   if r >= 0 and r <= 9
; samplesrc/rpncalc.pla: 0356:     if ^pkey == '<'
; samplesrc/rpncalc.pla: 0357:       fpu:pushExt(@memory[r*t_fpureg])
; samplesrc/rpncalc.pla: 0358:       showStack
; samplesrc/rpncalc.pla: 0359:     else
	!BYTE	$54			; CALL	_X006
_F188 	!WORD	0		
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$54			; CALL	_C006
_F189 	!WORD	_C006		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B088
	!WORD	_B088-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$12			; CN	9
	!BYTE	$4A			; ISLE
_B088 
	!BYTE	$4C			; BRFLS	_B089
	!WORD	_B089-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$24			; BRNE	_B091
	!WORD	_B091-*
	!BYTE	$26			; LA	_D049+0
_F190 	!WORD	_D049+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_X031+24
_F191 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C002
_F192 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B092
	!WORD	_B092-*
_B091 
; samplesrc/rpncalc.pla: 0360:       fpu:storExt(@memory[r*t_fpureg], X_REG)
; samplesrc/rpncalc.pla: 0361:       showMem
; samplesrc/rpncalc.pla: 0362:     fin
	!BYTE	$26			; LA	_D049+0
_F193 	!WORD	_D049+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X031+54
_F194 	!WORD	0+54		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C003
_F195 	!WORD	_C003		
_B092 
; samplesrc/rpncalc.pla: 0363:   fin
_B089 
_B090 
; samplesrc/rpncalc.pla: 0364: end
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/rpncalc.pla: 0365: def elemsKey(pkey)#0
					; pkey -> [0]
_P011 					; elemsKey(pkey)#0()
_C021 					; elemsKey()
; samplesrc/rpncalc.pla: 0366:   updateInput
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rpncalc.pla: 0367:   when ^pkey
	!BYTE	$54			; CALL	_C008
_F196 	!WORD	_C008		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B094-*
; samplesrc/rpncalc.pla: 0368:     is 'C'
_B095 
; samplesrc/rpncalc.pla: 0369:       fpu:cosX()
; samplesrc/rpncalc.pla: 0370:       break
	!BYTE	$6A			; LAW	_X031+102
_F197 	!WORD	0+102		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0371:     is 'S'
_B096 
; samplesrc/rpncalc.pla: 0372:       fpu:sinX()
; samplesrc/rpncalc.pla: 0373:       break
	!BYTE	$6A			; LAW	_X031+104
_F198 	!WORD	0+104		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0374:     is 'T'
_B097 
; samplesrc/rpncalc.pla: 0375:       fpu:tanX()
; samplesrc/rpncalc.pla: 0376:       break
	!BYTE	$6A			; LAW	_X031+106
_F199 	!WORD	0+106		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0377:     is 'A'
_B098 
; samplesrc/rpncalc.pla: 0378:       fpu:atanX()
; samplesrc/rpncalc.pla: 0379:       break
	!BYTE	$6A			; LAW	_X031+108
_F200 	!WORD	0+108		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0380:     is '^'
_B099 
; samplesrc/rpncalc.pla: 0381:       fpu:powXY()
; samplesrc/rpncalc.pla: 0382:       break
	!BYTE	$6A			; LAW	_X031+130
_F201 	!WORD	0+130		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0383:     is 'L'
_B100 
; samplesrc/rpncalc.pla: 0384:       fpu:log2X()
; samplesrc/rpncalc.pla: 0385:       break
	!BYTE	$6A			; LAW	_X031+110
_F202 	!WORD	0+110		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0386:     is 'P'
_B101 
; samplesrc/rpncalc.pla: 0387:       fpu:powEX()
; samplesrc/rpncalc.pla: 0388:       break
	!BYTE	$6A			; LAW	_X031+122
_F203 	!WORD	0+122		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0389:     is 'N'
_B102 
; samplesrc/rpncalc.pla: 0390:       fpu:lnX()
; samplesrc/rpncalc.pla: 0391:       break
	!BYTE	$6A			; LAW	_X031+114
_F204 	!WORD	0+114		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; samplesrc/rpncalc.pla: 0392:   wend
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
_B094 
	!BYTE	$08			; CASEBLOCK
	!WORD	$0041
	!WORD	_B098-*
	!WORD	$0043
	!WORD	_B095-*
	!WORD	$004C
	!WORD	_B100-*
	!WORD	$004E
	!WORD	_B102-*
	!WORD	$0050
	!WORD	_B101-*
	!WORD	$0053
	!WORD	_B096-*
	!WORD	$0054
	!WORD	_B097-*
	!WORD	$005E
	!WORD	_B099-*
_B093 
; samplesrc/rpncalc.pla: 0393:   showStack
; samplesrc/rpncalc.pla: 0394: end
	!BYTE	$54			; CALL	_C002
_F205 	!WORD	_C002		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rpncalc.pla: 0395: //
; samplesrc/rpncalc.pla: 0396: // Command line handler
; samplesrc/rpncalc.pla: 0397: //
; samplesrc/rpncalc.pla: 0398: def cmdKey(pkey)#0
					; pkey -> [0]
_P001 					; cmdKey(pkey)#0()
_C022 					; cmdKey()
; samplesrc/rpncalc.pla: 0399: //  word cmdLine
; samplesrc/rpncalc.pla: 0400: 
; samplesrc/rpncalc.pla: 0401: //  showStatus("Command")
; samplesrc/rpncalc.pla: 0402: //  cmdLine = gets(':'|$80)
; samplesrc/rpncalc.pla: 0403:   word d
					; d -> [2]
; samplesrc/rpncalc.pla: 0404: 
; samplesrc/rpncalc.pla: 0405:   showStatus("Press 1-9 for fix point digits(Q=Quit):")
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$2E			; CS
	!BYTE	$27
	!BYTE	$50,$72,$65,$73,$73,$20,$31,$2D
	!BYTE	$39,$20,$66,$6F,$72,$20,$66,$69
	!BYTE	$78,$20,$70,$6F,$69,$6E,$74,$20
	!BYTE	$64,$69,$67,$69,$74,$73,$28,$51
	!BYTE	$3D,$51,$75,$69,$74,$29,$3A
	!BYTE	$54			; CALL	_C005
_F206 	!WORD	_C005		
; samplesrc/rpncalc.pla: 0406:   d = toupper(getc) - '0'
; samplesrc/rpncalc.pla: 0407:   if d >= 1 and d <= 9
; samplesrc/rpncalc.pla: 0408:     displayFix = d
; samplesrc/rpncalc.pla: 0409:     displayInt = displayWidth - displayFix - 2
; samplesrc/rpncalc.pla: 0410:   elsif d == 'Q' - '0'
	!BYTE	$54			; CALL	_X006
_F207 	!WORD	0		
	!BYTE	$54			; CALL	_X021
_F208 	!WORD	0		
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B103
	!WORD	_B103-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$12			; CN	9
	!BYTE	$4A			; ISLE
_B103 
	!BYTE	$4C			; BRFLS	_B104
	!WORD	_B104-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$78			; SAB	_D047+0
_F209 	!WORD	_D047+0		
	!BYTE	$1E			; CN	15
	!BYTE	$68			; LAB	_D047+0
_F210 	!WORD	_D047+0		
	!BYTE	$84			; SUB 
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$78			; SAB	_D048+0
_F211 	!WORD	_D048+0		
	!BYTE	$50			; BRNCH	_B105
	!WORD	_B105-*
_B104 
; samplesrc/rpncalc.pla: 0411:     quit = TRUE
; samplesrc/rpncalc.pla: 0412:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$21			; CB	33
	!BYTE	$24			; BRNE	_B106
	!WORD	_B106-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$78			; SAB	_D045+0
_F212 	!WORD	_D045+0		
_B106 
_B105 
; samplesrc/rpncalc.pla: 0413:   clearStatus
; samplesrc/rpncalc.pla: 0414:   //
; samplesrc/rpncalc.pla: 0415:   // Do something
; samplesrc/rpncalc.pla: 0416:   //
; samplesrc/rpncalc.pla: 0417:   initDisplay
; samplesrc/rpncalc.pla: 0418:   showStack
; samplesrc/rpncalc.pla: 0419:   showMem
; samplesrc/rpncalc.pla: 0420:   showInput
; samplesrc/rpncalc.pla: 0421: end
	!BYTE	$54			; CALL	_C006
_F213 	!WORD	_C006		
	!BYTE	$54			; CALL	_C009
_F214 	!WORD	_C009		
	!BYTE	$54			; CALL	_C002
_F215 	!WORD	_C002		
	!BYTE	$54			; CALL	_C003
_F216 	!WORD	_C003		
	!BYTE	$54			; CALL	_C004
_F217 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/rpncalc.pla: 0422: //
; samplesrc/rpncalc.pla: 0423: // Keypress handler
; samplesrc/rpncalc.pla: 0424: //
; samplesrc/rpncalc.pla: 0425: def inputKey#0
_C023 					; inputKey()
; samplesrc/rpncalc.pla: 0426:   byte inkey
					; inkey -> [0]
; samplesrc/rpncalc.pla: 0427:   word pkeys
					; pkeys -> [1]
; samplesrc/rpncalc.pla: 0428: 
; samplesrc/rpncalc.pla: 0429:   conio:textctrl(ctrlecho, OFF)
	!BYTE	$58,$03,$00		; ENTER	3,0
; samplesrc/rpncalc.pla: 0430:   while not quit
	!BYTE	$04			; CN	2
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X032+12
_F218 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B109
	!WORD	_B109-*
_B107 
; samplesrc/rpncalc.pla: 0431:     pkeys = @keypad
; samplesrc/rpncalc.pla: 0432:     conio:gotoxy(18, 7)
; samplesrc/rpncalc.pla: 0433:     inkey = toupper(getc)
; samplesrc/rpncalc.pla: 0434:     while ^pkeys
	!BYTE	$26			; LA	_D050+0
_F219 	!WORD	_D050+0		
	!BYTE	$76,$01			; SLW	[1]
	!BYTE	$2A,$12			; CB	18
	!BYTE	$0E			; CN	7
	!BYTE	$6A			; LAW	_X032+8
_F220 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_X006
_F221 	!WORD	0		
	!BYTE	$54			; CALL	_X021
_F222 	!WORD	0		
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B112
	!WORD	_B112-*
_B110 
; samplesrc/rpncalc.pla: 0435:       if inkey == ^pkeys
; samplesrc/rpncalc.pla: 0436:         conio:textctrl(ctrlattr, INVERSE)
; samplesrc/rpncalc.pla: 0437:         conio:gotoxy(pkeys->xpos, pkeys->ypos)
; samplesrc/rpncalc.pla: 0438:         puts(pkeys + keystr)
; samplesrc/rpncalc.pla: 0439:         conio:textctrl(ctrlattr, NORMAL)
; samplesrc/rpncalc.pla: 0440:         pkeys=>phandler(pkeys)#0
; samplesrc/rpncalc.pla: 0441:         conio:gotoxy(pkeys->xpos, pkeys->ypos)
; samplesrc/rpncalc.pla: 0442:         puts(pkeys + keystr)
; samplesrc/rpncalc.pla: 0443:         break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B113
	!WORD	_B113-*
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X032+12
_F223 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_X032+8
_F224 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X004
_F225 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$6A			; LAW	_X032+12
_F226 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$34			; DUP
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_X032+8
_F227 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X004
_F228 	!WORD	0		
	!BYTE	$50			; BRNCH	_B111
	!WORD	_B111-*
; samplesrc/rpncalc.pla: 0444:       fin
_B113 
_B114 
; samplesrc/rpncalc.pla: 0445:       pkeys = pkeys + t_keyinput
; samplesrc/rpncalc.pla: 0446:     loop
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$76,$01			; SLW	[1]
_B112 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B110
	!WORD	_B110-*
_B111 
; samplesrc/rpncalc.pla: 0447:   loop
_B109 
	!BYTE	$68			; LAB	_D045+0
_F229 	!WORD	_D045+0		
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
_B108 
; samplesrc/rpncalc.pla: 0448:   conio:textctrl(ctrlecho, ON)
; samplesrc/rpncalc.pla: 0449: end
	!BYTE	$04			; CN	2
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X032+12
_F230 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5A,$03			; LEAVE	3
; samplesrc/rpncalc.pla: 0450: initDisplay
_INIT 
; samplesrc/rpncalc.pla: 0451: initState
; samplesrc/rpncalc.pla: 0452: initInput
; samplesrc/rpncalc.pla: 0453: showStack
; samplesrc/rpncalc.pla: 0454: showMem
; samplesrc/rpncalc.pla: 0455: showInput
; samplesrc/rpncalc.pla: 0456: showStatus("Version 0.7")
	!BYTE	$54			; CALL	_C009
_F231 	!WORD	_C009		
	!BYTE	$54			; CALL	_C010
_F232 	!WORD	_C010		
	!BYTE	$54			; CALL	_C007
_F233 	!WORD	_C007		
	!BYTE	$54			; CALL	_C002
_F234 	!WORD	_C002		
	!BYTE	$54			; CALL	_C003
_F235 	!WORD	_C003		
	!BYTE	$54			; CALL	_C004
_F236 	!WORD	_C004		
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$56,$65,$72,$73,$69,$6F,$6E,$20
	!BYTE	$30,$2E,$37
	!BYTE	$54			; CALL	_C005
_F237 	!WORD	_C005		
; samplesrc/rpncalc.pla: 0457: inputKey
; samplesrc/rpncalc.pla: 0458: conio:textmode(0)
; samplesrc/rpncalc.pla: 0459: conio:gotoxy(0, 22)
; samplesrc/rpncalc.pla: 0460: done
	!BYTE	$54			; CALL	_C023
_F238 	!WORD	_C023		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X032+14
_F239 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_X032+8
_F240 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	25
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTI
	!BYTE	$D0,$D5,$D4,$49
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	5			; ESD INDEX
	; DCI STRING: GETC
	!BYTE	$C7,$C5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	6			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: EXT2STR
	!BYTE	$C5,$D8,$D4,$B2,$D3,$D4,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: FPU
	!BYTE	$C6,$D0,$55
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	!BYTE	$00			; END OF ESD
