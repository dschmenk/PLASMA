const MODADDR      = $1000
const inbuff       = $200
const CFFADest     = $00
const CFFAFileName = $02
const CFFAOldName  = $04
const CFFAFileType = $06
const CFFAAuxType  = $07
const CFFAFileSize = $09
const CFFAEntryPtr = $0B
;
; Pedefined functions.
;
predef home, gotoxy, viewport, crout, cout, prstr, cin, rdstr
predef syscall
predef markheap, allocheap, allocalignheap, releaseheap, availheap
predef memset, memcpy, xmemcpy
predef uword_isgt, uword_isge, uword_islt, uword_isle
predef execmod
;
; Standard Library exported functions.
;
byte stdlibstr[]  = "STDLIB"
byte clsstr[]     = "CLS"
byte gotoxystr[]  = "GOTOXY"
byte viewstr[]    = "VIEWPORT"
byte putcstr[]    = "PUTC"
byte putsstr[]    = "PUTS"
byte getcstr[]    = "GETC"
byte getsstr[]    = "GETS"
byte sysstr[]     = "SYSCALL"
byte hpmarkstr[]  = "HEAPMARK"
byte hpalignstr[] = "HEAPALLOCALIGN"
byte hpallocstr[] = "HEAPALLOC"
byte hprelstr[]   = "HEAPRELEASE"
byte hpavailstr[] = "HEAPAVAIL"
byte memsetstr[]  = "MEMSET"
byte memcpystr[]  = "MEMCPY"
byte uisgtstr[]   = "ISUGT"
byte uisgestr[]   = "ISUGE"
byte uisltstr[]   = "ISULT"
byte uislestr[]   = "ISULE"
byte execstr[]    = "EXEC"
word exports[]    = @clsstr,    @home
word              = @gotoxystr, @gotoxy
word		  = @viewstr,   @viewport
word		  = @putcstr,   @cout
word		  = @putsstr,   @prstr
word		  = @getcstr,   @cin
word		  = @getsstr,   @rdstr
word		  = @sysstr,    @syscall
word		  = @hpmarkstr, @markheap
word		  = @hpallocstr,@allocheap
word		  = @hpalignstr,@allocalignheap
word		  = @hprelstr,  @releaseheap
word		  = @memsetstr, @memset
word		  = @memcpystr, @memcpy
word              = @uisgtstr,  @uword_isgt
word              = @uisgestr,  @uword_isge
word              = @uisltstr,  @uword_islt
word              = @uislestr,  @uword_isle
word              = @execstr,   @execmod
word              = 0
word stdlibsym    = @exports     
;
; String pool.
;
byte version[]    = "\nPLASMA 0.9\n"
byte freestr[]    = "MEM FREE:$"
byte errorstr[]   = "ERR:$"
byte prompt[]     = "PLASMA"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
;
; System variable.
;
word systemflags = 0
word heap
word symtbl, lastsym
word perr
word cmdptr
;
; CALL SOS
; SYSCALL(CMD)
;
asm syscall
	LDA	ESTKL,X
	STX	ESP
	TAX
	JSR	$900C
	LDX	ESP
	STA	ESTKL,X
	LDY    	#$00
	STY	ESTKH,X	
	RTS
end
;
; QUIT TO MONITOR
;
asm quit
	JMP	$9000
end
;
; SET MEMORY TO VALUE
; MEMSET(ADDR, SIZE, VALUE)
;
asm memset
	LDY     #$00
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	INC     ESTKL+1,X
	INC     ESTKH+1,X
SETMLP	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKL,X
	STA     (DST),Y
	INY
	BNE     +
	INC     DSTH
+	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKH,X
	STA     (DST),Y
	INY
	BNE     SETMLP
	INC     DSTH
	BNE     SETMLP
SETMEX	INX
	INX
	RTS
end
;
; COPY MEMORY
; MEMCPY(DSTADDR, SRCADDR, SIZE)
;
asm memcpy
	LDY	#$00
	LDA	ESTKL,X
	BNE 	+
	LDA	ESTKH,X
	BEQ	CPYMEX
+	LDA	ESTKL+2,X
	STA 	DSTL
	LDA	ESTKH+2,X
	STA 	DSTH
	LDA	ESTKL+1,X
	STA 	SRCL
	LDA	ESTKH+1,X
	STA 	SRCH
	CMP	DSTH
	BCC	REVCPY
	BNE	FORCPY
	LDA 	SRCL
	CMP	DSTL
	BCS	FORCPY
REVCPY				; REVERSE DIRECTION COPY
;	CLC
	LDA 	ESTKL,X
	ADC	DSTL
	STA	DSTL
	LDA	ESTKH,X
	ADC	DSTH
	STA	DSTH
	CLC
	LDA 	ESTKL,X
	ADC	SRCL
	STA	SRCL
	LDA	ESTKH,X
	ADC	SRCH
	STA	SRCH
	INC 	ESTKH,X
REVCPYLP
	LDA	DSTL
	BNE	+
	DEC	DSTH
+	DEC	DSTL
	LDA	SRCL
	BNE	+
	DEC	SRCH
+	DEC	SRCL
	LDA	(SRC),Y
	STA	(DST),Y
	DEC 	ESTKL,X
	BNE	REVCPYLP
	DEC	ESTKH,X
	BNE	REVCPYLP
	BEQ	CPYMEX
FORCPY	INC 	ESTKH,X
FORCPYLP
	LDA	(SRC),Y
	STA	(DST),Y
	INC	DSTL
	BNE	+
	INC	DSTH
+	INC	SRCL
	BNE	+
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	FORCPYLP
	DEC	ESTKH,X
	BNE	FORCPYLP
CPYMEX	INX
	INX
	RTS
end
;
; Unsigned word comparisons.
;
asm uword_isge
	LDY	#$00
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_isle
	LDY	#$00
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_isgt
	LDY	#$FF
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_islt
	LDY	#$FF
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
;
; Addresses of internal routines.
;
asm interp
	DEX
	LDA	#<IINTERP
	STA	ESTKL,X
	LDA	#>IINTERP
	STA	ESTKH,X
	RTS
end
; 
; A DCI string is one that has the high bit set for every character except the last.
; More efficient than C or Pascal strings.
;
;def dcitos(dci, str)
;    byte len, c
;    len = 0
;    repeat
;        c = (dci).[len]
;        len = len + 1
;        (str).[len] = c & $7F
;    until !(c & $80)
;    ^str = len
;    return len
;end
asm dcitos
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(SRC),Y
	INY
	PHA
	AND	#$7F
	STA	(DST),Y
	PLA
	BMI	-
	TYA
	LDY	#$00
	STA	(DST),Y
	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
;def stodci(str, dci)
;    byte len, c
;    len = ^str
;    if len == 0
;        return
;    fin
;    c = toupper((str).[len]) & $7F
;    len = len - 1
;    (dci).[len] = c
;    while len
;    	c = toupper((str).[len]) | $80
;    	len = len - 1
;    	(dci).[len] = c
;    loop
;    return ^str
;end
asm stodci
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	INX
	LDY	#$00
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
asm toupper
	LDA     ESTKL,X
TOUPR	AND	#$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SEC
	SBC     #$20
+	STA     ESTKL,X
	RTS
end
;
; Module symbols are entered into the symbol table
; pre-pended with a '#' to differentiate them
; from normal symbols.
;
;def modtosym(mod, dci)
;    byte len, c
;    (dci).0 = '#'|$80
;    len = 0
;    repeat
;        c = (mod).[len]
;        len = len + 1
;        (dci).[len] = c
;    until !(c & $80)
;    return dci
;end
asm modtosym
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDA	ESTKL,X
	STA	ESTKL+1,X
	STA	DSTL
	LDA	ESTKH,X
	STA	ESTKH+1,X
	STA	DSTH
	INX
	LDY	#$00
	LDA	#'#'+$80
	STA	(DST),Y
-	LDA	(SRC),Y
	INY
	STA	(DST),Y
	AND	#$80
	BMI	-
	RTS
end
;
; Lookup routines.
;
;def lookuptbl(dci, tbl)
;    word match
;    while ^tbl
;        match = dci
;        while ^tbl == ^match
;            if !(^tbl & $80)
;                return (tbl):1
;            fin
;            tbl   = tbl   + 1
;            match = match + 1
;        loop
;        while (^tbl & $80)
;            tbl = tbl + 1
;        loop
;        tbl = tbl + 3
;    loop
;    return 0
asm lookuptbl
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(DST),Y
	BEQ	+
	CMP	(SRC),Y
	BNE	++
	INY
	AND	#$80
	BMI	-
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
+	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
++	LDY	#$00
--	LDA	(DST),Y
	INC	DSTL
	BNE	++
	INC	DSTH
++	AND	#$80
	BMI	--
	LDA	#$02
	CLC
	ADC	DSTL
	STA	DSTL
	TYA
	ADC	DSTH
	STA	DSTH
	BNE	-
end
;
; CONSOLE I/O
;
asm cout
	LDA	ESTKL,X
	JSR	TOUPR
	ORA	#$80
	JMP	$FFEF
end
asm cin
	DEX
-	LDA	$D011
	BPL	-
	LDA	$D010
	AND	#$7F
	STA	ESTKL,X
	LDA	#$00
	STA	ESTKH,X
	RTS
end
def crout
    return cout($0D)
end
def prstr(str)
    byte i
    i = 1
    while i <= ^str
        cout((str)[i])
	i = i + 1
    loop
end
def rdstr(prompt)
    byte ch, maxlen, i
    maxlen = 0
    inbuff.0 = 0
    cout(prompt)
    repeat
        ch = cin
	when ch
	    is $15 ; right arrow
	        if inbuff.0 < maxlen
		    inbuff.0 = inbuff.0 + 1
		    ch = inbuff[inbuff.0]
		    cout(ch)
		fin
	    is $08 ; left arrow
	        if inbuff.0
		    cout('\\')
		    cout(inbuff[inbuff.0])
		    inbuff.0 = inbuff.0 - 1
		fin
	    is $04 ; ctrl-d
	        if inbuff.0
		    cout('#')
		    cout(inbuff[inbuff.0])
		    for i = inbuff.0 + 1 to maxlen
		        inbuff[i - 1] = inbuff[i]
		    next
		    maxlen   = maxlen   - 1
		    inbuff.0 = inbuff.0 - 1
		fin
	    is $0C ; ctrl-l
	        crout
		prstr(inbuff)
	    is $0D ; return
	    is $18 ; ctrl-x
	        crout
		inbuff.0 = 0
	    is $9B ; escape
	        inbuff.0 = 0
		ch = $0D
	    otherwise
	        cout(ch)
		inbuff.0 = inbuff.0 + 1
		inbuff[inbuff.0] = ch
		if inbuff.0 > maxlen
		    maxlen = inbuff.0
		fin
	wend
    until ch == $0D or inbuff.0 == $7F
    cout($0D)
    return inbuff
end
def home
end
def gotoxy(x, y)
end
def viewport(left, top, width, height)
end
def prbyte(v)
    cout(hexchar[(v >> 4) & $0F])
    return cout(hexchar[v & $0F])
end
def prword(v)
    prbyte(v >> 8)
    return prbyte(v)
end
;
; CFFA1 routines
; FILE I/O
;
def opendir
    perr = syscall($10)
    return perr
end
def readdir
    perr = syscall($12)
    return *CFFAEntryPtr
end
def finddirentry(filename)
    *CFFAFileName = filename
    perr = syscall($14)
    return *CFFAEntryPtr    
end
def readfile(filename, buffer)
    *CFFADest     = buffer
    *CFFAFileName = filename
    perr = syscall($22)
    return perr
end
;
; Heap routines.
;
def availheap
    byte fp
    return @fp - heap
end
def allocheap(size)
    word addr
    addr = heap
    heap = heap + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def allocalignheap(size, pow2, freeaddr)
    word align, addr
    if freeaddr
        *freeaddr = heap
    fin
    align = (1 << pow2) - 1
    addr = (heap | align) + 1
    heap = addr + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def markheap
    return heap;
end
def releaseheap(newheap)
    heap = newheap;
    return @newheap - heap;
end
;
; DCI table routines,
;
def addtbl(dci, val, last)
    while ^dci & $80
        ^*last = ^dci
        *last  = *last + 1
        dci    = dci   + 1
    loop
    ^*last = ^dci
    *last  = *last + 1
    **last = val
    *last  = *last + 2
    ^*last = 0
end
;
; Symbol table routines.
;
def lookupsym(sym)
    return lookuptbl(sym, symtbl)
end
def addsym(sym, addr)
    return addtbl(sym, addr, @lastsym);
end
;
; Module routines.
;
def lookupmod(mod)
    byte dci[17]
    return lookuptbl(modtosym(mod, @dci), symtbl)
end
def addmod(mod, addr)
    byte dci[17]
    return addtbl(modtosym(mod, @dci), addr, @lastsym)
end
def lookupextern(esd, index)
    word sym
    byte str[16]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if (esd).0 & $10 and (esd).1 == index
            return lookupsym(sym)
        fin
        esd = esd + 3
    loop
    prbyte(index)
    cout('?')
    crout
    return 0
end
def adddef(addr, deflast)
    word defentry
    defentry = *deflast
    *deflast = defentry + 5
    (defentry).0 = $20
    (defentry):1 = interp
    (defentry):3 = addr
    (defentry).5 = 0 ; null out next entry
    return defentry
end
def lookupdef(addr, deftbl)
    while (deftbl).0 == $20
        if (deftbl):3 == addr
            return deftbl
        fin
        deftbl = deftbl + 5
    loop
    return 0
end
def loadmod(mod)
    word refnum, rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr, modaddr, modfix, modend
    word deftbl, deflast
    word moddep, rld, esd, sym
    byte str[17], filename[17]
    ;
    ; Read the RELocatable module header (first 128 bytes)
    ;
    dcitos(mod, @filename)    
    rdlen = (finddirentry(@filename)):$15
    if perr
        return -perr
    fin
    if rdlen > 0
        readfile(@filename, heap)
	modsize = (heap):0
	moddep  = heap+1
	defofst = modsize
        init    = 0
        if rdlen > 4 and (heap):2 == $DA7E ; DAVE = magic number :-)
            ;
            ; This is an EXTended RELocatable (data+bytecode) module.
            ;
            defofst  = (heap):6
            defcnt   = (heap):8
            init     = (heap):10
            moddep   = heap + 12
	    ;
	    ; Load module dependencies.
	    ;
            while ^moddep
                if !lookupmod(moddep)
                    if loadmod(moddep) < 0
	      	        return perr
		    fin
                fin
                moddep = moddep + dcitos(moddep, @str)
            loop
	    ;
	    ; Init def table.
	    ;
	    deftbl   = allocheap(defcnt * 5 + 1)
	    deflast  = deftbl
	    ^deflast = 0
	    ;
	    ; Re-read file
	    ;
	    readfile(@filename, heap)
            moddep = heap + 12
            while ^moddep
                moddep = moddep + dcitos(moddep, @str)
            loop
        fin
	;
	; Alloc heap space for relocated module (data + bytecode).
	;
	moddep  = moddep  + 1
	modfix  = moddep  - (heap + 2) ; Adjust to skip header
	modsize = modsize - modfix
	rdlen   = rdlen   - modfix - 2
	modaddr = allocheap(modsize)
	memcpy(modaddr, moddep, rdlen)
	;
	; Apply all fixups and symbol import/export.
	;
        modfix   = modaddr - modfix
        bytecode = defofst + modfix - MODADDR
        modend   = modaddr + modsize
        rld      = modend  ; Re-Locatable Directory
        esd      = rld     ; Extern+Entry Symbol Directory
        while ^esd         ; Scan to end of ESD
            esd = esd + 4
	loop
        esd = esd + 1
        ;
        ; Run through the Re-Location Dictionary.
        ;
        while ^rld
            if ^rld == $02
	        ;
		; This is a bytcode def entry - add it to the def directory.
		;
                adddef((rld):1 - defofst + bytecode, @deflast)
            else
                addr = (rld):1 + modfix
                if uword_isge(addr, modaddr) ; Skip fixups to header
                    if ^rld & $80 ; WORD sized fixup.
                        fixup = *addr
                    else	  ; BYTE sized fixup.
                        fixup = ^addr
                    fin
                    if ^rld & $10 ; EXTERN reference.
                        fixup = fixup + lookupextern(esd, (rld).3)
                    else	  ; INTERN fixup.
                        fixup = fixup + modfix - MODADDR
                        if uword_isge(fixup, bytecode)
                            ;
                            ; Bytecode address - replace with call def directory.
                            ;
                            fixup = lookupdef(fixup - bytecode + bytecode, deftbl)
                        fin
                    fin
                    if ^rld & $80 ; WORD sized fixup.
                        *addr = fixup
                    else	  ; BYTE sized fixup.
                        ^addr = fixup
                    fin
                fin
            fin
            rld = rld + 4
        loop
	;
        ; Run through the External/Entry Symbol Directory.
	;
        while ^esd
            sym = esd
            esd = esd + dcitos(esd, @str)
            if ^esd & $08
		;
                ; EXPORT symbol - add it to the global symbol table.
		;
                addr = (esd):1 + modfix - MODADDR
                if uword_isge(addr, bytecode)
		    ;
		    ; Use the def directory address for bytecode.
		    ;
                    addr = lookupdef(addr - bytecode + bytecode, deftbl)
                fin
                addsym(sym, addr)
            fin
            esd = esd + 3
        loop
    else
        perr = perr | 0x100
        return -perr
    fin
    ;
    ; Call init routine if it exists.
    ;
    if init
        return adddef(init - defofst + bytecode, @deflast)()
    fin
    return 0
end
;
; Command mode
;
def catalog
    byte type, len
    word entry, filecnt

    opendir
    repeat
        entry = readdir
	if !perr
	    type = ^entry
	    if type
	        len = type & $0F
		^entry = len
		prstr(entry)
	    if type & $F0 == $D0 ; Is it a directory?
	        cout('/')
	        len = len + 1
	    elsif (entry).$10 == $FF
	        cout('-')
		len = len + 1
	    elsif (entry).$10 == $FE
	        cout('+')
		len = len + 1
	    fin
	        for len = 19 - len downto 0
		    cout(' ')
                next
            fin
	fin
    until perr
    perr = 0
    return crout()
end
def stripchars(strptr)
    while ^strptr and ^(strptr + 1) <> ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
    return ^strptr
end
def stripspaces(strptr)
    while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)
    byte i

    for i = 1 to ^strptr
        if (strptr)[i] == ' '
	    ^strptr = i - 1
	    return
	fin
    next
end
def parsecmd(strptr)
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
def execmod(modfile)
    byte moddci[17]
    word saveheap, savesym, saveflags
  
    if stodci(modfile, @moddci)
        saveheap  = heap
	savesym     = lastsym
	saveflags   = systemflags
	^lastsym    = 0
	perr        = loadmod(@moddci)
	systemflags = saveflags
	lastsym     = savesym
	heap        = saveheap
    fin
end

;
; Get heap start
;
heap = *$0006
;
; Print some startup info.
;
prstr(@version)
prstr(@freestr)
prword(availheap)
crout
;
; Init symbol table.
;
symtbl   = allocheap($200)
lastsym  = symtbl
^lastsym = 0
stodci(@stdlibstr, heap)
addmod(heap, 1)
while *stdlibsym
    stodci((stdlibsym):0, heap)
    addsym(heap, (stdlibsym):2)
    stdlibsym = stdlibsym + 4
loop
;
; Handle commands.
;
while 1
    prstr(@prompt)
    cmdptr = rdstr($BA)
    if ^cmdptr
        when toupper(parsecmd(cmdptr))
            is 'Q'
	        quit
	    is 'M'
	        syscall($02)
	    is 'C'
	        catalog
	    is '+'
	        execmod(cmdptr)
	    otherwise
	        prstr(@huhstr)
        wend
        if perr
            prstr(@errorstr)
	    prbyte(perr)
	    perr = 0
        else
            prstr(@okstr)
        fin
	crout()
    fin
loop
done
