; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; toolsrc/codeopt.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; toolsrc/codeopt.pla: 0001: 
; toolsrc/codeopt.pla: 0002: //
; toolsrc/codeopt.pla: 0003: // Imports from main compiler
; toolsrc/codeopt.pla: 0004: //
; toolsrc/codeopt.pla: 0005: import plasm
	; DCI STRING: PLASM
	!BYTE	$D0,$CC,$C1,$D3,$4D
					; PLASM -> X028
; toolsrc/codeopt.pla: 0006:     word freeop_lst
					; FREEOP_LST -> X029
; toolsrc/codeopt.pla: 0007:     word optimize_seq
					; OPTIMIZE_SEQ -> X030
; toolsrc/codeopt.pla: 0008: end
; toolsrc/codeopt.pla: 0009: //
; toolsrc/codeopt.pla: 0010: // Code sequence values shares with main compiler
; toolsrc/codeopt.pla: 0011: //
; toolsrc/codeopt.pla: 0012: include "toolsrc/codeseq.plh"
; toolsrc/codeseq.plh: 0001: //
; toolsrc/codeseq.plh: 0002: // Constant code group
; toolsrc/codeseq.plh: 0003: //
; toolsrc/codeseq.plh: 0004: const CONST_GROUP       = $00
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; CONST_GROUP = 0
; toolsrc/codeseq.plh: 0005: const CONST_CODE        = $2C
					; CONST_CODE = 44
; toolsrc/codeseq.plh: 0006: const ADDI_CODE         = $38
					; ADDI_CODE = 56
; toolsrc/codeseq.plh: 0007: const SUBI_CODE         = $3A
					; SUBI_CODE = 58
; toolsrc/codeseq.plh: 0008: const ANDI_CODE         = $3C
					; ANDI_CODE = 60
; toolsrc/codeseq.plh: 0009: const ORI_CODE          = $3E
					; ORI_CODE = 62
; toolsrc/codeseq.plh: 0010: const CONSTR_GROUP      = $01
					; CONSTR_GROUP = 1
; toolsrc/codeseq.plh: 0011: const CONSTR_CODE       = $2E
					; CONSTR_CODE = 46
; toolsrc/codeseq.plh: 0012: //
; toolsrc/codeseq.plh: 0013: // Stack code group
; toolsrc/codeseq.plh: 0014: //
; toolsrc/codeseq.plh: 0015: const STACK_GROUP       = $02
					; STACK_GROUP = 2
; toolsrc/codeseq.plh: 0016: const INDEXB_CODE       = $82
					; INDEXB_CODE = 130
; toolsrc/codeseq.plh: 0017: const ADD_CODE          = $82
					; ADD_CODE = 130
; toolsrc/codeseq.plh: 0018: const SUB_CODE          = $84
					; SUB_CODE = 132
; toolsrc/codeseq.plh: 0019: const MUL_CODE          = $86
					; MUL_CODE = 134
; toolsrc/codeseq.plh: 0020: const DIV_CODE          = $88
					; DIV_CODE = 136
; toolsrc/codeseq.plh: 0021: const MOD_CODE          = $8A
					; MOD_CODE = 138
; toolsrc/codeseq.plh: 0022: const INC_CODE          = $8C
					; INC_CODE = 140
; toolsrc/codeseq.plh: 0023: const DEC_CODE          = $8E
					; DEC_CODE = 142
; toolsrc/codeseq.plh: 0024: const NEG_CODE          = $90
					; NEG_CODE = 144
; toolsrc/codeseq.plh: 0025: const COMP_CODE         = $92
					; COMP_CODE = 146
; toolsrc/codeseq.plh: 0026: const AND_CODE          = $94
					; AND_CODE = 148
; toolsrc/codeseq.plh: 0027: const OR_CODE           = $96
					; OR_CODE = 150
; toolsrc/codeseq.plh: 0028: const EOR_CODE          = $98
					; EOR_CODE = 152
; toolsrc/codeseq.plh: 0029: const SHL_CODE          = $9A
					; SHL_CODE = 154
; toolsrc/codeseq.plh: 0030: const SHR_CODE          = $9C
					; SHR_CODE = 156
; toolsrc/codeseq.plh: 0031: const INDEXW_CODE       = $9E
					; INDEXW_CODE = 158
; toolsrc/codeseq.plh: 0032: const LOGIC_NOT_CODE    = $80
					; LOGIC_NOT_CODE = 128
; toolsrc/codeseq.plh: 0033: const DROP_CODE         = $30
					; DROP_CODE = 48
; toolsrc/codeseq.plh: 0034: const DROP2_CODE        = $32
					; DROP2_CODE = 50
; toolsrc/codeseq.plh: 0035: const DUP_CODE          = $34
					; DUP_CODE = 52
; toolsrc/codeseq.plh: 0036: const EQ_CODE           = $40
					; EQ_CODE = 64
; toolsrc/codeseq.plh: 0037: const NE_CODE           = $42
					; NE_CODE = 66
; toolsrc/codeseq.plh: 0038: const GT_CODE           = $44
					; GT_CODE = 68
; toolsrc/codeseq.plh: 0039: const LT_CODE           = $46
					; LT_CODE = 70
; toolsrc/codeseq.plh: 0040: const GE_CODE           = $48
					; GE_CODE = 72
; toolsrc/codeseq.plh: 0041: const LE_CODE           = $4A
					; LE_CODE = 74
; toolsrc/codeseq.plh: 0042: const ICAL_CODE         = $56
					; ICAL_CODE = 86
; toolsrc/codeseq.plh: 0043: const RET_CODE          = $5C
					; RET_CODE = 92
; toolsrc/codeseq.plh: 0044: const LB_CODE           = $60
					; LB_CODE = 96
; toolsrc/codeseq.plh: 0045: const BPTR_CODE         = $60
					; BPTR_CODE = 96
; toolsrc/codeseq.plh: 0046: const LW_CODE           = $62
					; LW_CODE = 98
; toolsrc/codeseq.plh: 0047: const WPTR_CODE         = $62
					; WPTR_CODE = 98
; toolsrc/codeseq.plh: 0048: const SB_CODE           = $70
					; SB_CODE = 112
; toolsrc/codeseq.plh: 0049: const SW_CODE           = $72
					; SW_CODE = 114
; toolsrc/codeseq.plh: 0050: //
; toolsrc/codeseq.plh: 0051: // Local address code group
; toolsrc/codeseq.plh: 0052: //
; toolsrc/codeseq.plh: 0053: const LOCAL_GROUP       = $03
					; LOCAL_GROUP = 3
; toolsrc/codeseq.plh: 0054: const LADDR_CODE        = $28
					; LADDR_CODE = 40
; toolsrc/codeseq.plh: 0055: const LLB_CODE          = $64
					; LLB_CODE = 100
; toolsrc/codeseq.plh: 0056: const LLW_CODE          = $66
					; LLW_CODE = 102
; toolsrc/codeseq.plh: 0057: const DLB_CODE          = $6C
					; DLB_CODE = 108
; toolsrc/codeseq.plh: 0058: const DLW_CODE          = $6E
					; DLW_CODE = 110
; toolsrc/codeseq.plh: 0059: const SLB_CODE          = $74
					; SLB_CODE = 116
; toolsrc/codeseq.plh: 0060: const SLW_CODE          = $76
					; SLW_CODE = 118
; toolsrc/codeseq.plh: 0061: const ADDLB_CODE        = $B0
					; ADDLB_CODE = 176
; toolsrc/codeseq.plh: 0062: const ADDLW_CODE        = $B2
					; ADDLW_CODE = 178
; toolsrc/codeseq.plh: 0063: const IDXLB_CODE        = $B8
					; IDXLB_CODE = 184
; toolsrc/codeseq.plh: 0064: const IDXLW_CODE        = $BA
					; IDXLW_CODE = 186
; toolsrc/codeseq.plh: 0065: //
; toolsrc/codeseq.plh: 0066: // Global address code group
; toolsrc/codeseq.plh: 0067: //
; toolsrc/codeseq.plh: 0068: const GLOBAL_GROUP      = $04
					; GLOBAL_GROUP = 4
; toolsrc/codeseq.plh: 0069: const GADDR_CODE        = $26
					; GADDR_CODE = 38
; toolsrc/codeseq.plh: 0070: const CALL_CODE         = $54
					; CALL_CODE = 84
; toolsrc/codeseq.plh: 0071: const LAB_CODE          = $68
					; LAB_CODE = 104
; toolsrc/codeseq.plh: 0072: const LAW_CODE          = $6A
					; LAW_CODE = 106
; toolsrc/codeseq.plh: 0073: const SAB_CODE          = $78
					; SAB_CODE = 120
; toolsrc/codeseq.plh: 0074: const SAW_CODE          = $7A
					; SAW_CODE = 122
; toolsrc/codeseq.plh: 0075: const DAB_CODE          = $7C
					; DAB_CODE = 124
; toolsrc/codeseq.plh: 0076: const DAW_CODE          = $7E
					; DAW_CODE = 126
; toolsrc/codeseq.plh: 0077: const ADDAB_CODE        = $B4
					; ADDAB_CODE = 180
; toolsrc/codeseq.plh: 0078: const ADDAW_CODE        = $B6
					; ADDAW_CODE = 182
; toolsrc/codeseq.plh: 0079: const IDXAB_CODE        = $BC
					; IDXAB_CODE = 188
; toolsrc/codeseq.plh: 0080: const IDXAW_CODE        = $BE
					; IDXAW_CODE = 190
; toolsrc/codeseq.plh: 0081: //
; toolsrc/codeseq.plh: 0082: // Relative address code group
; toolsrc/codeseq.plh: 0083: //
; toolsrc/codeseq.plh: 0084: const RELATIVE_GROUP    = $05
					; RELATIVE_GROUP = 5
; toolsrc/codeseq.plh: 0085: const BREQ_CODE         = $22
					; BREQ_CODE = 34
; toolsrc/codeseq.plh: 0086: const BRNE_CODE         = $24
					; BRNE_CODE = 36
; toolsrc/codeseq.plh: 0087: const BRFALSE_CODE      = $4C
					; BRFALSE_CODE = 76
; toolsrc/codeseq.plh: 0088: const BRTRUE_CODE       = $4E
					; BRTRUE_CODE = 78
; toolsrc/codeseq.plh: 0089: const BRNCH_CODE        = $50
					; BRNCH_CODE = 80
; toolsrc/codeseq.plh: 0090: const BRAND_CODE        = $AC
					; BRAND_CODE = 172
; toolsrc/codeseq.plh: 0091: const BROR_CODE         = $AE
					; BROR_CODE = 174
; toolsrc/codeseq.plh: 0092: const BRGT_CODE         = $A0
					; BRGT_CODE = 160
; toolsrc/codeseq.plh: 0093: const BRLT_CODE         = $A2
					; BRLT_CODE = 162
; toolsrc/codeseq.plh: 0094: //
; toolsrc/codeseq.plh: 0095: // Code tag address group
; toolsrc/codeseq.plh: 0096: //
; toolsrc/codeseq.plh: 0097: const CODETAG_GROUP     = $06
					; CODETAG_GROUP = 6
; toolsrc/codeseq.plh: 0098: //
; toolsrc/codeseq.plh: 0099: // Invalid code
; toolsrc/codeseq.plh: 0100: //
; toolsrc/codeseq.plh: 0101: const INVALID_CODE      = $FF
					; INVALID_CODE = 255
; toolsrc/codeseq.plh: 0102: //
; toolsrc/codeseq.plh: 0103: // Code sequence op
; toolsrc/codeseq.plh: 0104: //
; toolsrc/codeseq.plh: 0105: struc t_opseq
; toolsrc/codeseq.plh: 0106:     byte opcode
					; opcode = 0
; toolsrc/codeseq.plh: 0107:     byte opgroup
					; opgroup = 1
; toolsrc/codeseq.plh: 0108:     word opval[]
					; opval = 2
; toolsrc/codeseq.plh: 0109:     word optag
					; optag = 2
; toolsrc/codeseq.plh: 0110:     word opoffset
					; opoffset = 4
; toolsrc/codeseq.plh: 0111:     word opnext
					; opnext = 6
; toolsrc/codeseq.plh: 0112: end
					; t_opseq = 8
; toolsrc/codeopt.pla: 0012: 
; toolsrc/codeopt.pla: 0013: //
; toolsrc/codeopt.pla: 0014: // Replace all but the first of a series of identical load opcodes by DUP. This
; toolsrc/codeopt.pla: 0015: // doesn't reduce the number of opcodes but does reduce their size in bytes.
; toolsrc/codeopt.pla: 0016: // This is only called on the second optimisation pass because the DUP opcodes
; toolsrc/codeopt.pla: 0017: // may inhibit other peephole optimisations which are more valuable.
; toolsrc/codeopt.pla: 0018: //
; toolsrc/codeopt.pla: 0019: def try_dupify(op)
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
					; op -> [0]
_C000 					; try_dupify()
; toolsrc/codeopt.pla: 0020:     byte crunched
					; crunched -> [2]
; toolsrc/codeopt.pla: 0021:     word nextop
					; nextop -> [3]
; toolsrc/codeopt.pla: 0022: 
; toolsrc/codeopt.pla: 0023:     crunched = FALSE
	!BYTE	$58,$05,$01		; ENTER	5,1
; toolsrc/codeopt.pla: 0024:     nextop   = op=>opnext
; toolsrc/codeopt.pla: 0025:     while nextop
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$50			; BRNCH	_B003
	!WORD	_B003-*
_B001 
; toolsrc/codeopt.pla: 0026:         if op->opcode <> nextop->opcode; return crunched; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B004
	!WORD	_B004-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
_B004 
_B005 
; toolsrc/codeopt.pla: 0027:         when op->opcode
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B007-*
; toolsrc/codeopt.pla: 0028:             is CONST_CODE
_B008 
; toolsrc/codeopt.pla: 0029:                 if op=>opval <> nextop=>opval; return crunched; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$22			; BREQ	_B009
	!WORD	_B009-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
_B009 
_B010 
; toolsrc/codeopt.pla: 0030:                 break
	!BYTE	$50			; BRNCH	_B006
	!WORD	_B006-*
; toolsrc/codeopt.pla: 0031:             is LADDR_CODE
_B011 
; toolsrc/codeopt.pla: 0032:             is LLB_CODE
_B012 
; toolsrc/codeopt.pla: 0033:             is LLW_CODE
_B013 
; toolsrc/codeopt.pla: 0034:                 if op=>opoffset <> nextop=>opoffset; return crunched; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$22			; BREQ	_B014
	!WORD	_B014-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
_B014 
_B015 
; toolsrc/codeopt.pla: 0035:                 break
	!BYTE	$50			; BRNCH	_B006
	!WORD	_B006-*
; toolsrc/codeopt.pla: 0036:             is GADDR_CODE
_B016 
; toolsrc/codeopt.pla: 0037:             is LAB_CODE
_B017 
; toolsrc/codeopt.pla: 0038:             is LAW_CODE
_B018 
; toolsrc/codeopt.pla: 0039:                 if (op=>optag <> nextop=>optag) or (op=>opoffset <> nextop=>opoffset); return crunched; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B019
	!WORD	_B019-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$42			; ISNE
_B019 
	!BYTE	$4C			; BRFLS	_B020
	!WORD	_B020-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
_B020 
_B021 
; toolsrc/codeopt.pla: 0040:                 break
	!BYTE	$50			; BRNCH	_B006
	!WORD	_B006-*
; toolsrc/codeopt.pla: 0041:             otherwise
_B007 
	!BYTE	$07			; CASEBLOCK
	!WORD	$0026
	!WORD	_B016-*
	!WORD	$0028
	!WORD	_B011-*
	!WORD	$002C
	!WORD	_B008-*
	!WORD	$0064
	!WORD	_B012-*
	!WORD	$0066
	!WORD	_B013-*
	!WORD	$0068
	!WORD	_B017-*
	!WORD	$006A
	!WORD	_B018-*
; toolsrc/codeopt.pla: 0042:                 return crunched
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/codeopt.pla: 0043:         wend
_B006 
; toolsrc/codeopt.pla: 0044:         nextop->opcode  = DUP_CODE
; toolsrc/codeopt.pla: 0045:         nextop->opgroup = STACK_GROUP
; toolsrc/codeopt.pla: 0046:         nextop          = nextop=>opnext
; toolsrc/codeopt.pla: 0047:         crunched        = TRUE
; toolsrc/codeopt.pla: 0048:     loop
	!BYTE	$2A,$34			; CB	52
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$02			; SLB	[2]
_B003 
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
_B002 
; toolsrc/codeopt.pla: 0049:     return crunched
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/codeopt.pla: 0050: end
; toolsrc/codeopt.pla: 0051: def is_hardware_address(addr)
					; addr -> [0]
_C001 					; is_hardware_address()
; toolsrc/codeopt.pla: 0052:     return isuge(addr, $C000) and isult(addr, $D000)
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$54			; CALL	_X025
_F000 	!WORD	0		
	!BYTE	$AC			; BRAND	_B022
	!WORD	_B022-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$D0		; CW	53248
	!BYTE	$54			; CALL	_X026
_F001 	!WORD	0		
_B022 
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codeopt.pla: 0053: end
; toolsrc/codeopt.pla: 0054: //
; toolsrc/codeopt.pla: 0055: // Crunch sequence (peephole optimize)
; toolsrc/codeopt.pla: 0056: //
; toolsrc/codeopt.pla: 0057: def crunch_seq(seq, pass)
					; seq -> [0]
					; pass -> [2]
_C002 					; crunch_seq()
; toolsrc/codeopt.pla: 0058:     word nextop, nextopnext, opprev, op, freeops
					; nextop -> [4]
					; nextopnext -> [6]
					; opprev -> [8]
					; op -> [10]
					; freeops -> [12]
; toolsrc/codeopt.pla: 0059:     byte crunched, shiftcnt
					; crunched -> [14]
					; shiftcnt -> [15]
; toolsrc/codeopt.pla: 0060: 
; toolsrc/codeopt.pla: 0061:     opprev   = NULL
	!BYTE	$58,$10,$02		; ENTER	16,2
; toolsrc/codeopt.pla: 0062:     op       = *seq
; toolsrc/codeopt.pla: 0063:     nextop   = op=>opnext
; toolsrc/codeopt.pla: 0064:     crunched = FALSE
; toolsrc/codeopt.pla: 0065:     freeops  = 0
; toolsrc/codeopt.pla: 0066:     while op and nextop
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B025
	!WORD	_B025-*
_B023 
; toolsrc/codeopt.pla: 0067:         when op->opcode
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B028-*
; toolsrc/codeopt.pla: 0068:             is CONST_CODE
_B029 
; toolsrc/codeopt.pla: 0069:                 if op=>opval == 1
; toolsrc/codeopt.pla: 0070:                     if nextop->opcode == ADD_CODE
; toolsrc/codeopt.pla: 0071:                         op->opcode  = INC_CODE
; toolsrc/codeopt.pla: 0072:                         op->opgroup = STACK_GROUP
; toolsrc/codeopt.pla: 0073:                         freeops     = 1
; toolsrc/codeopt.pla: 0074:                         break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$24			; BRNE	_B030
	!WORD	_B030-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$82			; CB	130
	!BYTE	$24			; BRNE	_B032
	!WORD	_B032-*
	!BYTE	$2A,$8C			; CB	140
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0075:                     fin
_B032 
_B033 
; toolsrc/codeopt.pla: 0076:                     if nextop->opcode == SUB_CODE
; toolsrc/codeopt.pla: 0077:                         op->opcode  = DEC_CODE
; toolsrc/codeopt.pla: 0078:                         op->opgroup = STACK_GROUP
; toolsrc/codeopt.pla: 0079:                         freeops     = 1
; toolsrc/codeopt.pla: 0080:                         break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$84			; CB	132
	!BYTE	$24			; BRNE	_B034
	!WORD	_B034-*
	!BYTE	$2A,$8E			; CB	142
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0081:                     fin
_B034 
_B035 
; toolsrc/codeopt.pla: 0082:                     if nextop->opcode == SHL_CODE
; toolsrc/codeopt.pla: 0083:                         op->opcode     = DUP_CODE
; toolsrc/codeopt.pla: 0084:                         op->opgroup    = STACK_GROUP
; toolsrc/codeopt.pla: 0085:                         nextop->opcode = ADD_CODE
; toolsrc/codeopt.pla: 0086:                         break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$24			; BRNE	_B036
	!WORD	_B036-*
	!BYTE	$2A,$34			; CB	52
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$82			; CB	130
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0087:                     fin
_B036 
_B037 
; toolsrc/codeopt.pla: 0088:                     if nextop->opcode == MUL_CODE or nextop->opcode == DIV_CODE
; toolsrc/codeopt.pla: 0089:                         freeops = -2
; toolsrc/codeopt.pla: 0090:                         break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$86			; CB	134
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B038
	!WORD	_B038-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$88			; CB	136
	!BYTE	$40			; ISEQ
_B038 
	!BYTE	$4C			; BRFLS	_B039
	!WORD	_B039-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0091:                     fin
_B039 
_B040 
; toolsrc/codeopt.pla: 0092:                 fin
_B030 
_B031 
; toolsrc/codeopt.pla: 0093:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B042-*
; toolsrc/codeopt.pla: 0094:                     is NEG_CODE
_B043 
; toolsrc/codeopt.pla: 0095:                         op=>opval = -op=>opval
; toolsrc/codeopt.pla: 0096:                         freeops   = 1
; toolsrc/codeopt.pla: 0097:                         break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0098:                     is COMP_CODE
_B044 
; toolsrc/codeopt.pla: 0099:                         op=>opval = ~op=>opval
; toolsrc/codeopt.pla: 0100:                         freeops   = 1
; toolsrc/codeopt.pla: 0101:                         break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$92			; COMP
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0102:                     is LOGIC_NOT_CODE
_B045 
; toolsrc/codeopt.pla: 0103:                         op=>opval = op=>opval ?? FALSE :: TRUE
; toolsrc/codeopt.pla: 0104:                         freeops   = 1
; toolsrc/codeopt.pla: 0105:                         break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B046
	!WORD	_B046-*
	!BYTE	$00			; CN	0
	!BYTE	$50			; BRNCH	_B047
	!WORD	_B047-*
_B046 
	!BYTE	$20			; MINUS ONE
_B047 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0106:                     is BRFALSE_CODE
_B048 
; toolsrc/codeopt.pla: 0107:                         if op=>opval
; toolsrc/codeopt.pla: 0108:                             freeops = -2 // Remove constant and never taken branch
; toolsrc/codeopt.pla: 0109:                         else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B049
	!WORD	_B049-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B050
	!WORD	_B050-*
_B049 
; toolsrc/codeopt.pla: 0110:                             op->opcode  = BRNCH_CODE // Always taken branch
; toolsrc/codeopt.pla: 0111:                             op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0112:                             op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0113:                             freeops     = 1
; toolsrc/codeopt.pla: 0114:                         fin
	!BYTE	$2A,$50			; CB	80
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B050 
; toolsrc/codeopt.pla: 0115:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0116:                     is BRTRUE_CODE
_B051 
; toolsrc/codeopt.pla: 0117:                         if not op=>opval
; toolsrc/codeopt.pla: 0118:                             freeops = -2 // Remove constant never taken branch
; toolsrc/codeopt.pla: 0119:                         else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B052
	!WORD	_B052-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B053
	!WORD	_B053-*
_B052 
; toolsrc/codeopt.pla: 0120:                             op->opcode  = BRNCH_CODE // Always taken branch
; toolsrc/codeopt.pla: 0121:                             op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0122:                             op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0123:                             freeops     = 1
; toolsrc/codeopt.pla: 0124:                         fin
	!BYTE	$2A,$50			; CB	80
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B053 
; toolsrc/codeopt.pla: 0125:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0126:                     is BRGT_CODE
_B054 
; toolsrc/codeopt.pla: 0127:                         if opprev and (opprev->opcode == CONST_CODE) and (op=>opval <= opprev=>opval)
; toolsrc/codeopt.pla: 0128:                             freeops = 1
; toolsrc/codeopt.pla: 0129:                         fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$AC			; BRAND	_B055
	!WORD	_B055-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$60			; LB
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B056
	!WORD	_B056-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4A			; ISLE
_B056 
_B055 
	!BYTE	$4C			; BRFLS	_B057
	!WORD	_B057-*
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B057 
_B058 
; toolsrc/codeopt.pla: 0130:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0131:                     is BRLT_CODE
_B059 
; toolsrc/codeopt.pla: 0132:                         if opprev and (opprev->opcode == CONST_CODE) and (op=>opval >= opprev=>opval)
; toolsrc/codeopt.pla: 0133:                             freeops = 1
; toolsrc/codeopt.pla: 0134:                         fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$AC			; BRAND	_B060
	!WORD	_B060-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$60			; LB
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B061
	!WORD	_B061-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$48			; ISGE
_B061 
_B060 
	!BYTE	$4C			; BRFLS	_B062
	!WORD	_B062-*
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B062 
_B063 
; toolsrc/codeopt.pla: 0135:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0136:                     is BROR_CODE
_B064 
; toolsrc/codeopt.pla: 0137:                         if not op=>opval
; toolsrc/codeopt.pla: 0138:                             freeops = -2 // Remove zero constant
; toolsrc/codeopt.pla: 0139:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B065
	!WORD	_B065-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
_B065 
_B066 
; toolsrc/codeopt.pla: 0140:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0141:                     is BRAND_CODE
_B067 
; toolsrc/codeopt.pla: 0142:                         if op=>opval
; toolsrc/codeopt.pla: 0143:                             freeops = -2 // Remove non-zero constant
; toolsrc/codeopt.pla: 0144:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B068
	!WORD	_B068-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
_B068 
_B069 
; toolsrc/codeopt.pla: 0145:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0146:                     is NE_CODE
_B070 
; toolsrc/codeopt.pla: 0147:                         if not op=>opval
; toolsrc/codeopt.pla: 0148:                             freeops = -2 // Remove ZERO:ISNE
; toolsrc/codeopt.pla: 0149:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B071
	!WORD	_B071-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
_B071 
_B072 
; toolsrc/codeopt.pla: 0150:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0151:                     is EQ_CODE
_B073 
; toolsrc/codeopt.pla: 0152:                         if not op=>opval
; toolsrc/codeopt.pla: 0153:                             op->opcode  = LOGIC_NOT_CODE // Replace ZERO:ISEQ
; toolsrc/codeopt.pla: 0154:                             op->opgroup = STACK_GROUP
; toolsrc/codeopt.pla: 0155:                             freeops     = 1
; toolsrc/codeopt.pla: 0156:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B074
	!WORD	_B074-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B074 
_B075 
; toolsrc/codeopt.pla: 0157:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0158:                     is CONST_CODE // Collapse constant operation
_B076 
; toolsrc/codeopt.pla: 0159:                         nextopnext = nextop=>opnext
; toolsrc/codeopt.pla: 0160:                         if nextopnext
; toolsrc/codeopt.pla: 0161:                             when nextopnext->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$4C			; BRFLS	_B077
	!WORD	_B077-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B080-*
; toolsrc/codeopt.pla: 0162:                                 is MUL_CODE
_B081 
; toolsrc/codeopt.pla: 0163:                                     op=>opval = op=>opval * nextop=>opval
; toolsrc/codeopt.pla: 0164:                                     freeops   = 2
; toolsrc/codeopt.pla: 0165:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$86			; MUL
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0166:                                 is DIV_CODE
_B082 
; toolsrc/codeopt.pla: 0167:                                     op=>opval = op=>opval / nextop=>opval
; toolsrc/codeopt.pla: 0168:                                     freeops   = 2
; toolsrc/codeopt.pla: 0169:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$88			; DIV
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0170:                                 is MOD_CODE
_B083 
; toolsrc/codeopt.pla: 0171:                                     op=>opval = op=>opval % nextop=>opval
; toolsrc/codeopt.pla: 0172:                                     freeops   = 2
; toolsrc/codeopt.pla: 0173:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8A			; MOD
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0174:                                 is ADD_CODE
_B084 
; toolsrc/codeopt.pla: 0175:                                     op=>opval = op=>opval + nextop=>opval
; toolsrc/codeopt.pla: 0176:                                     freeops   = 2
; toolsrc/codeopt.pla: 0177:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0178:                                 is SUB_CODE
_B085 
; toolsrc/codeopt.pla: 0179:                                     op=>opval = op=>opval - nextop=>opval
; toolsrc/codeopt.pla: 0180:                                     freeops   = 2
; toolsrc/codeopt.pla: 0181:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$84			; SUB 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0182:                                 is SHL_CODE
_B086 
; toolsrc/codeopt.pla: 0183:                                     op=>opval = op=>opval << nextop=>opval
; toolsrc/codeopt.pla: 0184:                                     freeops   = 2
; toolsrc/codeopt.pla: 0185:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$9A			; SHL
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0186:                                 is SHR_CODE
_B087 
; toolsrc/codeopt.pla: 0187:                                     op=>opval = op=>opval >> nextop=>opval
; toolsrc/codeopt.pla: 0188:                                     freeops   = 2
; toolsrc/codeopt.pla: 0189:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$9C			; SHR
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0190:                                 is AND_CODE
_B088 
; toolsrc/codeopt.pla: 0191:                                     op=>opval = op=>opval & nextop=>opval
; toolsrc/codeopt.pla: 0192:                                     freeops   = 2
; toolsrc/codeopt.pla: 0193:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$94			; AND 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0194:                                 is OR_CODE
_B089 
; toolsrc/codeopt.pla: 0195:                                     op=>opval = op=>opval | nextop=>opval
; toolsrc/codeopt.pla: 0196:                                     freeops   = 2
; toolsrc/codeopt.pla: 0197:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$96			; OR 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0198:                                 is EOR_CODE
_B090 
; toolsrc/codeopt.pla: 0199:                                     op=>opval = op=>opval ^ nextop=>opval
; toolsrc/codeopt.pla: 0200:                                     freeops   = 2
; toolsrc/codeopt.pla: 0201:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$98			; XOR
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0202:                                 is EQ_CODE
_B091 
; toolsrc/codeopt.pla: 0203:                                     op=>opval = op=>opval == nextop=>opval
; toolsrc/codeopt.pla: 0204:                                     freeops   = 2
; toolsrc/codeopt.pla: 0205:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0206:                                 is NE_CODE
_B092 
; toolsrc/codeopt.pla: 0207:                                     op=>opval = op=>opval <> nextop=>opval
; toolsrc/codeopt.pla: 0208:                                     freeops   = 2
; toolsrc/codeopt.pla: 0209:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$42			; ISNE
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0210:                                 is GE_CODE
_B093 
; toolsrc/codeopt.pla: 0211:                                     op=>opval = op=>opval >= nextop=>opval
; toolsrc/codeopt.pla: 0212:                                     freeops   = 2
; toolsrc/codeopt.pla: 0213:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$48			; ISGE
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0214:                                 is LT_CODE
_B094 
; toolsrc/codeopt.pla: 0215:                                     op=>opval = op=>opval < nextop=>opval
; toolsrc/codeopt.pla: 0216:                                     freeops   = 2
; toolsrc/codeopt.pla: 0217:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$46			; ISLT
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0218:                                 is GT_CODE
_B095 
; toolsrc/codeopt.pla: 0219:                                     op=>opval = op=>opval > nextop=>opval
; toolsrc/codeopt.pla: 0220:                                     freeops   = 2
; toolsrc/codeopt.pla: 0221:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$44			; ISGT
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0222:                                 is LE_CODE
_B096 
; toolsrc/codeopt.pla: 0223:                                     op=>opval = op=>opval <= nextop=>opval
; toolsrc/codeopt.pla: 0224:                                     freeops   = 2
; toolsrc/codeopt.pla: 0225:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4A			; ISLE
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; toolsrc/codeopt.pla: 0226:                             wend // End of collapse constant operation
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
_B080 
	!BYTE	$10			; CASEBLOCK
	!WORD	$0040
	!WORD	_B091-*
	!WORD	$0042
	!WORD	_B092-*
	!WORD	$0044
	!WORD	_B095-*
	!WORD	$0046
	!WORD	_B094-*
	!WORD	$0048
	!WORD	_B093-*
	!WORD	$004A
	!WORD	_B096-*
	!WORD	$0082
	!WORD	_B084-*
	!WORD	$0084
	!WORD	_B085-*
	!WORD	$0086
	!WORD	_B081-*
	!WORD	$0088
	!WORD	_B082-*
	!WORD	$008A
	!WORD	_B083-*
	!WORD	$0094
	!WORD	_B088-*
	!WORD	$0096
	!WORD	_B089-*
	!WORD	$0098
	!WORD	_B090-*
	!WORD	$009A
	!WORD	_B086-*
	!WORD	$009C
	!WORD	_B087-*
_B079 
; toolsrc/codeopt.pla: 0227:                         fin
_B077 
_B078 
; toolsrc/codeopt.pla: 0228:                         if pass and not freeops and op=>opval
; toolsrc/codeopt.pla: 0229:                             crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0230:                         fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B097
	!WORD	_B097-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B098
	!WORD	_B098-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
_B098 
_B097 
	!BYTE	$4C			; BRFLS	_B099
	!WORD	_B099-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F002 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B099 
_B100 
; toolsrc/codeopt.pla: 0231:                         break // CONST_CODE
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0232:                     is ADD_CODE
_B101 
; toolsrc/codeopt.pla: 0233:                         if op=>opval == 0
; toolsrc/codeopt.pla: 0234:                             freeops = -2
; toolsrc/codeopt.pla: 0235:                         elsif op=>opval > 0 and op=>opval <= 255
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B102
	!WORD	_B102-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B103
	!WORD	_B103-*
_B102 
; toolsrc/codeopt.pla: 0236:                             op->opcode = ADDI_CODE
; toolsrc/codeopt.pla: 0237:                             freeops    = 1
; toolsrc/codeopt.pla: 0238:                         elsif op=>opval >= -255 and op=>opval < 0
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B104
	!WORD	_B104-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$4A			; ISLE
_B104 
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$2A,$38			; CB	56
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B103
	!WORD	_B103-*
_B105 
; toolsrc/codeopt.pla: 0239:                             op->opcode = SUBI_CODE
; toolsrc/codeopt.pla: 0240:                             op=>opval  = -op=>opval
; toolsrc/codeopt.pla: 0241:                             freeops    = 1
; toolsrc/codeopt.pla: 0242:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$5E,$01			; CFFB	-255
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B106
	!WORD	_B106-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
_B106 
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$2A,$3A			; CB	58
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B107 
_B103 
; toolsrc/codeopt.pla: 0243:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0244:                     is SUB_CODE
_B108 
; toolsrc/codeopt.pla: 0245:                         if op=>opval == 0
; toolsrc/codeopt.pla: 0246:                             freeops = -2
; toolsrc/codeopt.pla: 0247:                         elsif op=>opval > 0 and op=>opval <= 255
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B109
	!WORD	_B109-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B110
	!WORD	_B110-*
_B109 
; toolsrc/codeopt.pla: 0248:                             op->opcode = SUBI_CODE
; toolsrc/codeopt.pla: 0249:                             freeops    = 1
; toolsrc/codeopt.pla: 0250:                         elsif op=>opval >= -255 and op=>opval < 0
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B111
	!WORD	_B111-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$4A			; ISLE
_B111 
	!BYTE	$4C			; BRFLS	_B112
	!WORD	_B112-*
	!BYTE	$2A,$3A			; CB	58
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B110
	!WORD	_B110-*
_B112 
; toolsrc/codeopt.pla: 0251:                             op->opcode = ADDI_CODE
; toolsrc/codeopt.pla: 0252:                             op=>opval  = -op=>opval
; toolsrc/codeopt.pla: 0253:                             freeops    = 1
; toolsrc/codeopt.pla: 0254:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$5E,$01			; CFFB	-255
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B113
	!WORD	_B113-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
_B113 
	!BYTE	$4C			; BRFLS	_B114
	!WORD	_B114-*
	!BYTE	$2A,$38			; CB	56
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B114 
_B110 
; toolsrc/codeopt.pla: 0255:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0256:                     is AND_CODE
_B115 
; toolsrc/codeopt.pla: 0257:                         if op=>opval >= 0 and op=>opval <= 255
; toolsrc/codeopt.pla: 0258:                             op->opcode = ANDI_CODE
; toolsrc/codeopt.pla: 0259:                             freeops    = 1
; toolsrc/codeopt.pla: 0260:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B116
	!WORD	_B116-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$4A			; ISLE
_B116 
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B117 
_B118 
; toolsrc/codeopt.pla: 0261:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0262:                     is OR_CODE
_B119 
; toolsrc/codeopt.pla: 0263:                         if op=>opval == 0
; toolsrc/codeopt.pla: 0264:                             freeops = -2
; toolsrc/codeopt.pla: 0265:                         elsif op=>opval > 0 and op=>opval <= 255
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B120
	!WORD	_B120-*
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B121
	!WORD	_B121-*
_B120 
; toolsrc/codeopt.pla: 0266:                             op->opcode = ORI_CODE
; toolsrc/codeopt.pla: 0267:                             freeops    = 1
; toolsrc/codeopt.pla: 0268:                         fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B122
	!WORD	_B122-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$4A			; ISLE
_B122 
	!BYTE	$4C			; BRFLS	_B123
	!WORD	_B123-*
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B123 
_B121 
; toolsrc/codeopt.pla: 0269:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0270:                     is MUL_CODE
_B124 
; toolsrc/codeopt.pla: 0271:                         if op=>opval == 0
; toolsrc/codeopt.pla: 0272:                             op->opcode      = DROP_CODE
; toolsrc/codeopt.pla: 0273:                             op->opgroup     = STACK_GROUP
; toolsrc/codeopt.pla: 0274:                             nextop->opcode  = CONST_CODE
; toolsrc/codeopt.pla: 0275:                             nextop->opgroup = CONST_GROUP
; toolsrc/codeopt.pla: 0276:                             nextop=>opval   = 0
; toolsrc/codeopt.pla: 0277:                         elsif op=>opval == 2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B125
	!WORD	_B125-*
	!BYTE	$2A,$30			; CB	48
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B126
	!WORD	_B126-*
_B125 
; toolsrc/codeopt.pla: 0278:                             op->opcode     = DUP_CODE
; toolsrc/codeopt.pla: 0279:                             op->opgroup    = STACK_GROUP
; toolsrc/codeopt.pla: 0280:                             nextop->opcode = ADD_CODE
; toolsrc/codeopt.pla: 0281:                         elsif op=>opval == 3
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$04			; CN	2
	!BYTE	$24			; BRNE	_B127
	!WORD	_B127-*
	!BYTE	$2A,$34			; CB	52
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$82			; CB	130
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B126
	!WORD	_B126-*
_B127 
; toolsrc/codeopt.pla: 0282:                             op->opcode     = DUP_CODE
; toolsrc/codeopt.pla: 0283:                             op->opgroup    = STACK_GROUP
; toolsrc/codeopt.pla: 0284:                             nextop->opcode = INDEXW_CODE
; toolsrc/codeopt.pla: 0285:                         else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$06			; CN	3
	!BYTE	$24			; BRNE	_B128
	!WORD	_B128-*
	!BYTE	$2A,$34			; CB	52
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$9E			; CB	158
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B126
	!WORD	_B126-*
_B128 
; toolsrc/codeopt.pla: 0286:                             for shiftcnt = 2 to 15
	!BYTE	$1E			; CN	15
	!BYTE	$04			; CN	2
_B130 
	!BYTE	$6C,$0F			; DLB	[15]
; toolsrc/codeopt.pla: 0287:                                 if op=>opval == 1 << shiftcnt
; toolsrc/codeopt.pla: 0288:                                     op=>opval       = shiftcnt
; toolsrc/codeopt.pla: 0289:                                     nextop->opcode  = SHL_CODE
; toolsrc/codeopt.pla: 0290:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$9A			; SHL
	!BYTE	$24			; BRNE	_B132
	!WORD	_B132-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
; toolsrc/codeopt.pla: 0291:                                 fin
_B132 
_B133 
; toolsrc/codeopt.pla: 0292:                             next
_B131 
	!BYTE	$A4			; INCBRLE	_B130
	!WORD	_B130-*
_B129 
	!BYTE	$74,$0F			; SLB	[15]
	!BYTE	$30			; DROP 
; toolsrc/codeopt.pla: 0293:                         fin
_B126 
; toolsrc/codeopt.pla: 0294:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0295:                     is DIV_CODE
_B134 
; toolsrc/codeopt.pla: 0296:                        for shiftcnt = 1 to 15
	!BYTE	$1E			; CN	15
	!BYTE	$02			; CN	1
_B136 
	!BYTE	$6C,$0F			; DLB	[15]
; toolsrc/codeopt.pla: 0297:                             if op=>opval == 1 << shiftcnt
; toolsrc/codeopt.pla: 0298:                                 op=>opval      = shiftcnt
; toolsrc/codeopt.pla: 0299:                                 nextop->opcode = SHR_CODE
; toolsrc/codeopt.pla: 0300:                                 break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$9A			; SHL
	!BYTE	$24			; BRNE	_B138
	!WORD	_B138-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$2A,$9C			; CB	156
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B135
	!WORD	_B135-*
; toolsrc/codeopt.pla: 0301:                             fin
_B138 
_B139 
; toolsrc/codeopt.pla: 0302:                         next
_B137 
	!BYTE	$A4			; INCBRLE	_B136
	!WORD	_B136-*
_B135 
	!BYTE	$74,$0F			; SLB	[15]
	!BYTE	$30			; DROP 
; toolsrc/codeopt.pla: 0303:                         break
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; toolsrc/codeopt.pla: 0304:                 wend
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
_B042 
	!BYTE	$12			; CASEBLOCK
	!WORD	$002C
	!WORD	_B076-*
	!WORD	$0040
	!WORD	_B073-*
	!WORD	$0042
	!WORD	_B070-*
	!WORD	$004C
	!WORD	_B048-*
	!WORD	$004E
	!WORD	_B051-*
	!WORD	$0080
	!WORD	_B045-*
	!WORD	$0082
	!WORD	_B101-*
	!WORD	$0084
	!WORD	_B108-*
	!WORD	$0086
	!WORD	_B124-*
	!WORD	$0088
	!WORD	_B134-*
	!WORD	$0090
	!WORD	_B043-*
	!WORD	$0092
	!WORD	_B044-*
	!WORD	$0094
	!WORD	_B115-*
	!WORD	$0096
	!WORD	_B119-*
	!WORD	$00A0
	!WORD	_B054-*
	!WORD	$00A2
	!WORD	_B059-*
	!WORD	$00AC
	!WORD	_B067-*
	!WORD	$00AE
	!WORD	_B064-*
_B041 
; toolsrc/codeopt.pla: 0305:                 break // CONST_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0306:             is LADDR_CODE
_B140 
; toolsrc/codeopt.pla: 0307:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B142-*
; toolsrc/codeopt.pla: 0308:                     is CONST_CODE
_B143 
; toolsrc/codeopt.pla: 0309:                         if nextop=>opnext
; toolsrc/codeopt.pla: 0310:                             nextopnext = nextop=>opnext
; toolsrc/codeopt.pla: 0311:                             when nextopnext->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B144
	!WORD	_B144-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B147-*
; toolsrc/codeopt.pla: 0312:                                 is ADD_CODE // INDEXB_CODE
_B148 
; toolsrc/codeopt.pla: 0313:                                     op=>opoffset = op=>opoffset + nextop=>opval
; toolsrc/codeopt.pla: 0314:                                     freeops      = 2
; toolsrc/codeopt.pla: 0315:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
; toolsrc/codeopt.pla: 0316:                                 is INDEXW_CODE
_B149 
; toolsrc/codeopt.pla: 0317:                                     op=>opoffset = op=>opoffset + nextop=>opval * 2
; toolsrc/codeopt.pla: 0318:                                     freeops      = 2
; toolsrc/codeopt.pla: 0319:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
; toolsrc/codeopt.pla: 0320:                             wend
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
_B147 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0082
	!WORD	_B148-*
	!WORD	$009E
	!WORD	_B149-*
_B146 
; toolsrc/codeopt.pla: 0321:                         fin
_B144 
_B145 
; toolsrc/codeopt.pla: 0322:                         break
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
; toolsrc/codeopt.pla: 0323:                     is LB_CODE
_B150 
; toolsrc/codeopt.pla: 0324:                         op->opcode = LLB_CODE
; toolsrc/codeopt.pla: 0325:                         freeops    = 1
; toolsrc/codeopt.pla: 0326:                         break
	!BYTE	$2A,$64			; CB	100
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
; toolsrc/codeopt.pla: 0327:                     is LW_CODE
_B151 
; toolsrc/codeopt.pla: 0328:                         op->opcode = LLW_CODE
; toolsrc/codeopt.pla: 0329:                         freeops    = 1
; toolsrc/codeopt.pla: 0330:                         break
	!BYTE	$2A,$66			; CB	102
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
; toolsrc/codeopt.pla: 0331:                     is SB_CODE
_B152 
; toolsrc/codeopt.pla: 0332:                         op->opcode = SLB_CODE
; toolsrc/codeopt.pla: 0333:                         freeops    = 1
; toolsrc/codeopt.pla: 0334:                         break
	!BYTE	$2A,$74			; CB	116
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
; toolsrc/codeopt.pla: 0335:                     is SW_CODE
_B153 
; toolsrc/codeopt.pla: 0336:                         op->opcode = SLW_CODE
; toolsrc/codeopt.pla: 0337:                         freeops    = 1
; toolsrc/codeopt.pla: 0338:                         break
	!BYTE	$2A,$76			; CB	118
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
; toolsrc/codeopt.pla: 0339:                 wend
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
_B142 
	!BYTE	$05			; CASEBLOCK
	!WORD	$002C
	!WORD	_B143-*
	!WORD	$0060
	!WORD	_B150-*
	!WORD	$0062
	!WORD	_B151-*
	!WORD	$0070
	!WORD	_B152-*
	!WORD	$0072
	!WORD	_B153-*
_B141 
; toolsrc/codeopt.pla: 0340:                 if pass > 0 and not freeops
; toolsrc/codeopt.pla: 0341:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0342:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B154
	!WORD	_B154-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
_B154 
	!BYTE	$4C			; BRFLS	_B155
	!WORD	_B155-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F003 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B155 
_B156 
; toolsrc/codeopt.pla: 0343:                 break // LADDR_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0344:             is GADDR_CODE
_B157 
; toolsrc/codeopt.pla: 0345:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B159-*
; toolsrc/codeopt.pla: 0346:                     is CONST_CODE
_B160 
; toolsrc/codeopt.pla: 0347:                         if nextop=>opnext
; toolsrc/codeopt.pla: 0348:                             nextopnext = nextop=>opnext
; toolsrc/codeopt.pla: 0349:                             when nextopnext->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B161
	!WORD	_B161-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B164-*
; toolsrc/codeopt.pla: 0350:                                 is ADD_CODE // INDEXB_CODE
_B165 
; toolsrc/codeopt.pla: 0351:                                     op=>opoffset = op=>opoffset + nextop=>opval
; toolsrc/codeopt.pla: 0352:                                     freeops      = 2
; toolsrc/codeopt.pla: 0353:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B163
	!WORD	_B163-*
; toolsrc/codeopt.pla: 0354:                                 is INDEXW_CODE
_B166 
; toolsrc/codeopt.pla: 0355:                                     op=>opoffset = op=>opoffset + nextop=>opval * 2
; toolsrc/codeopt.pla: 0356:                                     freeops      = 2
; toolsrc/codeopt.pla: 0357:                                     break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B163
	!WORD	_B163-*
; toolsrc/codeopt.pla: 0358:                             wend
	!BYTE	$50			; BRNCH	_B163
	!WORD	_B163-*
_B164 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0082
	!WORD	_B165-*
	!WORD	$009E
	!WORD	_B166-*
_B163 
; toolsrc/codeopt.pla: 0359:                         fin
_B161 
_B162 
; toolsrc/codeopt.pla: 0360:                         break
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0361:                     is LB_CODE
_B167 
; toolsrc/codeopt.pla: 0362:                         op->opcode = LAB_CODE
; toolsrc/codeopt.pla: 0363:                         freeops    = 1
; toolsrc/codeopt.pla: 0364:                         break
	!BYTE	$2A,$68			; CB	104
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0365:                     is LW_CODE
_B168 
; toolsrc/codeopt.pla: 0366:                         op->opcode = LAW_CODE
; toolsrc/codeopt.pla: 0367:                         freeops    = 1
; toolsrc/codeopt.pla: 0368:                         break
	!BYTE	$2A,$6A			; CB	106
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0369:                     is SB_CODE
_B169 
; toolsrc/codeopt.pla: 0370:                         op->opcode = SAB_CODE
; toolsrc/codeopt.pla: 0371:                         freeops    = 1
; toolsrc/codeopt.pla: 0372:                         break
	!BYTE	$2A,$78			; CB	120
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0373:                     is SW_CODE
_B170 
; toolsrc/codeopt.pla: 0374:                         op->opcode = SAW_CODE
; toolsrc/codeopt.pla: 0375:                         freeops    = 1
; toolsrc/codeopt.pla: 0376:                         break
	!BYTE	$2A,$7A			; CB	122
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0377:                     is ICAL_CODE
_B171 
; toolsrc/codeopt.pla: 0378:                         op->opcode = CALL_CODE
; toolsrc/codeopt.pla: 0379:                         freeops    = 1
; toolsrc/codeopt.pla: 0380:                         break
	!BYTE	$2A,$54			; CB	84
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; toolsrc/codeopt.pla: 0381:                 wend
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
_B159 
	!BYTE	$06			; CASEBLOCK
	!WORD	$002C
	!WORD	_B160-*
	!WORD	$0056
	!WORD	_B171-*
	!WORD	$0060
	!WORD	_B167-*
	!WORD	$0062
	!WORD	_B168-*
	!WORD	$0070
	!WORD	_B169-*
	!WORD	$0072
	!WORD	_B170-*
_B158 
; toolsrc/codeopt.pla: 0382:                 if pass and not freeops
; toolsrc/codeopt.pla: 0383:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0384:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B172
	!WORD	_B172-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
_B172 
	!BYTE	$4C			; BRFLS	_B173
	!WORD	_B173-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F004 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B173 
_B174 
; toolsrc/codeopt.pla: 0385:                 break // GADDR_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0386:             is LLB_CODE
_B175 
; toolsrc/codeopt.pla: 0387:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B177-*
; toolsrc/codeopt.pla: 0388:                     is ADD_CODE // INDEXB_CODE
_B178 
; toolsrc/codeopt.pla: 0389:                         op->opcode = ADDLB_CODE
; toolsrc/codeopt.pla: 0390:                         freeops    = 1
; toolsrc/codeopt.pla: 0391:                         break
	!BYTE	$2A,$B0			; CB	176
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B176
	!WORD	_B176-*
; toolsrc/codeopt.pla: 0392:                     is INDEXW_CODE
_B179 
; toolsrc/codeopt.pla: 0393:                         op->opcode = IDXLB_CODE
; toolsrc/codeopt.pla: 0394:                         freeops    = 1
; toolsrc/codeopt.pla: 0395:                         break
	!BYTE	$2A,$B8			; CB	184
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B176
	!WORD	_B176-*
; toolsrc/codeopt.pla: 0396:                 wend
	!BYTE	$50			; BRNCH	_B176
	!WORD	_B176-*
_B177 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0082
	!WORD	_B178-*
	!WORD	$009E
	!WORD	_B179-*
_B176 
; toolsrc/codeopt.pla: 0397:                 if pass and not freeops
; toolsrc/codeopt.pla: 0398:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0399:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B180
	!WORD	_B180-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
_B180 
	!BYTE	$4C			; BRFLS	_B181
	!WORD	_B181-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F005 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B181 
_B182 
; toolsrc/codeopt.pla: 0400:                 break // LLB_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0401:             is LLW_CODE
_B183 
; toolsrc/codeopt.pla: 0402:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B185-*
; toolsrc/codeopt.pla: 0403:                     is ADD_CODE // INDEXB_CODE
_B186 
; toolsrc/codeopt.pla: 0404:                         op->opcode = ADDLW_CODE
; toolsrc/codeopt.pla: 0405:                         freeops    = 1
; toolsrc/codeopt.pla: 0406:                         break
	!BYTE	$2A,$B2			; CB	178
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
; toolsrc/codeopt.pla: 0407:                     is INDEXW_CODE
_B187 
; toolsrc/codeopt.pla: 0408:                         op->opcode = IDXLW_CODE
; toolsrc/codeopt.pla: 0409:                         freeops    = 1
; toolsrc/codeopt.pla: 0410:                         break
	!BYTE	$2A,$BA			; CB	186
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
; toolsrc/codeopt.pla: 0411:                     is CONST_CODE
_B188 
; toolsrc/codeopt.pla: 0412:                         // LLW [n]:CB 8:SHR -> LLB [n+1]
; toolsrc/codeopt.pla: 0413:                         if nextop=>opval == 8 and nextop=>opnext
; toolsrc/codeopt.pla: 0414:                             nextopnext = nextop=>opnext
; toolsrc/codeopt.pla: 0415:                             if nextopnext->opcode == SHR_CODE
; toolsrc/codeopt.pla: 0416:                                 op->opcode = LLB_CODE
; toolsrc/codeopt.pla: 0417:                                 op=>opoffset++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$10			; CN	8
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B189
	!WORD	_B189-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
_B189 
	!BYTE	$4C			; BRFLS	_B190
	!WORD	_B190-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$9C			; CB	156
	!BYTE	$24			; BRNE	_B192
	!WORD	_B192-*
	!BYTE	$2A,$64			; CB	100
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
; toolsrc/codeopt.pla: 0418:                                 freeops = 2
; toolsrc/codeopt.pla: 0419:                                 break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
; toolsrc/codeopt.pla: 0420:                             fin
_B192 
_B193 
; toolsrc/codeopt.pla: 0421:                         fin
_B190 
_B191 
; toolsrc/codeopt.pla: 0422:                         break
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
; toolsrc/codeopt.pla: 0423:                 wend
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
_B185 
	!BYTE	$03			; CASEBLOCK
	!WORD	$002C
	!WORD	_B188-*
	!WORD	$0082
	!WORD	_B186-*
	!WORD	$009E
	!WORD	_B187-*
_B184 
; toolsrc/codeopt.pla: 0424:                 if pass and not freeops
; toolsrc/codeopt.pla: 0425:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0426:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B194
	!WORD	_B194-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
_B194 
	!BYTE	$4C			; BRFLS	_B195
	!WORD	_B195-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F006 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B195 
_B196 
; toolsrc/codeopt.pla: 0427:                 break // LLW_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0428:             is LAB_CODE
_B197 
; toolsrc/codeopt.pla: 0429:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B199-*
; toolsrc/codeopt.pla: 0430:                     is ADD_CODE // INDEXB_CODE
_B200 
; toolsrc/codeopt.pla: 0431:                         op->opcode = ADDAB_CODE
; toolsrc/codeopt.pla: 0432:                         freeops    = 1
; toolsrc/codeopt.pla: 0433:                         break
	!BYTE	$2A,$B4			; CB	180
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B198
	!WORD	_B198-*
; toolsrc/codeopt.pla: 0434:                     is INDEXW_CODE
_B201 
; toolsrc/codeopt.pla: 0435:                         op->opcode = IDXAB_CODE
; toolsrc/codeopt.pla: 0436:                         freeops    = 1
; toolsrc/codeopt.pla: 0437:                         break
	!BYTE	$2A,$BC			; CB	188
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B198
	!WORD	_B198-*
; toolsrc/codeopt.pla: 0438:                 wend
	!BYTE	$50			; BRNCH	_B198
	!WORD	_B198-*
_B199 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0082
	!WORD	_B200-*
	!WORD	$009E
	!WORD	_B201-*
_B198 
; toolsrc/codeopt.pla: 0439:                 if pass and not freeops and not is_hardware_address(op=>opoffset)
; toolsrc/codeopt.pla: 0440:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0441:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B202
	!WORD	_B202-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B203
	!WORD	_B203-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F007 	!WORD	_C001		
	!BYTE	$80			; NOT
_B203 
_B202 
	!BYTE	$4C			; BRFLS	_B204
	!WORD	_B204-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F008 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B204 
_B205 
; toolsrc/codeopt.pla: 0442:                 break // LAB_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0443:             is LAW_CODE
_B206 
; toolsrc/codeopt.pla: 0444:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B208-*
; toolsrc/codeopt.pla: 0445:                     is ADD_CODE // INDEXB_CODE
_B209 
; toolsrc/codeopt.pla: 0446:                         op->opcode = ADDAW_CODE
; toolsrc/codeopt.pla: 0447:                         freeops    = 1
; toolsrc/codeopt.pla: 0448:                         break
	!BYTE	$2A,$B6			; CB	182
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B207
	!WORD	_B207-*
; toolsrc/codeopt.pla: 0449:                     is INDEXW_CODE
_B210 
; toolsrc/codeopt.pla: 0450:                         op->opcode = IDXAW_CODE
; toolsrc/codeopt.pla: 0451:                         freeops    = 1
; toolsrc/codeopt.pla: 0452:                         break
	!BYTE	$2A,$BE			; CB	190
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B207
	!WORD	_B207-*
; toolsrc/codeopt.pla: 0453:                     is CONST_CODE
_B211 
; toolsrc/codeopt.pla: 0454:                         // LLW [n]:CB 8:SHR -> LLB [n+1]
; toolsrc/codeopt.pla: 0455:                         if nextop=>opval == 8 and nextop=>opnext
; toolsrc/codeopt.pla: 0456:                             nextopnext = nextop=>opnext
; toolsrc/codeopt.pla: 0457:                             if nextopnext->opcode == SHR_CODE
; toolsrc/codeopt.pla: 0458:                                 op->opcode = LAB_CODE
; toolsrc/codeopt.pla: 0459:                                 op=>opoffset++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$10			; CN	8
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B212
	!WORD	_B212-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
_B212 
	!BYTE	$4C			; BRFLS	_B213
	!WORD	_B213-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$9C			; CB	156
	!BYTE	$24			; BRNE	_B215
	!WORD	_B215-*
	!BYTE	$2A,$68			; CB	104
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
; toolsrc/codeopt.pla: 0460:                                 freeops = 2
; toolsrc/codeopt.pla: 0461:                                 break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B207
	!WORD	_B207-*
; toolsrc/codeopt.pla: 0462:                             fin
_B215 
_B216 
; toolsrc/codeopt.pla: 0463:                         fin
_B213 
_B214 
; toolsrc/codeopt.pla: 0464:                         break
	!BYTE	$50			; BRNCH	_B207
	!WORD	_B207-*
; toolsrc/codeopt.pla: 0465:                 wend
	!BYTE	$50			; BRNCH	_B207
	!WORD	_B207-*
_B208 
	!BYTE	$03			; CASEBLOCK
	!WORD	$002C
	!WORD	_B211-*
	!WORD	$0082
	!WORD	_B209-*
	!WORD	$009E
	!WORD	_B210-*
_B207 
; toolsrc/codeopt.pla: 0466:                 if pass and not freeops and not is_hardware_address(op=>opoffset)
; toolsrc/codeopt.pla: 0467:                     crunched = try_dupify(op)
; toolsrc/codeopt.pla: 0468:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B217
	!WORD	_B217-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B218
	!WORD	_B218-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F009 	!WORD	_C001		
	!BYTE	$80			; NOT
_B218 
_B217 
	!BYTE	$4C			; BRFLS	_B219
	!WORD	_B219-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C000
_F010 	!WORD	_C000		
	!BYTE	$74,$0E			; SLB	[14]
_B219 
_B220 
; toolsrc/codeopt.pla: 0469:                 break // LAW_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0470:             is LOGIC_NOT_CODE
_B221 
; toolsrc/codeopt.pla: 0471:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B223-*
; toolsrc/codeopt.pla: 0472:                     is BRFALSE_CODE
_B224 
; toolsrc/codeopt.pla: 0473:                         op->opcode  = BRTRUE_CODE
; toolsrc/codeopt.pla: 0474:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0475:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0476:                         freeops     = 1
; toolsrc/codeopt.pla: 0477:                         break
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B222
	!WORD	_B222-*
; toolsrc/codeopt.pla: 0478:                     is BRTRUE_CODE
_B225 
; toolsrc/codeopt.pla: 0479:                         op->opcode  = BRFALSE_CODE
; toolsrc/codeopt.pla: 0480:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0481:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0482:                         freeops     = 1
; toolsrc/codeopt.pla: 0483:                         break
	!BYTE	$2A,$4C			; CB	76
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B222
	!WORD	_B222-*
; toolsrc/codeopt.pla: 0484:                 wend
	!BYTE	$50			; BRNCH	_B222
	!WORD	_B222-*
_B223 
	!BYTE	$02			; CASEBLOCK
	!WORD	$004C
	!WORD	_B224-*
	!WORD	$004E
	!WORD	_B225-*
_B222 
; toolsrc/codeopt.pla: 0485:                 break // LOGIC_NOT_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0486:             is EQ_CODE
_B226 
; toolsrc/codeopt.pla: 0487:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B228-*
; toolsrc/codeopt.pla: 0488:                     is BRFALSE_CODE
_B229 
; toolsrc/codeopt.pla: 0489:                         op->opcode  = BRNE_CODE
; toolsrc/codeopt.pla: 0490:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0491:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0492:                         freeops     = 1
; toolsrc/codeopt.pla: 0493:                         break
	!BYTE	$2A,$24			; CB	36
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B227
	!WORD	_B227-*
; toolsrc/codeopt.pla: 0494:                     is BRTRUE_CODE
_B230 
; toolsrc/codeopt.pla: 0495:                         op->opcode  = BREQ_CODE
; toolsrc/codeopt.pla: 0496:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0497:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0498:                         freeops     = 1
; toolsrc/codeopt.pla: 0499:                         break
	!BYTE	$2A,$22			; CB	34
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B227
	!WORD	_B227-*
; toolsrc/codeopt.pla: 0500:                 wend
	!BYTE	$50			; BRNCH	_B227
	!WORD	_B227-*
_B228 
	!BYTE	$02			; CASEBLOCK
	!WORD	$004C
	!WORD	_B229-*
	!WORD	$004E
	!WORD	_B230-*
_B227 
; toolsrc/codeopt.pla: 0501:                 break // EQ_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0502:             is NE_CODE
_B231 
; toolsrc/codeopt.pla: 0503:                 when nextop->opcode
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B233-*
; toolsrc/codeopt.pla: 0504:                     is BRFALSE_CODE
_B234 
; toolsrc/codeopt.pla: 0505:                         op->opcode  = BREQ_CODE
; toolsrc/codeopt.pla: 0506:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0507:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0508:                         freeops     = 1
; toolsrc/codeopt.pla: 0509:                         break
	!BYTE	$2A,$22			; CB	34
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B232
	!WORD	_B232-*
; toolsrc/codeopt.pla: 0510:                     is BRTRUE_CODE
_B235 
; toolsrc/codeopt.pla: 0511:                         op->opcode  = BRNE_CODE
; toolsrc/codeopt.pla: 0512:                         op->opgroup = RELATIVE_GROUP
; toolsrc/codeopt.pla: 0513:                         op=>optag   = nextop=>optag
; toolsrc/codeopt.pla: 0514:                         freeops     = 1
; toolsrc/codeopt.pla: 0515:                         break
	!BYTE	$2A,$24			; CB	36
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$50			; BRNCH	_B232
	!WORD	_B232-*
; toolsrc/codeopt.pla: 0516:                 wend
	!BYTE	$50			; BRNCH	_B232
	!WORD	_B232-*
_B233 
	!BYTE	$02			; CASEBLOCK
	!WORD	$004C
	!WORD	_B234-*
	!WORD	$004E
	!WORD	_B235-*
_B232 
; toolsrc/codeopt.pla: 0517:                 break // NE_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0518:             is SLB_CODE
_B236 
; toolsrc/codeopt.pla: 0519:                 if nextop->opcode == LLB_CODE and op=>opoffset == nextop=>opoffset
; toolsrc/codeopt.pla: 0520:                     op->opcode = DLB_CODE
; toolsrc/codeopt.pla: 0521:                     freeops    = 1
; toolsrc/codeopt.pla: 0522:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$64			; CB	100
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B237
	!WORD	_B237-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B237 
	!BYTE	$4C			; BRFLS	_B238
	!WORD	_B238-*
	!BYTE	$2A,$6C			; CB	108
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B238 
_B239 
; toolsrc/codeopt.pla: 0523:                 break // SLB_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0524:             is SLW_CODE
_B240 
; toolsrc/codeopt.pla: 0525:                 if nextop->opcode == LLW_CODE and op=>opoffset == nextop=>opoffset
; toolsrc/codeopt.pla: 0526:                     op->opcode = DLW_CODE
; toolsrc/codeopt.pla: 0527:                     freeops    = 1
; toolsrc/codeopt.pla: 0528:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$66			; CB	102
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B241
	!WORD	_B241-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B241 
	!BYTE	$4C			; BRFLS	_B242
	!WORD	_B242-*
	!BYTE	$2A,$6E			; CB	110
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B242 
_B243 
; toolsrc/codeopt.pla: 0529:                 break // SLW_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0530:             is SAB_CODE
_B244 
; toolsrc/codeopt.pla: 0531:                 if nextop->opcode == LAB_CODE and op=>optag == nextop=>optag and op=>opoffset == nextop=>opoffset
; toolsrc/codeopt.pla: 0532:                     op->opcode = DAB_CODE
; toolsrc/codeopt.pla: 0533:                     freeops    = 1
; toolsrc/codeopt.pla: 0534:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$68			; CB	104
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B245
	!WORD	_B245-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B246
	!WORD	_B246-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B246 
_B245 
	!BYTE	$4C			; BRFLS	_B247
	!WORD	_B247-*
	!BYTE	$2A,$7C			; CB	124
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B247 
_B248 
; toolsrc/codeopt.pla: 0535:                 break // SAB_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0536:             is SAW_CODE
_B249 
; toolsrc/codeopt.pla: 0537:                 if nextop->opcode == LAW_CODE and op=>optag == nextop=>optag and op=>opoffset == nextop=>opoffset
; toolsrc/codeopt.pla: 0538:                     op->opcode = DAW_CODE
; toolsrc/codeopt.pla: 0539:                     freeops    = 1
; toolsrc/codeopt.pla: 0540:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$6A			; CB	106
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B250
	!WORD	_B250-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B251
	!WORD	_B251-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B251 
_B250 
	!BYTE	$4C			; BRFLS	_B252
	!WORD	_B252-*
	!BYTE	$2A,$7E			; CB	126
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$76,$0C			; SLW	[12]
_B252 
_B253 
; toolsrc/codeopt.pla: 0541:                 break // SAW_CODE
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/codeopt.pla: 0542:         wend
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
_B028 
	!BYTE	$0E			; CASEBLOCK
	!WORD	$0026
	!WORD	_B157-*
	!WORD	$0028
	!WORD	_B140-*
	!WORD	$002C
	!WORD	_B029-*
	!WORD	$0040
	!WORD	_B226-*
	!WORD	$0042
	!WORD	_B231-*
	!WORD	$0064
	!WORD	_B175-*
	!WORD	$0066
	!WORD	_B183-*
	!WORD	$0068
	!WORD	_B197-*
	!WORD	$006A
	!WORD	_B206-*
	!WORD	$0074
	!WORD	_B236-*
	!WORD	$0076
	!WORD	_B240-*
	!WORD	$0078
	!WORD	_B244-*
	!WORD	$007A
	!WORD	_B249-*
	!WORD	$0080
	!WORD	_B221-*
_B027 
; toolsrc/codeopt.pla: 0543:         //
; toolsrc/codeopt.pla: 0544:         // Free up crunched ops. If freeops is positive we free up that many ops
; toolsrc/codeopt.pla: 0545:         // *after* op; if it's negative, we free up abs(freeops) ops *starting
; toolsrc/codeopt.pla: 0546:         // with* op.
; toolsrc/codeopt.pla: 0547:         //
; toolsrc/codeopt.pla: 0548:         if freeops < 0
; toolsrc/codeopt.pla: 0549:             freeops = -freeops
; toolsrc/codeopt.pla: 0550:             if op == *seq
; toolsrc/codeopt.pla: 0551:                 //
; toolsrc/codeopt.pla: 0552:                 // If op is at the start of the sequence, we treat this as a special case.
; toolsrc/codeopt.pla: 0553:                 //
; toolsrc/codeopt.pla: 0554:                 while freeops
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B254
	!WORD	_B254-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$90			; NEG
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$24			; BRNE	_B256
	!WORD	_B256-*
	!BYTE	$50			; BRNCH	_B260
	!WORD	_B260-*
_B258 
; toolsrc/codeopt.pla: 0555:                     nextop     = op=>opnext
; toolsrc/codeopt.pla: 0556:                     op=>opnext = freeop_lst
; toolsrc/codeopt.pla: 0557:                     freeop_lst = op
; toolsrc/codeopt.pla: 0558:                     *seq       = nextop
; toolsrc/codeopt.pla: 0559:                     op         = nextop
; toolsrc/codeopt.pla: 0560:                     freeops--
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_X029+0
_F011 	!WORD	0+0		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$7A			; SAW	_X029+0
_F012 	!WORD	0+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$8E			; DECR
; toolsrc/codeopt.pla: 0561:                 loop
	!BYTE	$76,$0C			; SLW	[12]
_B260 
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$4E			; BRTRU	_B258
	!WORD	_B258-*
_B259 
; toolsrc/codeopt.pla: 0562:                 crunched = TRUE
; toolsrc/codeopt.pla: 0563:             else
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$50			; BRNCH	_B257
	!WORD	_B257-*
_B256 
; toolsrc/codeopt.pla: 0564:                 //
; toolsrc/codeopt.pla: 0565:                 // Otherwise we just move op back to point to the previous op and
; toolsrc/codeopt.pla: 0566:                 // let the following loop remove the required number of ops.
; toolsrc/codeopt.pla: 0567:                 //
; toolsrc/codeopt.pla: 0568:                 op      = opprev
; toolsrc/codeopt.pla: 0569:                 nextop  = op=>opnext
; toolsrc/codeopt.pla: 0570:             fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B257 
; toolsrc/codeopt.pla: 0571:         fin
_B254 
_B255 
; toolsrc/codeopt.pla: 0572:         while freeops
	!BYTE	$50			; BRNCH	_B263
	!WORD	_B263-*
_B261 
; toolsrc/codeopt.pla: 0573:             op=>opnext     = nextop=>opnext
; toolsrc/codeopt.pla: 0574:             nextop=>opnext = freeop_lst
; toolsrc/codeopt.pla: 0575:             freeop_lst     = nextop
; toolsrc/codeopt.pla: 0576:             nextop         = op=>opnext
; toolsrc/codeopt.pla: 0577:             crunched       = TRUE
; toolsrc/codeopt.pla: 0578:             freeops--
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_X029+0
_F013 	!WORD	0+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_X029+0
_F014 	!WORD	0+0		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$8E			; DECR
; toolsrc/codeopt.pla: 0579:         loop
	!BYTE	$76,$0C			; SLW	[12]
_B263 
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$4E			; BRTRU	_B261
	!WORD	_B261-*
_B262 
; toolsrc/codeopt.pla: 0580:         opprev = op
; toolsrc/codeopt.pla: 0581:         op     = nextop
; toolsrc/codeopt.pla: 0582:         nextop = op=>opnext
; toolsrc/codeopt.pla: 0583:     loop
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B025 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$AC			; BRAND	_B026
	!WORD	_B026-*
	!BYTE	$66,$04			; LLW	[4]
_B026 
	!BYTE	$4E			; BRTRU	_B023
	!WORD	_B023-*
_B024 
; toolsrc/codeopt.pla: 0584:     return crunched
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$5A,$10			; LEAVE	16
; toolsrc/codeopt.pla: 0585: end
; toolsrc/codeopt.pla: 0586: //
; toolsrc/codeopt.pla: 0587: // Point to crunch function
; toolsrc/codeopt.pla: 0588: //
; toolsrc/codeopt.pla: 0589: optimize_seq = @crunch_seq
_INIT 
; toolsrc/codeopt.pla: 0590: //
; toolsrc/codeopt.pla: 0591: // Keep this module in memory
; toolsrc/codeopt.pla: 0592: //
; toolsrc/codeopt.pla: 0593: return modkeep
	!BYTE	$26			; LA	_C002+0
_F015 	!WORD	_C002+0		
	!BYTE	$7A			; SAW	_X030+0
_F016 	!WORD	0+0		
	!BYTE	$2C,$00,$20		; CW	8192
	!BYTE	$5C			; RET
; toolsrc/codeopt.pla: 0594: done
_SYSFLAGS	=	0
_DEFCNT	=	4
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: ISUGE
	!BYTE	$C9,$D3,$D5,$C7,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	25			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: FREEOP_LST
	!BYTE	$C6,$D2,$C5,$C5,$CF,$D0,$DF,$CC,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: OPTIMIZE_SEQ
	!BYTE	$CF,$D0,$D4,$C9,$CD,$C9,$DA,$C5,$DF,$D3,$C5,$51
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	!BYTE	$00			; END OF ESD
