; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; toolsrc/ed.pla: 0001: //=====================================
; toolsrc/ed.pla: 0002: //
; toolsrc/ed.pla: 0003: //              Text Editor
; toolsrc/ed.pla: 0004: //
; toolsrc/ed.pla: 0005: //=====================================
; toolsrc/ed.pla: 0006: 
; toolsrc/ed.pla: 0007: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; toolsrc/ed.pla: 0007: 
; toolsrc/ed.pla: 0008: include "inc/args.plh"
; inc/args.plh: 0001: import args
	; DCI STRING: ARGS
	!BYTE	$C1,$D2,$C7,$53
					; ARGS -> X028
; inc/args.plh: 0002:     predef  argFirst, argNext(str)
					; ARGFIRST -> X029
					; ARGNEXT -> X030
; inc/args.plh: 0003: end
; toolsrc/ed.pla: 0008: 
; toolsrc/ed.pla: 0009: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X031
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:         word getmark
					; getmark = 36
; inc/fileio.plh: 0076:         word setmark
					; setmark = 38
; inc/fileio.plh: 0077:     end
					; t_fileio = 40
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     // Globally accessible error code
; inc/fileio.plh: 0080:     //
; inc/fileio.plh: 0081:     byte perr
					; PERR -> X032
; inc/fileio.plh: 0082: end
; toolsrc/ed.pla: 0009: 
; toolsrc/ed.pla: 0010: include "inc/conio.plh"
; inc/conio.plh: 0001: import conio
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
					; CONIO -> X033
; inc/conio.plh: 0002:     //
; inc/conio.plh: 0003:     // ASCII key values
; inc/conio.plh: 0004:     //
; inc/conio.plh: 0005:     const keyarrowdown  = $0A
					; keyarrowdown = 10
; inc/conio.plh: 0006:     const keyarrowup    = $0B
					; keyarrowup = 11
; inc/conio.plh: 0007:     const keyarrowleft  = $08
					; keyarrowleft = 8
; inc/conio.plh: 0008:     const keyarrowright = $15
					; keyarrowright = 21
; inc/conio.plh: 0009:     const keyenter      = $0D
					; keyenter = 13
; inc/conio.plh: 0010:     const keyescape     = $1B
					; keyescape = 27
; inc/conio.plh: 0011:     const keyctrla      = $01
					; keyctrla = 1
; inc/conio.plh: 0012:     const keyctrlb      = $02
					; keyctrlb = 2
; inc/conio.plh: 0013:     const keyctrlc      = $03
					; keyctrlc = 3
; inc/conio.plh: 0014:     const keyctrld      = $04
					; keyctrld = 4
; inc/conio.plh: 0015:     const keyctrle      = $05
					; keyctrle = 5
; inc/conio.plh: 0016:     const keyctrlf      = $06
					; keyctrlf = 6
; inc/conio.plh: 0017:     const keyctrlg      = $07
					; keyctrlg = 7
; inc/conio.plh: 0018:     const keyctrli      = $09
					; keyctrli = 9
; inc/conio.plh: 0019:     const keyctrlk      = $0B
					; keyctrlk = 11
; inc/conio.plh: 0020:     const keyctrll      = $0C
					; keyctrll = 12
; inc/conio.plh: 0021:     const keyctrln      = $0E
					; keyctrln = 14
; inc/conio.plh: 0022:     const keyctrlo      = $0F
					; keyctrlo = 15
; inc/conio.plh: 0023:     const keyctrlp      = $10
					; keyctrlp = 16
; inc/conio.plh: 0024:     const keyctrlq      = $11
					; keyctrlq = 17
; inc/conio.plh: 0025:     const keyctrlr      = $12
					; keyctrlr = 18
; inc/conio.plh: 0026:     const keyctrls      = $13
					; keyctrls = 19
; inc/conio.plh: 0027:     const keyctrlt      = $14
					; keyctrlt = 20
; inc/conio.plh: 0028:     const keyctrlu      = $15
					; keyctrlu = 21
; inc/conio.plh: 0029:     const keyctrlv      = $16
					; keyctrlv = 22
; inc/conio.plh: 0030:     const keyctrlw      = $17
					; keyctrlw = 23
; inc/conio.plh: 0031:     const keyctrlx      = $18
					; keyctrlx = 24
; inc/conio.plh: 0032:     const keyctrly      = $19
					; keyctrly = 25
; inc/conio.plh: 0033:     const keyctrlz      = $1A
					; keyctrlz = 26
; inc/conio.plh: 0034:     const keytab        = keyctrli
					; keytab = 9
; inc/conio.plh: 0035:     const keydetab      = $1D
					; keydetab = 29
; inc/conio.plh: 0036:     const keyspace      = $20
					; keyspace = 32
; inc/conio.plh: 0037:     const keydelete     = $7F
					; keydelete = 127
; inc/conio.plh: 0038:     //
; inc/conio.plh: 0039:     // Option/Solid-Apple key modifier
; inc/conio.plh: 0040:     //
; inc/conio.plh: 0041:     const keyoptmod     = $80
					; keyoptmod = 128
; inc/conio.plh: 0042:     //
; inc/conio.plh: 0043:     // Clear optioms
; inc/conio.plh: 0044:     //
; inc/conio.plh: 0045:     const cleol         = 1
					; cleol = 1
; inc/conio.plh: 0046:     const cleos         = 2
					; cleos = 2
; inc/conio.plh: 0047:     const cls           = 3
					; cls = 3
; inc/conio.plh: 0048:     //
; inc/conio.plh: 0049:     // Control Codes
; inc/conio.plh: 0050:     //
; inc/conio.plh: 0051:     const ctrlattr      = 1
					; ctrlattr = 1
; inc/conio.plh: 0052:     const ctrlecho      = 2
					; ctrlecho = 2
; inc/conio.plh: 0053:     const ctrlcursor    = 3
					; ctrlcursor = 3
; inc/conio.plh: 0054:     const ctrlcase      = 4
					; ctrlcase = 4
; inc/conio.plh: 0055:     const ctrlscroll    = 5
					; ctrlscroll = 5
; inc/conio.plh: 0056:     //
; inc/conio.plh: 0057:     // Control parameters
; inc/conio.plh: 0058:     //
; inc/conio.plh: 0059:     const OFF           = 0
					; OFF = 0
; inc/conio.plh: 0060:     const ON            = 1
					; ON = 1
; inc/conio.plh: 0061:     const NORMAL        = $FF
					; NORMAL = 255
; inc/conio.plh: 0062:     const INVERSE       = $3F
					; INVERSE = 63
; inc/conio.plh: 0063:     const FLASH         = $7F
					; FLASH = 127
; inc/conio.plh: 0064:     const UP            = 1
					; UP = 1
; inc/conio.plh: 0065:     const DOWN          = -1
					; DOWN = -1
; inc/conio.plh: 0066:     //
; inc/conio.plh: 0067:     // Additional modes available on VIDEX UltraTerm
; inc/conio.plh: 0068:     //
; inc/conio.plh: 0069:     const UTmode80x24   = 1
					; UTmode80x24 = 1
; inc/conio.plh: 0070:     const UTmode96x24   = 2
					; UTmode96x24 = 2
; inc/conio.plh: 0071:     const UTmode160x24  = 3
					; UTmode160x24 = 3
; inc/conio.plh: 0072:     const UTmode80x24I  = 4
					; UTmode80x24I = 4
; inc/conio.plh: 0073:     const UTmode80x32I  = 5
					; UTmode80x32I = 5
; inc/conio.plh: 0074:     const UTmode80x48I  = 6
					; UTmode80x48I = 6
; inc/conio.plh: 0075:     const UTmode132x24I = 7
					; UTmode132x24I = 7
; inc/conio.plh: 0076:     const UTmode128x32I = 8
					; UTmode128x32I = 8
; inc/conio.plh: 0077:     //
; inc/conio.plh: 0078:     // API
; inc/conio.plh: 0079:     //
; inc/conio.plh: 0080:     struc t_conio
; inc/conio.plh: 0081:         word keypressed
					; keypressed = 0
; inc/conio.plh: 0082:         word getkey
					; getkey = 2
; inc/conio.plh: 0083:         word putchars
					; putchars = 4
; inc/conio.plh: 0084:         word clear
					; clear = 6
; inc/conio.plh: 0085:         word gotoxy
					; gotoxy = 8
; inc/conio.plh: 0086:         word viewport
					; viewport = 10
; inc/conio.plh: 0087:         word textctrl
					; textctrl = 12
; inc/conio.plh: 0088:         word textmode
					; textmode = 14
; inc/conio.plh: 0089:         word grmode
					; grmode = 16
; inc/conio.plh: 0090:         word grcolor
					; grcolor = 18
; inc/conio.plh: 0091:         word grplot
					; grplot = 20
; inc/conio.plh: 0092:         word tone
					; tone = 22
; inc/conio.plh: 0093:         word rnd
					; rnd = 24
; inc/conio.plh: 0094:     end
					; t_conio = 26
; inc/conio.plh: 0095: end
; toolsrc/ed.pla: 0010: 
; toolsrc/ed.pla: 0011: include "inc/vblank.plh"
; inc/vblank.plh: 0001: import vblank
	; DCI STRING: VBLANK
	!BYTE	$D6,$C2,$CC,$C1,$CE,$4B
					; VBLANK -> X034
; inc/vblank.plh: 0002:     predef waitVBL#1
					; WAITVBL -> X035
; inc/vblank.plh: 0003: end
; toolsrc/ed.pla: 0011: 
; toolsrc/ed.pla: 0012: sysflags restxt1|resxtxt1|nojitc // Keep JITC from compiling and pausing while editing
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_SYSFLAGS	=	$0105		; SYSTEM FLAGS
; toolsrc/ed.pla: 0013: const CSW          = $36
					; CSW = 54
; toolsrc/ed.pla: 0014: //
; toolsrc/ed.pla: 0015: // Data and text buffer constants
; toolsrc/ed.pla: 0016: //
; toolsrc/ed.pla: 0017: const MAXLINES      = 999
					; MAXLINES = 999
; toolsrc/ed.pla: 0018: const MAXLINESSIZE  = MAXLINES+24
					; MAXLINESSIZE = 1023
; toolsrc/ed.pla: 0019: const MAXCLIPLINES  = 256
					; MAXCLIPLINES = 256
; toolsrc/ed.pla: 0020: const MAXLNLEN      = 127
					; MAXLNLEN = 127
; toolsrc/ed.pla: 0021: const pgjmp         = 16
					; pgjmp = 16
; toolsrc/ed.pla: 0022: const changed       = 1
					; changed = 1
; toolsrc/ed.pla: 0023: const insmode       = 2
					; insmode = 2
; toolsrc/ed.pla: 0024: const gutter        = 4     // This has to be 4 to match on-screen width
					; gutter = 4
; toolsrc/ed.pla: 0025: const selection     = 8
					; selection = 8
; toolsrc/ed.pla: 0026: const exit          = 16
					; exit = 16
; toolsrc/ed.pla: 0027: const numlock       = 128
					; numlock = 128
; toolsrc/ed.pla: 0028: //
; toolsrc/ed.pla: 0029: // Text screen dimensions
; toolsrc/ed.pla: 0030: //
; toolsrc/ed.pla: 0031: byte[] UltraTermWidth  = 80, 96, 160, 80, 80, 80, 132, 128
_D036 					; UltraTermWidth  = 80, 96, 160, 80, 80, 80, 132, 128
	!BYTE	$50
	!BYTE	$60
	!BYTE	$A0
	!BYTE	$50
	!BYTE	$50
	!BYTE	$50
	!BYTE	$84
	!BYTE	$80
; toolsrc/ed.pla: 0032: byte[] UltraTermHeight = 24, 24,  24, 24, 32, 48,  24,  32
_D037 					; UltraTermHeight = 24, 24,  24, 24, 32, 48,  24,  32
	!BYTE	$18
	!BYTE	$18
	!BYTE	$18
	!BYTE	$18
	!BYTE	$20
	!BYTE	$30
	!BYTE	$18
	!BYTE	$20
; toolsrc/ed.pla: 0033: word scrnheight     = 24
_D038 					; scrnheight     = 24
	!WORD	$0018
; toolsrc/ed.pla: 0034: byte scrnwidth      = 80
_D039 					; scrnwidth      = 80
	!BYTE	$50
; toolsrc/ed.pla: 0035: byte viewwidth
_D040 	!FILL	1			; viewwidth
; toolsrc/ed.pla: 0036: byte viewleft
_D041 	!FILL	1			; viewleft
; toolsrc/ed.pla: 0037: word viewtop
_D042 	!FILL	2			; viewtop
; toolsrc/ed.pla: 0038: //
; toolsrc/ed.pla: 0039: // Editor variables
; toolsrc/ed.pla: 0040: //
; toolsrc/ed.pla: 0041: byte nullstr       = ""
_D043 					; nullstr       = ""
	!BYTE	$00
; toolsrc/ed.pla: 0042: byte[80] findstr   = ""
_D044 					; findstr   = ""
	!BYTE	$00
	!FILL	$4F
; toolsrc/ed.pla: 0043: byte[64] filename  = "UNTITLED"
_D045 					; filename  = "UNTITLED"
	!BYTE	$08
	!BYTE	$55,$4E,$54,$49,$54,$4C,$45,$44
	!FILL	$37
; toolsrc/ed.pla: 0044: byte flags         = 0
_D046 					; flags         = 0
	!BYTE	$00
; toolsrc/ed.pla: 0045: word numlines      = 0
_D047 					; numlines      = 0
	!WORD	$0000
; toolsrc/ed.pla: 0046: word numcliplines  = 0
_D048 					; numcliplines  = 0
	!WORD	$0000
; toolsrc/ed.pla: 0047: word arg
_D049 	!FILL	2			; arg
; toolsrc/ed.pla: 0048: word strpool, strplmapsize, strpoolmap
_D050 	!FILL	2			; strpool, strplmapsize, strpoolmap
_D051 	!FILL	2			; strplmapsize, strpoolmap
_D052 	!FILL	2			; strpoolmap
; toolsrc/ed.pla: 0049: word txtlinbuf, cliplinbuf
_D053 	!FILL	2			; txtlinbuf, cliplinbuf
_D054 	!FILL	2			; cliplinbuf
; toolsrc/ed.pla: 0050: word cursx, cursy, cursrow, curscol, selrow
_D055 	!FILL	2			; cursx, cursy, cursrow, curscol, selrow
_D056 	!FILL	2			; cursy, cursrow, curscol, selrow
_D057 	!FILL	2			; cursrow, curscol, selrow
_D058 	!FILL	2			; curscol, selrow
_D059 	!FILL	2			; selrow
; toolsrc/ed.pla: 0051: word cursflash = 500 // default cursor flash delay
_D060 					; cursflash = 500 // default cursor flash delay
	!WORD	$01F4
; toolsrc/ed.pla: 0052: //
; toolsrc/ed.pla: 0053: // Predeclared functions
; toolsrc/ed.pla: 0054: //
; toolsrc/ed.pla: 0055: predef cmdmode#0
; toolsrc/ed.pla: 0056: //
; toolsrc/ed.pla: 0057: // Utility functions
; toolsrc/ed.pla: 0058: //
; toolsrc/ed.pla: 0059: // Defines for ASM routines
; toolsrc/ed.pla: 0060: //
; toolsrc/ed.pla: 0061: asm equates
_A000 					; equates()
; toolsrc/ed.pla: 0062:     !SOURCE "vmsrc/plvmzp.inc"
    !SOURCE "vmsrc/plvmzp.inc"
; toolsrc/ed.pla: 0063: end
; toolsrc/ed.pla: 0064: asm lnupcpy(dststr, srcstr)#0
_A001 					; lnupcpy()
; toolsrc/ed.pla: 0065:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0066:         STA     SRCL
        STA     SRCL
; toolsrc/ed.pla: 0067:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0068:         STA     SRCH
        STA     SRCH
; toolsrc/ed.pla: 0069:         INX
        INX
; toolsrc/ed.pla: 0070:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0071:         STA     DSTL
        STA     DSTL
; toolsrc/ed.pla: 0072:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0073:         STA     DSTH
        STA     DSTH
; toolsrc/ed.pla: 0074:         INX
        INX
; toolsrc/ed.pla: 0075:         LDY     #$00
        LDY     #$00
; toolsrc/ed.pla: 0076:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/ed.pla: 0077:         CMP     #80
        CMP     #80
; toolsrc/ed.pla: 0078:         BCC     +
        BCC     +
; toolsrc/ed.pla: 0079:         LDA     #79
        LDA     #79
; toolsrc/ed.pla: 0080: +       STA     (DST),Y
+       STA     (DST),Y
; toolsrc/ed.pla: 0081:         TAY
        TAY
; toolsrc/ed.pla: 0082:         BEQ     +++
        BEQ     +++
; toolsrc/ed.pla: 0083: CPUPLP  LDA     (SRC),Y
CPUPLP  LDA     (SRC),Y
; toolsrc/ed.pla: 0084:         CMP     #$20
        CMP     #$20
; toolsrc/ed.pla: 0085:         BCS     +
        BCS     +
; toolsrc/ed.pla: 0086:         ADC     #$60
        ADC     #$60
; toolsrc/ed.pla: 0087: +       AND     #$7F
+       AND     #$7F
; toolsrc/ed.pla: 0088:         CMP     #$7B
        CMP     #$7B
; toolsrc/ed.pla: 0089:         BCS     ++
        BCS     ++
; toolsrc/ed.pla: 0090:         CMP     #$61
        CMP     #$61
; toolsrc/ed.pla: 0091:         BCC     ++
        BCC     ++
; toolsrc/ed.pla: 0092:         SEC
        SEC
; toolsrc/ed.pla: 0093:         SBC     #$20
        SBC     #$20
; toolsrc/ed.pla: 0094: ++      STA     (DST),Y
++      STA     (DST),Y
; toolsrc/ed.pla: 0095:         DEY
        DEY
; toolsrc/ed.pla: 0096:         BNE     CPUPLP
        BNE     CPUPLP
; toolsrc/ed.pla: 0097: +++     RTS
+++     RTS
; toolsrc/ed.pla: 0098: end
; toolsrc/ed.pla: 0099: //def sizemask(size)
; toolsrc/ed.pla: 0100: //    if size <= 80
; toolsrc/ed.pla: 0101: //        return sizetomask[(size - 1) >> 4]
; toolsrc/ed.pla: 0102: //    fin
; toolsrc/ed.pla: 0103: //    if size <= 16
; toolsrc/ed.pla: 0104: //        return $01
; toolsrc/ed.pla: 0105: //    elsif size <= 32
; toolsrc/ed.pla: 0106: //        return $03
; toolsrc/ed.pla: 0107: //    elsif size <= 48
; toolsrc/ed.pla: 0108: //        return $07
; toolsrc/ed.pla: 0109: //    elsif size <= 64
; toolsrc/ed.pla: 0110: //        return $0F
; toolsrc/ed.pla: 0111: //    elsif size <= 80
; toolsrc/ed.pla: 0112: //        return $1F
; toolsrc/ed.pla: 0113: //    fin
; toolsrc/ed.pla: 0114: //    return 0
; toolsrc/ed.pla: 0115: //end
; toolsrc/ed.pla: 0116: asm sizemask(size)#1
_A002 					; sizemask()
; toolsrc/ed.pla: 0117:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0118:         CMP     #129        ; 81
        CMP     #129        ; 81
; toolsrc/ed.pla: 0119:         BCS     ++
        BCS     ++
; toolsrc/ed.pla: 0120:         ADC     #$0F
        ADC     #$0F
; toolsrc/ed.pla: 0121:         LSR
        LSR
; toolsrc/ed.pla: 0122:         LSR
        LSR
; toolsrc/ed.pla: 0123:         LSR
        LSR
; toolsrc/ed.pla: 0124:         LSR
        LSR
; toolsrc/ed.pla: 0125:         TAY
        TAY
; toolsrc/ed.pla: 0126:         LDA     #$FF
        LDA     #$FF
; toolsrc/ed.pla: 0127: -       ASL
-       ASL
; toolsrc/ed.pla: 0128:         DEY
        DEY
; toolsrc/ed.pla: 0129:         BNE     -
        BNE     -
; toolsrc/ed.pla: 0130:         EOR     #$FF
        EOR     #$FF
; toolsrc/ed.pla: 0131:         STA     ESTKL,X
        STA     ESTKL,X
; toolsrc/ed.pla: 0132:         LDA     #$00
        LDA     #$00
; toolsrc/ed.pla: 0133:         STA     ESTKH,X
        STA     ESTKH,X
; toolsrc/ed.pla: 0134:         RTS
        RTS
; toolsrc/ed.pla: 0135: --      DEY                     ; THIS IS NEXT MAP BYTE FROM BELOW
--      DEY                     ; THIS IS NEXT MAP BYTE FROM BELOW
; toolsrc/ed.pla: 0136:         CPY     #$FF
        CPY     #$FF
; toolsrc/ed.pla: 0137:         BNE     +
        BNE     +
; toolsrc/ed.pla: 0138:         DEC     DSTH
        DEC     DSTH
; toolsrc/ed.pla: 0139:         DEC     ESTKH+1,X
        DEC     ESTKH+1,X
; toolsrc/ed.pla: 0140:         LDA     ESTKH+1,X
        LDA     ESTKH+1,X
; toolsrc/ed.pla: 0141:         CMP     #$FF
        CMP     #$FF
; toolsrc/ed.pla: 0142:         BNE     +
        BNE     +
; toolsrc/ed.pla: 0143:         INX
        INX
; toolsrc/ed.pla: 0144:         INX
        INX
; toolsrc/ed.pla: 0145:         INX
        INX
; toolsrc/ed.pla: 0146: ++      LDA     #$00
++      LDA     #$00
; toolsrc/ed.pla: 0147:         STA     ESTKL,X
        STA     ESTKL,X
; toolsrc/ed.pla: 0148:         STA     ESTKH,X
        STA     ESTKH,X
; toolsrc/ed.pla: 0149:         RTS
        RTS
; toolsrc/ed.pla: 0150: end
; toolsrc/ed.pla: 0151: //def strpoolalloc(size)
; toolsrc/ed.pla: 0152: //    szmask = sizemask(size)
; toolsrc/ed.pla: 0153: //    for i = strplmapsize - 1 downto 0
; toolsrc/ed.pla: 0154: //        if  ^(strpoolmap + i) <> $FF
; toolsrc/ed.pla: 0155: //            mapmask = szmask
; toolsrc/ed.pla: 0156: //            ofst    = 0
; toolsrc/ed.pla: 0157: //            repeat // Look for memory hole to fit
; toolsrc/ed.pla: 0158: //                if ^(strpoolmap + i) & mapmask // Nope, shift over
; toolsrc/ed.pla: 0159: //                    mapmask = mapmask << 1
; toolsrc/ed.pla: 0160: //                    ofst++
; toolsrc/ed.pla: 0161: //                else // Yep, take it
; toolsrc/ed.pla: 0162: //                    ^(strpoolmap + i) = ^(strpoolmap + i) | mapmask
; toolsrc/ed.pla: 0163: //                    return (ofst << 4) + (i << 7) + strpool
; toolsrc/ed.pla: 0164: //                fin
; toolsrc/ed.pla: 0165: //            until mapmask & $100 // No fit
; toolsrc/ed.pla: 0166: //        fin
; toolsrc/ed.pla: 0167: //    next
; toolsrc/ed.pla: 0168: //    return 0
; toolsrc/ed.pla: 0169: //end
; toolsrc/ed.pla: 0170: asm poolalloc(poolbase, mapbase, idx, mask)#1
_A003 					; poolalloc()
; toolsrc/ed.pla: 0171:         LDA     ESTKL+2,X       ; MAPBASEL
        LDA     ESTKL+2,X       ; MAPBASEL
; toolsrc/ed.pla: 0172:         STA     DSTL
        STA     DSTL
; toolsrc/ed.pla: 0173:         LDA     ESTKH+2,X       ; MAPBASEH
        LDA     ESTKH+2,X       ; MAPBASEH
; toolsrc/ed.pla: 0174:         CLC
        CLC
; toolsrc/ed.pla: 0175:         ADC     ESTKH+1,X       ; IDXH
        ADC     ESTKH+1,X       ; IDXH
; toolsrc/ed.pla: 0176:         STA     DSTH
        STA     DSTH
; toolsrc/ed.pla: 0177:         LDY     ESTKL+1,X       ; IDXL
        LDY     ESTKL+1,X       ; IDXL
; toolsrc/ed.pla: 0178: +       LDA     (DST),Y
+       LDA     (DST),Y
; toolsrc/ed.pla: 0179:         CMP     #$FF
        CMP     #$FF
; toolsrc/ed.pla: 0180:         BEQ     --              ; MAP BYTE FULL, TRY NEXT
        BEQ     --              ; MAP BYTE FULL, TRY NEXT
; toolsrc/ed.pla: 0181:         LDA     #$00
        LDA     #$00
; toolsrc/ed.pla: 0182:         STA     TMP             ; OFST
        STA     TMP             ; OFST
; toolsrc/ed.pla: 0183:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0184:         STA     ESTKH,X
        STA     ESTKH,X
; toolsrc/ed.pla: 0185: -       AND     (DST),Y
-       AND     (DST),Y
; toolsrc/ed.pla: 0186:         BEQ     ++
        BEQ     ++
; toolsrc/ed.pla: 0187:         INC     TMP             ; OFST++
        INC     TMP             ; OFST++
; toolsrc/ed.pla: 0188:         ASL     ESTKH,X         ; MASK <<= 1
        ASL     ESTKH,X         ; MASK <<= 1
; toolsrc/ed.pla: 0189:         BCS     --              ; NO FIT, TRY NEXT MAP BYTE
        BCS     --              ; NO FIT, TRY NEXT MAP BYTE
; toolsrc/ed.pla: 0190:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0191:         BCC     -
        BCC     -
; toolsrc/ed.pla: 0192: ++      LDA     ESTKH,X         ; UPDATE MAPMASK
++      LDA     ESTKH,X         ; UPDATE MAPMASK
; toolsrc/ed.pla: 0193:         ORA     (DST),Y
        ORA     (DST),Y
; toolsrc/ed.pla: 0194:         STA     (DST),Y
        STA     (DST),Y
; toolsrc/ed.pla: 0195:         LDA     TMP             ; OFST
        LDA     TMP             ; OFST
; toolsrc/ed.pla: 0196:         ASL
        ASL
; toolsrc/ed.pla: 0197:         ASL
        ASL
; toolsrc/ed.pla: 0198:         ASL
        ASL
; toolsrc/ed.pla: 0199:         ASL
        ASL
; toolsrc/ed.pla: 0200:         ;CLC
        ;CLC
; toolsrc/ed.pla: 0201:         ADC     ESTKL+3,X       ; + OFST << 4
        ADC     ESTKL+3,X       ; + OFST << 4
; toolsrc/ed.pla: 0202:         STA     ESTKL+3,X
        STA     ESTKL+3,X
; toolsrc/ed.pla: 0203:         BCC     +
        BCC     +
; toolsrc/ed.pla: 0204:         INC     ESTKH+3,X
        INC     ESTKH+3,X
; toolsrc/ed.pla: 0205: +       TYA
+       TYA
; toolsrc/ed.pla: 0206:         LSR     ESTKH+1,X
        LSR     ESTKH+1,X
; toolsrc/ed.pla: 0207:         ROR
        ROR
; toolsrc/ed.pla: 0208:         TAY
        TAY
; toolsrc/ed.pla: 0209:         LDA     #$00
        LDA     #$00
; toolsrc/ed.pla: 0210:         ROR
        ROR
; toolsrc/ed.pla: 0211:         ;CLC
        ;CLC
; toolsrc/ed.pla: 0212:         ADC     ESTKL+3,X       ; + IDX << 7
        ADC     ESTKL+3,X       ; + IDX << 7
; toolsrc/ed.pla: 0213:         STA     ESTKL+3,X
        STA     ESTKL+3,X
; toolsrc/ed.pla: 0214:         TYA
        TYA
; toolsrc/ed.pla: 0215:         ADC     ESTKH+3,X
        ADC     ESTKH+3,X
; toolsrc/ed.pla: 0216:         STA     ESTKH+3,X
        STA     ESTKH+3,X
; toolsrc/ed.pla: 0217:         INX
        INX
; toolsrc/ed.pla: 0218:         INX
        INX
; toolsrc/ed.pla: 0219:         INX
        INX
; toolsrc/ed.pla: 0220:         RTS
        RTS
; toolsrc/ed.pla: 0221: end
; toolsrc/ed.pla: 0222: def bell#0
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
_C000 					; bell()
; toolsrc/ed.pla: 0223:     putc($07)
; toolsrc/ed.pla: 0224: end
	!BYTE	$0E			; CN	7
	!BYTE	$54			; CALL	_X002
_F000 	!WORD	0		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0225: //
; toolsrc/ed.pla: 0226: // Memory management routines
; toolsrc/ed.pla: 0227: //
; toolsrc/ed.pla: 0228: def striplead(strptr, chr)#0
					; strptr -> [0]
					; chr -> [2]
_C001 					; striplead()
; toolsrc/ed.pla: 0229:     byte striplen
					; striplen -> [4]
; toolsrc/ed.pla: 0230: 
; toolsrc/ed.pla: 0231:     for striplen = 1 to ^strptr
	!BYTE	$58,$05,$02		; ENTER	5,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B001
	!WORD	_B001-*
_B002 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0232:         if ^(strptr + striplen) <> chr
; toolsrc/ed.pla: 0233:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$22			; BREQ	_B004
	!WORD	_B004-*
	!BYTE	$50			; BRNCH	_B001
	!WORD	_B001-*
; toolsrc/ed.pla: 0234:         fin
_B004 
_B005 
; toolsrc/ed.pla: 0235:     next
_B003 
	!BYTE	$A4			; INCBRLE	_B002
	!WORD	_B002-*
_B001 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0236:     if striplen > 1
; toolsrc/ed.pla: 0237:         ^strptr = ^strptr - (striplen - 1)
; toolsrc/ed.pla: 0238:         memcpy(strptr + 1, strptr + striplen, ^strptr)
; toolsrc/ed.pla: 0239:     fin
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
	!BYTE	$84			; SUB 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F001 	!WORD	0		
_B006 
_B007 
; toolsrc/ed.pla: 0240: end
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0241: def strstripcpy(dststr, srcstr)#0
					; dststr -> [0]
					; srcstr -> [2]
_C002 					; strstripcpy()
; toolsrc/ed.pla: 0242:     byte strlen
					; strlen -> [4]
; toolsrc/ed.pla: 0243: 
; toolsrc/ed.pla: 0244:     memcpy(dststr, srcstr, ^srcstr + 1)
	!BYTE	$58,$05,$02		; ENTER	5,2
; toolsrc/ed.pla: 0245:     for strlen = ^dststr downto 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F002 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$A2			; BRLT	_B008
	!WORD	_B008-*
_B009 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0246:         if ^(dststr + strlen) > keyspace
; toolsrc/ed.pla: 0247:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B011
	!WORD	_B011-*
	!BYTE	$50			; BRNCH	_B008
	!WORD	_B008-*
; toolsrc/ed.pla: 0248:         fin
_B011 
_B012 
; toolsrc/ed.pla: 0249:     next
_B010 
	!BYTE	$A8			; DECBRGE	_B009
	!WORD	_B009-*
_B008 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0250:     ^dststr = strlen
; toolsrc/ed.pla: 0251: end
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0252: def delstr(strptr)#0
					; strptr -> [0]
_C003 					; delstr()
; toolsrc/ed.pla: 0253:     word ofst, mask
					; ofst -> [2]
					; mask -> [4]
; toolsrc/ed.pla: 0254: 
; toolsrc/ed.pla: 0255:     if strptr <> @nullstr
	!BYTE	$58,$06,$01		; ENTER	6,1
; toolsrc/ed.pla: 0256:         ofst = (strptr - strpool) >> 4
; toolsrc/ed.pla: 0257:         mask = sizemask(^strptr + 1) << (ofst & $07)
; toolsrc/ed.pla: 0258:         ofst = ofst >> 3
; toolsrc/ed.pla: 0259:         ^(strpoolmap + ofst) = ^(strpoolmap + ofst) & ~mask
; toolsrc/ed.pla: 0260:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+0
_F003 	!WORD	_D043+0		
	!BYTE	$22			; BREQ	_B013
	!WORD	_B013-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D050+0
_F004 	!WORD	_D050+0		
	!BYTE	$84			; SUB 
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_A002
_F005 	!WORD	_A002		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$9A			; SHL
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D052+0
_F006 	!WORD	_D052+0		
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$92			; COMP
	!BYTE	$94			; AND 
	!BYTE	$6A			; LAW	_D052+0
_F007 	!WORD	_D052+0		
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$70			; SB
_B013 
_B014 
; toolsrc/ed.pla: 0261: end
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0262: def newstr(strptr)
					; strptr -> [0]
_C004 					; newstr()
; toolsrc/ed.pla: 0263:     byte strlen
					; strlen -> [2]
; toolsrc/ed.pla: 0264:     word newptr
					; newptr -> [3]
; toolsrc/ed.pla: 0265: 
; toolsrc/ed.pla: 0266:     for strlen = ^strptr downto 1
	!BYTE	$58,$05,$01		; ENTER	5,1
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$A2			; BRLT	_B015
	!WORD	_B015-*
_B016 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/ed.pla: 0267:         if ^(strptr + strlen) > keyspace
; toolsrc/ed.pla: 0268:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B018
	!WORD	_B018-*
	!BYTE	$50			; BRNCH	_B015
	!WORD	_B015-*
; toolsrc/ed.pla: 0269:         fin
_B018 
_B019 
; toolsrc/ed.pla: 0270:     next
_B017 
	!BYTE	$A8			; DECBRGE	_B016
	!WORD	_B016-*
_B015 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0271:     if strlen == 0
; toolsrc/ed.pla: 0272:         return @nullstr
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$4E			; BRTRU	_B020
	!WORD	_B020-*
	!BYTE	$26			; LA	_D043+0
_F008 	!WORD	_D043+0		
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0273:     fin
_B020 
_B021 
; toolsrc/ed.pla: 0274:     newptr = poolalloc(strpool,          \
; toolsrc/ed.pla: 0275:     newptr = poolalloc(strpool,                                 strpoolmap,       \
; toolsrc/ed.pla: 0276:     newptr = poolalloc(strpool,                                 strpoolmap,                              strplmapsize - 1, \
; toolsrc/ed.pla: 0277:     newptr = poolalloc(strpool,                                 strpoolmap,                              strplmapsize - 1,                        sizemask(strlen + 1))
; toolsrc/ed.pla: 0278:     if newptr
; toolsrc/ed.pla: 0279:         memcpy(newptr + 1, strptr + 1, strlen)
; toolsrc/ed.pla: 0280:         ^newptr = strlen
; toolsrc/ed.pla: 0281:     else
	!BYTE	$6A			; LAW	_D050+0
_F009 	!WORD	_D050+0		
	!BYTE	$6A			; LAW	_D052+0
_F010 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D051+0
_F011 	!WORD	_D051+0		
	!BYTE	$8E			; DECR
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_A002
_F012 	!WORD	_A002		
	!BYTE	$54			; CALL	_A003
_F013 	!WORD	_A003		
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$4C			; BRFLS	_B022
	!WORD	_B022-*
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$54			; CALL	_X018
_F014 	!WORD	0		
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B023
	!WORD	_B023-*
_B022 
; toolsrc/ed.pla: 0282:         puts("Out of memory!\n")
	!BYTE	$2E			; CS
	!BYTE	$0F
	!BYTE	$4F,$75,$74,$20,$6F,$66,$20,$6D
	!BYTE	$65,$6D,$6F,$72,$79,$21,$0D
	!BYTE	$54			; CALL	_X004
_F015 	!WORD	0		
; toolsrc/ed.pla: 0283:         newptr = @nullstr
; toolsrc/ed.pla: 0284:     fin
	!BYTE	$26			; LA	_D043+0
_F016 	!WORD	_D043+0		
	!BYTE	$76,$03			; SLW	[3]
_B023 
; toolsrc/ed.pla: 0285:     return newptr
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0286: end
; toolsrc/ed.pla: 0287: def inittxtbuf#0
_C005 					; inittxtbuf()
; toolsrc/ed.pla: 0288:     word i
					; i -> [0]
; toolsrc/ed.pla: 0289: 
; toolsrc/ed.pla: 0290:     if not strpool
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0291:         txtlinbuf    = heapalloc(MAXLINESSIZE*2)
; toolsrc/ed.pla: 0292:         cliplinbuf   = heapalloc(MAXCLIPLINES*2)
; toolsrc/ed.pla: 0293:         strplmapsize = (heapavail - 1024) / 128
; toolsrc/ed.pla: 0294:         strpoolmap   = heapalloc(strplmapsize)
; toolsrc/ed.pla: 0295:         strpool      = heapalloc(strplmapsize * 128)
; toolsrc/ed.pla: 0296:         memset(txtlinbuf,  @nullstr, MAXLINESSIZE*2)
; toolsrc/ed.pla: 0297:         memset(cliplinbuf, @nullstr, MAXCLIPLINES*2)
; toolsrc/ed.pla: 0298:         memset(strpoolmap, 0, strplmapsize)
; toolsrc/ed.pla: 0299:     else
	!BYTE	$6A			; LAW	_D050+0
_F017 	!WORD	_D050+0		
	!BYTE	$4E			; BRTRU	_B024
	!WORD	_B024-*
	!BYTE	$2C,$FE,$07		; CW	2046
	!BYTE	$54			; CALL	_X014
_F018 	!WORD	0		
	!BYTE	$7A			; SAW	_D053+0
_F019 	!WORD	_D053+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X014
_F020 	!WORD	0		
	!BYTE	$7A			; SAW	_D054+0
_F021 	!WORD	_D054+0		
	!BYTE	$54			; CALL	_X016
_F022 	!WORD	0		
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$84			; SUB 
	!BYTE	$0E			; CN	7
	!BYTE	$9C			; SHR
	!BYTE	$7E			; DAW	_D051+0
_F023 	!WORD	_D051+0		
	!BYTE	$54			; CALL	_X014
_F024 	!WORD	0		
	!BYTE	$7A			; SAW	_D052+0
_F025 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D051+0
_F026 	!WORD	_D051+0		
	!BYTE	$0E			; CN	7
	!BYTE	$9A			; SHL
	!BYTE	$54			; CALL	_X014
_F027 	!WORD	0		
	!BYTE	$7A			; SAW	_D050+0
_F028 	!WORD	_D050+0		
	!BYTE	$6A			; LAW	_D053+0
_F029 	!WORD	_D053+0		
	!BYTE	$26			; LA	_D043+0
_F030 	!WORD	_D043+0		
	!BYTE	$2C,$FE,$07		; CW	2046
	!BYTE	$54			; CALL	_X017
_F031 	!WORD	0		
	!BYTE	$6A			; LAW	_D054+0
_F032 	!WORD	_D054+0		
	!BYTE	$26			; LA	_D043+0
_F033 	!WORD	_D043+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X017
_F034 	!WORD	0		
	!BYTE	$6A			; LAW	_D052+0
_F035 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D051+0
_F036 	!WORD	_D051+0		
	!BYTE	$54			; CALL	_X017
_F037 	!WORD	0		
	!BYTE	$50			; BRNCH	_B025
	!WORD	_B025-*
_B024 
; toolsrc/ed.pla: 0300:         for i = 0 to MAXLINESSIZE-1
	!BYTE	$2C,$FE,$03		; CW	1022
	!BYTE	$00			; CN	0
_B027 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0301:             if txtlinbuf=>[i] <> @nullstr
; toolsrc/ed.pla: 0302:                 delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 0303:                 txtlinbuf=>[i] = @nullstr
; toolsrc/ed.pla: 0304:             fin
	!BYTE	$6A			; LAW	_D053+0
_F038 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D043+0
_F039 	!WORD	_D043+0		
	!BYTE	$22			; BREQ	_B029
	!WORD	_B029-*
	!BYTE	$6A			; LAW	_D053+0
_F040 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F041 	!WORD	_C003		
	!BYTE	$26			; LA	_D043+0
_F042 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D053+0
_F043 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
_B029 
_B030 
; toolsrc/ed.pla: 0305:         next
_B028 
	!BYTE	$A4			; INCBRLE	_B027
	!WORD	_B027-*
_B026 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0306:     fin
_B025 
; toolsrc/ed.pla: 0307:     numlines   = 1
; toolsrc/ed.pla: 0308:     cursrow    = 0
; toolsrc/ed.pla: 0309:     curscol    = 0
; toolsrc/ed.pla: 0310:     cursx      = flags & gutter
; toolsrc/ed.pla: 0311:     cursy      = 0
; toolsrc/ed.pla: 0312:     viewleft   = 0
; toolsrc/ed.pla: 0313:     viewtop    = 0
; toolsrc/ed.pla: 0314:     viewwidth  = scrnwidth - (flags & gutter) - 2
; toolsrc/ed.pla: 0315:     flags      = flags & ~selection
; toolsrc/ed.pla: 0316: end
	!BYTE	$02			; CN	1
	!BYTE	$7A			; SAW	_D047+0
_F044 	!WORD	_D047+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D057+0
_F045 	!WORD	_D057+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D058+0
_F046 	!WORD	_D058+0		
	!BYTE	$68			; LAB	_D046+0
_F047 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$7A			; SAW	_D055+0
_F048 	!WORD	_D055+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D056+0
_F049 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D041+0
_F050 	!WORD	_D041+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D042+0
_F051 	!WORD	_D042+0		
	!BYTE	$68			; LAB	_D039+0
_F052 	!WORD	_D039+0		
	!BYTE	$68			; LAB	_D046+0
_F053 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$84			; SUB 
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$78			; SAB	_D040+0
_F054 	!WORD	_D040+0		
	!BYTE	$68			; LAB	_D046+0
_F055 	!WORD	_D046+0		
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D046+0
_F056 	!WORD	_D046+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0317: //
; toolsrc/ed.pla: 0318: // String routines
; toolsrc/ed.pla: 0319: //
; toolsrc/ed.pla: 0320: def fillnum(huns, tens, ones, chrptr)#3
					; huns -> [0]
					; tens -> [2]
					; ones -> [4]
					; chrptr -> [6]
_C006 					; fillnum()
; toolsrc/ed.pla: 0321:     if huns
	!BYTE	$58,$08,$04		; ENTER	8,4
; toolsrc/ed.pla: 0322:         chrptr->[0] = '0' + huns
; toolsrc/ed.pla: 0323:         chrptr->[1] = '0' + tens
; toolsrc/ed.pla: 0324:         chrptr->[2] = '0' + ones
; toolsrc/ed.pla: 0325:         ones++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B031
	!WORD	_B031-*
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0326:         if ones > 9
; toolsrc/ed.pla: 0327:             ones = 0
; toolsrc/ed.pla: 0328:             tens++
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0329:             if tens > 9
; toolsrc/ed.pla: 0330:                 tens = 0
; toolsrc/ed.pla: 0331:                 huns++
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B035
	!WORD	_B035-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0332:             fin
	!BYTE	$76,$00			; SLW	[0]
_B035 
_B036 
; toolsrc/ed.pla: 0333:         fin
_B033 
_B034 
; toolsrc/ed.pla: 0334:     elsif tens
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
_B031 
; toolsrc/ed.pla: 0335:         chrptr->[0] = ' '
; toolsrc/ed.pla: 0336:         chrptr->[1] = '0' + tens
; toolsrc/ed.pla: 0337:         chrptr->[2] = '0' + ones
; toolsrc/ed.pla: 0338:         ones++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B037
	!WORD	_B037-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0339:         if ones > 9
; toolsrc/ed.pla: 0340:             ones = 0
; toolsrc/ed.pla: 0341:             tens++
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B038
	!WORD	_B038-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0342:             if tens > 9
; toolsrc/ed.pla: 0343:                 tens = 0
; toolsrc/ed.pla: 0344:                 huns = 1
; toolsrc/ed.pla: 0345:             fin
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B040
	!WORD	_B040-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$76,$00			; SLW	[0]
_B040 
_B041 
; toolsrc/ed.pla: 0346:         fin
_B038 
_B039 
; toolsrc/ed.pla: 0347:     elsif ones
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
_B037 
; toolsrc/ed.pla: 0348:         chrptr->[0] = ' '
; toolsrc/ed.pla: 0349:         chrptr->[1] = ' '
; toolsrc/ed.pla: 0350:         chrptr->[2] = '0' + ones
; toolsrc/ed.pla: 0351:         ones++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B042
	!WORD	_B042-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0352:         if ones > 9
; toolsrc/ed.pla: 0353:             ones = 0
; toolsrc/ed.pla: 0354:             tens = 1
; toolsrc/ed.pla: 0355:         fin
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B043
	!WORD	_B043-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$02			; CN	1
	!BYTE	$76,$02			; SLW	[2]
_B043 
_B044 
; toolsrc/ed.pla: 0356:     fin
_B042 
_B032 
; toolsrc/ed.pla: 0357:     return huns, tens, ones
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/ed.pla: 0358: end
; toolsrc/ed.pla: 0359: def strtonum(strptr)
					; strptr -> [0]
_C007 					; strtonum()
; toolsrc/ed.pla: 0360:     word num, i
					; num -> [2]
					; i -> [4]
; toolsrc/ed.pla: 0361:     byte c
					; c -> [6]
; toolsrc/ed.pla: 0362: 
; toolsrc/ed.pla: 0363:     num = 0
	!BYTE	$58,$07,$01		; ENTER	7,1
; toolsrc/ed.pla: 0364:     for i = 1 to ^strptr
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B045
	!WORD	_B045-*
_B046 
	!BYTE	$6E,$04			; DLW	[4]
; toolsrc/ed.pla: 0365:         c = ^(strptr + i) & $7F
; toolsrc/ed.pla: 0366:         if c < '0' and c > '9'
; toolsrc/ed.pla: 0367:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B048
	!WORD	_B048-*
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
_B048 
	!BYTE	$4C			; BRFLS	_B049
	!WORD	_B049-*
	!BYTE	$50			; BRNCH	_B045
	!WORD	_B045-*
; toolsrc/ed.pla: 0368:         fin
_B049 
_B050 
; toolsrc/ed.pla: 0369:         num = num * 10 + c - '0'
; toolsrc/ed.pla: 0370:     next
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$02			; SLW	[2]
_B047 
	!BYTE	$A4			; INCBRLE	_B046
	!WORD	_B046-*
_B045 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0371:     return num
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/ed.pla: 0372: end
; toolsrc/ed.pla: 0373: def nametostr(namestr, len, strptr)#0
					; namestr -> [0]
					; len -> [2]
					; strptr -> [4]
_C008 					; nametostr()
; toolsrc/ed.pla: 0374:     ^strptr = len
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/ed.pla: 0375:     memcpy(strptr + 1, namestr, len)
; toolsrc/ed.pla: 0376: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X018
_F057 	!WORD	0		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0377: //
; toolsrc/ed.pla: 0378: // File routines
; toolsrc/ed.pla: 0379: //
; toolsrc/ed.pla: 0380: def readtxt(filename, startline)#0
					; filename -> [0]
					; startline -> [2]
_C009 					; readtxt()
; toolsrc/ed.pla: 0381:     byte refnum, i, j, txtbuf[MAXLNLEN+2]
					; refnum -> [4]
					; i -> [5]
					; j -> [6]
					; txtbuf -> [7]
; toolsrc/ed.pla: 0382: 
; toolsrc/ed.pla: 0383:     refnum = fileio:open(filename)
	!BYTE	$58,$88,$02		; ENTER	136,2
; toolsrc/ed.pla: 0384:     if refnum
; toolsrc/ed.pla: 0385:         fileio:newline(refnum, $7F, $0D)
; toolsrc/ed.pla: 0386:         numlines = startline
; toolsrc/ed.pla: 0387:         repeat
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+14
_F058 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$4C			; BRFLS	_B051
	!WORD	_B051-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_X031+28
_F059 	!WORD	0+28		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D047+0
_F060 	!WORD	_D047+0		
_B054 
; toolsrc/ed.pla: 0388:             txtbuf = fileio:read(refnum, @txtbuf + 1, MAXLNLEN)
; toolsrc/ed.pla: 0389:             if txtbuf
; toolsrc/ed.pla: 0390:                 txtlinbuf=>[numlines] = newstr(@txtbuf)
; toolsrc/ed.pla: 0391:                 numlines++
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$6A			; LAW	_X031+18
_F061 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$07			; DLB	[7]
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_C004
_F062 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F063 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D047+0
_F064 	!WORD	_D047+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D047+0
_F065 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0392:             fin
	!BYTE	$7A			; SAW	_D047+0
_F066 	!WORD	_D047+0		
_B056 
_B057 
; toolsrc/ed.pla: 0393:             if !(numlines & $0F); putc('.'); fin
	!BYTE	$6A			; LAW	_D047+0
_F067 	!WORD	_D047+0		
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4E			; BRTRU	_B058
	!WORD	_B058-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F068 	!WORD	0		
_B058 
_B059 
; toolsrc/ed.pla: 0394:         until txtbuf == 0 or numlines == MAXLINES
_B055 
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B060
	!WORD	_B060-*
	!BYTE	$6A			; LAW	_D047+0
_F069 	!WORD	_D047+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$40			; ISEQ
_B060 
	!BYTE	$4C			; BRFLS	_B054
	!WORD	_B054-*
_B053 
; toolsrc/ed.pla: 0395:         fileio:close(refnum)
; toolsrc/ed.pla: 0396:         //
; toolsrc/ed.pla: 0397:         // Make sure there is a blank line at the end of the buffer
; toolsrc/ed.pla: 0398:         //
; toolsrc/ed.pla: 0399:         if numlines < MAXLINES and txtlinbuf=>[numlines - 1] <> @nullstr
; toolsrc/ed.pla: 0400:             txtlinbuf=>[numlines] = @nullstr
; toolsrc/ed.pla: 0401:             numlines++
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F070 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D047+0
_F071 	!WORD	_D047+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B061
	!WORD	_B061-*
	!BYTE	$6A			; LAW	_D053+0
_F072 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D047+0
_F073 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D043+0
_F074 	!WORD	_D043+0		
	!BYTE	$42			; ISNE
_B061 
	!BYTE	$4C			; BRFLS	_B062
	!WORD	_B062-*
	!BYTE	$26			; LA	_D043+0
_F075 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D053+0
_F076 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D047+0
_F077 	!WORD	_D047+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D047+0
_F078 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0402:         fin
	!BYTE	$7A			; SAW	_D047+0
_F079 	!WORD	_D047+0		
_B062 
_B063 
; toolsrc/ed.pla: 0403:     fin
_B051 
_B052 
; toolsrc/ed.pla: 0404:     putln
; toolsrc/ed.pla: 0405: end
	!BYTE	$54			; CALL	_X003
_F080 	!WORD	0		
	!BYTE	$5A,$88			; LEAVE	136
; toolsrc/ed.pla: 0406: def writetxt(filename)#0
					; filename -> [0]
_C010 					; writetxt()
; toolsrc/ed.pla: 0407:     word i
					; i -> [2]
; toolsrc/ed.pla: 0408:     byte refnum, txtbuf[MAXLNLEN+2], txtlen
					; refnum -> [4]
					; txtbuf -> [5]
					; txtlen -> [134]
; toolsrc/ed.pla: 0409: 
; toolsrc/ed.pla: 0410:     //
; toolsrc/ed.pla: 0411:     // Remove blank lines at end of text.
; toolsrc/ed.pla: 0412:     //
; toolsrc/ed.pla: 0413:     while numlines > 1 and txtlinbuf=>[numlines - 1] == @nullstr; numlines--; loop
	!BYTE	$58,$87,$01		; ENTER	135,1
	!BYTE	$50			; BRNCH	_B066
	!WORD	_B066-*
_B064 
	!BYTE	$6A			; LAW	_D047+0
_F081 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D047+0
_F082 	!WORD	_D047+0		
_B066 
	!BYTE	$6A			; LAW	_D047+0
_F083 	!WORD	_D047+0		
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B067
	!WORD	_B067-*
	!BYTE	$6A			; LAW	_D053+0
_F084 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D047+0
_F085 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D043+0
_F086 	!WORD	_D043+0		
	!BYTE	$40			; ISEQ
_B067 
	!BYTE	$4E			; BRTRU	_B064
	!WORD	_B064-*
_B065 
; toolsrc/ed.pla: 0414:     //
; toolsrc/ed.pla: 0415:     // Delete old file and re-create
; toolsrc/ed.pla: 0416:     //
; toolsrc/ed.pla: 0417:     fileio:destroy(filename)
; toolsrc/ed.pla: 0418:     fileio:create(filename, $04, $00) // full access, TXT file
; toolsrc/ed.pla: 0419:     refnum = fileio:open(filename)
; toolsrc/ed.pla: 0420:     if refnum == 0
; toolsrc/ed.pla: 0421:         puts("\nError $"); puth(perr); puts(" opening: "); puts(filename); putln
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+24
_F087 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X031+22
_F088 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+14
_F089 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$4E			; BRTRU	_B068
	!WORD	_B068-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F090 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F091 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F092 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$6F,$70,$65,$6E,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F093 	!WORD	0		
; toolsrc/ed.pla: 0422:         return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F094 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F095 	!WORD	0		
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/ed.pla: 0423:     fin
_B068 
_B069 
; toolsrc/ed.pla: 0424:     //
; toolsrc/ed.pla: 0425:     // Write all the text lines to the file.
; toolsrc/ed.pla: 0426:     //
; toolsrc/ed.pla: 0427:     for i = 0 to numlines - 1
	!BYTE	$6A			; LAW	_D047+0
_F096 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B070
	!WORD	_B070-*
_B071 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/ed.pla: 0428:         txtlen = ^(txtlinbuf=>[i])
; toolsrc/ed.pla: 0429:         memcpy(@txtbuf, txtlinbuf=>[i] + 1, txtlen)
; toolsrc/ed.pla: 0430:         txtbuf[txtlen] = keyenter
; toolsrc/ed.pla: 0431:         txtlen++
	!BYTE	$6A			; LAW	_D053+0
_F097 	!WORD	_D053+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$74,$86			; SLB	[134]
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$6A			; LAW	_D053+0
_F098 	!WORD	_D053+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$86			; LLB	[134]
	!BYTE	$54			; CALL	_X018
_F099 	!WORD	0		
	!BYTE	$1A			; CN	13
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$B0,$86			; ADDLB	[134]
	!BYTE	$70			; SB
	!BYTE	$64,$86			; LLB	[134]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0432:         if fileio:write(refnum, @txtbuf, txtlen) <> txtlen
; toolsrc/ed.pla: 0433:             puts("\nError $"); puth(perr); puts(" writing: "); puts(filename); putln
	!BYTE	$74,$86			; SLB	[134]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$64,$86			; LLB	[134]
	!BYTE	$6A			; LAW	_X031+20
_F100 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$64,$86			; LLB	[134]
	!BYTE	$22			; BREQ	_B073
	!WORD	_B073-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F101 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F102 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F103 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$77,$72,$69,$74,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F104 	!WORD	0		
; toolsrc/ed.pla: 0434:             fileio:close(refnum)
; toolsrc/ed.pla: 0435:             return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F105 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F106 	!WORD	0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F107 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/ed.pla: 0436:         fin
_B073 
_B074 
; toolsrc/ed.pla: 0437:         if !(i & $0F); putc('.'); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4E			; BRTRU	_B075
	!WORD	_B075-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F108 	!WORD	0		
_B075 
_B076 
; toolsrc/ed.pla: 0438:     next
_B072 
	!BYTE	$A4			; INCBRLE	_B071
	!WORD	_B071-*
_B070 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0439:     if fileio:close(refnum) <> FILE_ERR_OK
; toolsrc/ed.pla: 0440:         puts("\nError $"); puth(perr); puts(" closing: "); puts(filename)
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F109 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B077
	!WORD	_B077-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F110 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F111 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F112 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$63,$6C,$6F,$73,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F113 	!WORD	0		
; toolsrc/ed.pla: 0441:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F114 	!WORD	0		
_B077 
_B078 
; toolsrc/ed.pla: 0442:     putln
; toolsrc/ed.pla: 0443: end
	!BYTE	$54			; CALL	_X003
_F115 	!WORD	0		
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/ed.pla: 0444: //
; toolsrc/ed.pla: 0445: // Screen routines
; toolsrc/ed.pla: 0446: //
; toolsrc/ed.pla: 0447: def drawstr(row, strptr)#0
					; row -> [0]
					; strptr -> [2]
_C011 					; drawstr()
; toolsrc/ed.pla: 0448:     word numchars
					; numchars -> [4]
; toolsrc/ed.pla: 0449: 
; toolsrc/ed.pla: 0450:     conio:gotoxy(flags & gutter, row)
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/ed.pla: 0451:     numchars = ^strptr - viewleft
; toolsrc/ed.pla: 0452:     if numchars >= viewwidth
; toolsrc/ed.pla: 0453:         conio:putchars(viewwidth, strptr + viewleft + 1)
; toolsrc/ed.pla: 0454:     else
	!BYTE	$68			; LAB	_D046+0
_F116 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X033+8
_F117 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D041+0
_F118 	!WORD	_D041+0		
	!BYTE	$84			; SUB 
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$68			; LAB	_D040+0
_F119 	!WORD	_D040+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B079
	!WORD	_B079-*
	!BYTE	$68			; LAB	_D040+0
_F120 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B4			; ADDAB	_D041+0
_F121 	!WORD	_D041+0		
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_X033+4
_F122 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B079 
; toolsrc/ed.pla: 0455:         conio:putchars(numchars, strptr + viewleft + 1)
; toolsrc/ed.pla: 0456:         conio:clear(cleol)
; toolsrc/ed.pla: 0457:     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B4			; ADDAB	_D041+0
_F123 	!WORD	_D041+0		
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_X033+4
_F124 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+6
_F125 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B080 
; toolsrc/ed.pla: 0458: end
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0459: def drawgutterrow(row)#0
					; row -> [0]
_C012 					; drawgutterrow()
; toolsrc/ed.pla: 0460:     byte seperator, huns, tens, ones
					; seperator -> [2]
					; huns -> [3]
					; tens -> [4]
					; ones -> [5]
; toolsrc/ed.pla: 0461:     word scrnrow
					; scrnrow -> [6]
; toolsrc/ed.pla: 0462:     char gutterchars[3]
					; gutterchars -> [8]
; toolsrc/ed.pla: 0463: 
; toolsrc/ed.pla: 0464:     //
; toolsrc/ed.pla: 0465:     // Draw line numbers and gutter hilites
; toolsrc/ed.pla: 0466:     //
; toolsrc/ed.pla: 0467:     if flags & gutter
	!BYTE	$58,$0B,$01		; ENTER	11,1
; toolsrc/ed.pla: 0468:         scrnrow    = row + viewtop
; toolsrc/ed.pla: 0469:         huns, tens = divmod(scrnrow + 1, 100)
; toolsrc/ed.pla: 0470:         tens, ones = divmod(tens, 10)
; toolsrc/ed.pla: 0471:         if scrnrow < numlines
; toolsrc/ed.pla: 0472:             seperator = viewleft ?? '<' :: ' '
; toolsrc/ed.pla: 0473:             if flags & selection
; toolsrc/ed.pla: 0474:                 if (scrnrow >= selrow and scrnrow <= cursrow) or (scrnrow >= cursrow and scrnrow <= selrow)
; toolsrc/ed.pla: 0475:                     seperator = '['
; toolsrc/ed.pla: 0476:                     conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0477:                 fin
	!BYTE	$68			; LAB	_D046+0
_F126 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B081
	!WORD	_B081-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B6			; ADDAW	_D042+0
_F127 	!WORD	_D042+0		
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$64			; CB	100
	!BYTE	$54			; CALL	_X023
_F128 	!WORD	0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X023
_F129 	!WORD	0		
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D047+0
_F130 	!WORD	_D047+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B083
	!WORD	_B083-*
	!BYTE	$68			; LAB	_D041+0
_F131 	!WORD	_D041+0		
	!BYTE	$4C			; BRFLS	_B085
	!WORD	_B085-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$50			; BRNCH	_B086
	!WORD	_B086-*
_B085 
	!BYTE	$2A,$20			; CB	32
_B086 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$68			; LAB	_D046+0
_F132 	!WORD	_D046+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B087
	!WORD	_B087-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D059+0
_F133 	!WORD	_D059+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B089
	!WORD	_B089-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D057+0
_F134 	!WORD	_D057+0		
	!BYTE	$4A			; ISLE
_B089 
	!BYTE	$AE			; BROR	_B090
	!WORD	_B090-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D057+0
_F135 	!WORD	_D057+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B091
	!WORD	_B091-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D059+0
_F136 	!WORD	_D059+0		
	!BYTE	$4A			; ISLE
_B091 
_B090 
	!BYTE	$4C			; BRFLS	_B092
	!WORD	_B092-*
	!BYTE	$2A,$5B			; CB	91
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F137 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B092 
_B093 
; toolsrc/ed.pla: 0478:             fin
_B087 
_B088 
; toolsrc/ed.pla: 0479:             if scrnrow == cursrow
; toolsrc/ed.pla: 0480:                 conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0481:             fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D057+0
_F138 	!WORD	_D057+0		
	!BYTE	$24			; BRNE	_B094
	!WORD	_B094-*
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F139 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B094 
_B095 
; toolsrc/ed.pla: 0482:             huns, tens, ones = fillnum(huns, tens, ones, @gutterchars)
; toolsrc/ed.pla: 0483:             conio:gotoxy(0, row)
; toolsrc/ed.pla: 0484:             conio:putchars(3, @gutterchars)
; toolsrc/ed.pla: 0485:             conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0486:             putc(seperator)
; toolsrc/ed.pla: 0487:             conio:textctrl(ctrlattr, NORMAL)
; toolsrc/ed.pla: 0488:         fin
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C006
_F140 	!WORD	_C006		
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X033+8
_F141 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$6A			; LAW	_X033+4
_F142 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F143 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$54			; CALL	_X002
_F144 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$6A			; LAW	_X033+12
_F145 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B083 
_B084 
; toolsrc/ed.pla: 0489:     fin
_B081 
_B082 
; toolsrc/ed.pla: 0490: end
	!BYTE	$5A,$0B			; LEAVE	11
; toolsrc/ed.pla: 0491: def drawgutter#0
_C013 					; drawgutter()
; toolsrc/ed.pla: 0492:     byte row, seperator, huns, tens, ones
					; row -> [0]
					; seperator -> [1]
					; huns -> [2]
					; tens -> [3]
					; ones -> [4]
; toolsrc/ed.pla: 0493:     word scrnrow
					; scrnrow -> [5]
; toolsrc/ed.pla: 0494:     char gutterchars[3]
					; gutterchars -> [7]
; toolsrc/ed.pla: 0495: 
; toolsrc/ed.pla: 0496:     //
; toolsrc/ed.pla: 0497:     // Draw line numbers and gutter hilites
; toolsrc/ed.pla: 0498:     //
; toolsrc/ed.pla: 0499:     if flags & gutter
	!BYTE	$58,$0A,$00		; ENTER	10,0
; toolsrc/ed.pla: 0500:         seperator = viewleft ?? '<' :: ' '
; toolsrc/ed.pla: 0501:         huns, tens = divmod(viewtop + 1, 100)
; toolsrc/ed.pla: 0502:         tens, ones = divmod(tens, 10)
; toolsrc/ed.pla: 0503:         for row = 0 to scrnheight-1
	!BYTE	$68			; LAB	_D046+0
_F146 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$68			; LAB	_D041+0
_F147 	!WORD	_D041+0		
	!BYTE	$4C			; BRFLS	_B098
	!WORD	_B098-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$50			; BRNCH	_B099
	!WORD	_B099-*
_B098 
	!BYTE	$2A,$20			; CB	32
_B099 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D042+0
_F148 	!WORD	_D042+0		
	!BYTE	$8C			; INCR
	!BYTE	$2A,$64			; CB	100
	!BYTE	$54			; CALL	_X023
_F149 	!WORD	0		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X023
_F150 	!WORD	0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6A			; LAW	_D038+0
_F151 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B100
	!WORD	_B100-*
_B101 
	!BYTE	$6C,$00			; DLB	[0]
; toolsrc/ed.pla: 0504:             scrnrow = row + viewtop
; toolsrc/ed.pla: 0505:             if scrnrow < numlines
; toolsrc/ed.pla: 0506:                 seperator = viewleft ?? '<' :: ' '
; toolsrc/ed.pla: 0507:                 if flags & selection
; toolsrc/ed.pla: 0508:                     if (scrnrow >= selrow and scrnrow <= cursrow) or (scrnrow >= cursrow and scrnrow <= selrow)
; toolsrc/ed.pla: 0509:                         seperator = '['
; toolsrc/ed.pla: 0510:                         conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0511:                     fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$B6			; ADDAW	_D042+0
_F152 	!WORD	_D042+0		
	!BYTE	$6E,$05			; DLW	[5]
	!BYTE	$6A			; LAW	_D047+0
_F153 	!WORD	_D047+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B103
	!WORD	_B103-*
	!BYTE	$68			; LAB	_D041+0
_F154 	!WORD	_D041+0		
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$50			; BRNCH	_B106
	!WORD	_B106-*
_B105 
	!BYTE	$2A,$20			; CB	32
_B106 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$68			; LAB	_D046+0
_F155 	!WORD	_D046+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$6A			; LAW	_D059+0
_F156 	!WORD	_D059+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B109
	!WORD	_B109-*
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$6A			; LAW	_D057+0
_F157 	!WORD	_D057+0		
	!BYTE	$4A			; ISLE
_B109 
	!BYTE	$AE			; BROR	_B110
	!WORD	_B110-*
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$6A			; LAW	_D057+0
_F158 	!WORD	_D057+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B111
	!WORD	_B111-*
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$6A			; LAW	_D059+0
_F159 	!WORD	_D059+0		
	!BYTE	$4A			; ISLE
_B111 
_B110 
	!BYTE	$4C			; BRFLS	_B112
	!WORD	_B112-*
	!BYTE	$2A,$5B			; CB	91
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F160 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B112 
_B113 
; toolsrc/ed.pla: 0512:                 fin
_B107 
_B108 
; toolsrc/ed.pla: 0513:                 if scrnrow == cursrow
; toolsrc/ed.pla: 0514:                     conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0515:                 fin
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$6A			; LAW	_D057+0
_F161 	!WORD	_D057+0		
	!BYTE	$24			; BRNE	_B114
	!WORD	_B114-*
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F162 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B114 
_B115 
; toolsrc/ed.pla: 0516:                 huns, tens, ones = fillnum(huns, tens, ones, @gutterchars)
; toolsrc/ed.pla: 0517:                 conio:gotoxy(0, row)
; toolsrc/ed.pla: 0518:                 conio:putchars(3, @gutterchars)
; toolsrc/ed.pla: 0519:                 conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0520:                 putc(seperator)
; toolsrc/ed.pla: 0521:                 conio:textctrl(ctrlattr, NORMAL)
; toolsrc/ed.pla: 0522:             fin
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_C006
_F163 	!WORD	_C006		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$00			; CN	0
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$6A			; LAW	_X033+8
_F164 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_X033+4
_F165 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F166 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_X002
_F167 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$6A			; LAW	_X033+12
_F168 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B103 
_B104 
; toolsrc/ed.pla: 0523:         next
_B102 
	!BYTE	$A4			; INCBRLE	_B101
	!WORD	_B101-*
_B100 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0524:     fin
_B096 
_B097 
; toolsrc/ed.pla: 0525: end
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 0526: def drawrows(toprow, bottomrow)#0
					; toprow -> [0]
					; bottomrow -> [2]
_C014 					; drawrows()
; toolsrc/ed.pla: 0527:     byte row, seperator, huns, tens, ones
					; row -> [4]
					; seperator -> [5]
					; huns -> [6]
					; tens -> [7]
					; ones -> [8]
; toolsrc/ed.pla: 0528:     word scrnrow, strptr, numchars
					; scrnrow -> [9]
					; strptr -> [11]
					; numchars -> [13]
; toolsrc/ed.pla: 0529:     char gutterchars[3]
					; gutterchars -> [15]
; toolsrc/ed.pla: 0530: 
; toolsrc/ed.pla: 0531:     //
; toolsrc/ed.pla: 0532:     // Draw gutter and text
; toolsrc/ed.pla: 0533:     //
; toolsrc/ed.pla: 0534:     huns, tens = divmod(viewtop + toprow + 1, 100)
	!BYTE	$58,$12,$02		; ENTER	18,2
; toolsrc/ed.pla: 0535:     tens, ones = divmod(tens, 10)
; toolsrc/ed.pla: 0536:     for row = toprow to bottomrow
	!BYTE	$6A			; LAW	_D042+0
_F169 	!WORD	_D042+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$64			; CB	100
	!BYTE	$54			; CALL	_X023
_F170 	!WORD	0		
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X023
_F171 	!WORD	0		
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$A0			; BRGT	_B116
	!WORD	_B116-*
_B117 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0537:         conio:gotoxy(0, row)
; toolsrc/ed.pla: 0538:         scrnrow = row + viewtop
; toolsrc/ed.pla: 0539:         if scrnrow < numlines
; toolsrc/ed.pla: 0540:             if flags & gutter
; toolsrc/ed.pla: 0541:                 seperator = viewleft ?? '<' :: ' '
; toolsrc/ed.pla: 0542:                 if flags & selection
; toolsrc/ed.pla: 0543:                     if (scrnrow >= selrow and scrnrow <= cursrow) or (scrnrow >= cursrow and scrnrow <= selrow)
; toolsrc/ed.pla: 0544:                         seperator = '['
; toolsrc/ed.pla: 0545:                         conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0546:                     fin
	!BYTE	$00			; CN	0
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X033+8
_F172 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$B6			; ADDAW	_D042+0
_F173 	!WORD	_D042+0		
	!BYTE	$6E,$09			; DLW	[9]
	!BYTE	$6A			; LAW	_D047+0
_F174 	!WORD	_D047+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B119
	!WORD	_B119-*
	!BYTE	$68			; LAB	_D046+0
_F175 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B121
	!WORD	_B121-*
	!BYTE	$68			; LAB	_D041+0
_F176 	!WORD	_D041+0		
	!BYTE	$4C			; BRFLS	_B123
	!WORD	_B123-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$50			; BRNCH	_B124
	!WORD	_B124-*
_B123 
	!BYTE	$2A,$20			; CB	32
_B124 
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$68			; LAB	_D046+0
_F177 	!WORD	_D046+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B125
	!WORD	_B125-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$6A			; LAW	_D059+0
_F178 	!WORD	_D059+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B127
	!WORD	_B127-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$6A			; LAW	_D057+0
_F179 	!WORD	_D057+0		
	!BYTE	$4A			; ISLE
_B127 
	!BYTE	$AE			; BROR	_B128
	!WORD	_B128-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$6A			; LAW	_D057+0
_F180 	!WORD	_D057+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B129
	!WORD	_B129-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$6A			; LAW	_D059+0
_F181 	!WORD	_D059+0		
	!BYTE	$4A			; ISLE
_B129 
_B128 
	!BYTE	$4C			; BRFLS	_B130
	!WORD	_B130-*
	!BYTE	$2A,$5B			; CB	91
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F182 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B130 
_B131 
; toolsrc/ed.pla: 0547:                 fin
_B125 
_B126 
; toolsrc/ed.pla: 0548:                 if scrnrow == cursrow
; toolsrc/ed.pla: 0549:                     conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0550:                 fin
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$6A			; LAW	_D057+0
_F183 	!WORD	_D057+0		
	!BYTE	$24			; BRNE	_B132
	!WORD	_B132-*
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F184 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B132 
_B133 
; toolsrc/ed.pla: 0551:                 huns, tens, ones = fillnum(huns, tens, ones, @gutterchars)
; toolsrc/ed.pla: 0552:                 conio:putchars(3, @gutterchars)
; toolsrc/ed.pla: 0553:                 conio:textctrl(ctrlattr, INVERSE)
; toolsrc/ed.pla: 0554:                 putc(seperator)
; toolsrc/ed.pla: 0555:                 conio:textctrl(ctrlattr, NORMAL)
; toolsrc/ed.pla: 0556:             fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$54			; CALL	_C006
_F185 	!WORD	_C006		
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$06			; CN	3
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$6A			; LAW	_X033+4
_F186 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F187 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$54			; CALL	_X002
_F188 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$6A			; LAW	_X033+12
_F189 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B121 
_B122 
; toolsrc/ed.pla: 0557:             strptr = txtlinbuf=>[scrnrow]
; toolsrc/ed.pla: 0558:             numchars = ^strptr - viewleft
; toolsrc/ed.pla: 0559:             if numchars >= viewwidth
; toolsrc/ed.pla: 0560:                 numchars = viewwidth
; toolsrc/ed.pla: 0561:             fin
	!BYTE	$6A			; LAW	_D053+0
_F190 	!WORD	_D053+0		
	!BYTE	$BA,$09			; IDXLW	[9]
	!BYTE	$62			; LW
	!BYTE	$6E,$0B			; DLW	[11]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D041+0
_F191 	!WORD	_D041+0		
	!BYTE	$84			; SUB 
	!BYTE	$6E,$0D			; DLW	[13]
	!BYTE	$68			; LAB	_D040+0
_F192 	!WORD	_D040+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B134
	!WORD	_B134-*
	!BYTE	$68			; LAB	_D040+0
_F193 	!WORD	_D040+0		
	!BYTE	$76,$0D			; SLW	[13]
_B134 
_B135 
; toolsrc/ed.pla: 0562:             conio:putchars(numchars, strptr + viewleft + 1)
; toolsrc/ed.pla: 0563:         fin
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$B4			; ADDAB	_D041+0
_F194 	!WORD	_D041+0		
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_X033+4
_F195 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B119 
_B120 
; toolsrc/ed.pla: 0564:         conio:clear(cleol)
; toolsrc/ed.pla: 0565:     next
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+6
_F196 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B118 
	!BYTE	$A4			; INCBRLE	_B117
	!WORD	_B117-*
_B116 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0566: end
	!BYTE	$5A,$12			; LEAVE	18
; toolsrc/ed.pla: 0567: def drawscrn#0
_C015 					; drawscrn()
; toolsrc/ed.pla: 0568:     drawrows(0, scrnheight - 1)
; toolsrc/ed.pla: 0569: end
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D038+0
_F197 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C014
_F198 	!WORD	_C014		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0570: def curshpos(hpos)#1
					; hpos -> [0]
_C016 					; curshpos()
; toolsrc/ed.pla: 0571:     byte needredraw, scrnleft, scrnright
					; needredraw -> [2]
					; scrnleft -> [3]
					; scrnright -> [4]
; toolsrc/ed.pla: 0572: 
; toolsrc/ed.pla: 0573:     needredraw = TRUE
	!BYTE	$58,$05,$01		; ENTER	5,1
; toolsrc/ed.pla: 0574:     if hpos < 0; hpos = 0; fin
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B136
	!WORD	_B136-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B136 
_B137 
; toolsrc/ed.pla: 0575:     if hpos > MAXLNLEN; hpos = MAXLNLEN; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B138
	!WORD	_B138-*
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$76,$00			; SLW	[0]
_B138 
_B139 
; toolsrc/ed.pla: 0576:     scrnleft  = flags & gutter
; toolsrc/ed.pla: 0577:     scrnright = scrnwidth - 2
; toolsrc/ed.pla: 0578:     curscol   = hpos
; toolsrc/ed.pla: 0579:     cursx     = curscol - viewleft + scrnleft
; toolsrc/ed.pla: 0580:     if cursx > scrnright
; toolsrc/ed.pla: 0581:         cursx    = scrnright
; toolsrc/ed.pla: 0582:         viewleft = curscol - viewwidth
; toolsrc/ed.pla: 0583:     elsif cursx < scrnleft
	!BYTE	$68			; LAB	_D046+0
_F199 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$68			; LAB	_D039+0
_F200 	!WORD	_D039+0		
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D058+0
_F201 	!WORD	_D058+0		
	!BYTE	$68			; LAB	_D041+0
_F202 	!WORD	_D041+0		
	!BYTE	$84			; SUB 
	!BYTE	$B0,$03			; ADDLB	[3]
	!BYTE	$7E			; DAW	_D055+0
_F203 	!WORD	_D055+0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B140
	!WORD	_B140-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$7A			; SAW	_D055+0
_F204 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D058+0
_F205 	!WORD	_D058+0		
	!BYTE	$68			; LAB	_D040+0
_F206 	!WORD	_D040+0		
	!BYTE	$84			; SUB 
	!BYTE	$78			; SAB	_D041+0
_F207 	!WORD	_D041+0		
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
_B140 
; toolsrc/ed.pla: 0584:         cursx    = scrnleft
; toolsrc/ed.pla: 0585:         viewleft = curscol
; toolsrc/ed.pla: 0586:     else
	!BYTE	$6A			; LAW	_D055+0
_F208 	!WORD	_D055+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B142
	!WORD	_B142-*
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$7A			; SAW	_D055+0
_F209 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D058+0
_F210 	!WORD	_D058+0		
	!BYTE	$78			; SAB	_D041+0
_F211 	!WORD	_D041+0		
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
_B142 
; toolsrc/ed.pla: 0587:         needredraw = FALSE
; toolsrc/ed.pla: 0588:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
_B141 
; toolsrc/ed.pla: 0589:     return needredraw
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0590: end
; toolsrc/ed.pla: 0591: def cursvpos(vpos)#1
					; vpos -> [0]
_C017 					; cursvpos()
; toolsrc/ed.pla: 0592:     byte needredraw
					; needredraw -> [2]
; toolsrc/ed.pla: 0593: 
; toolsrc/ed.pla: 0594:     needredraw = TRUE
	!BYTE	$58,$03,$01		; ENTER	3,1
; toolsrc/ed.pla: 0595:     if vpos < 0; vpos = 0; fin
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B143
	!WORD	_B143-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B143 
_B144 
; toolsrc/ed.pla: 0596:     if vpos > numlines - 1; vpos = numlines - 1; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D047+0
_F212 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B145
	!WORD	_B145-*
	!BYTE	$6A			; LAW	_D047+0
_F213 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$76,$00			; SLW	[0]
_B145 
_B146 
; toolsrc/ed.pla: 0597:     cursrow = vpos
; toolsrc/ed.pla: 0598:     cursy   = cursrow - viewtop
; toolsrc/ed.pla: 0599:     if cursy > scrnheight - 1
; toolsrc/ed.pla: 0600:         cursy   = scrnheight - 1
; toolsrc/ed.pla: 0601:         viewtop = cursrow - (scrnheight - 1)
; toolsrc/ed.pla: 0602:     elsif cursy < 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D057+0
_F214 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D042+0
_F215 	!WORD	_D042+0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D056+0
_F216 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D038+0
_F217 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B147
	!WORD	_B147-*
	!BYTE	$6A			; LAW	_D038+0
_F218 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D056+0
_F219 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D057+0
_F220 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D038+0
_F221 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D042+0
_F222 	!WORD	_D042+0		
	!BYTE	$50			; BRNCH	_B148
	!WORD	_B148-*
_B147 
; toolsrc/ed.pla: 0603:         cursy   = 0
; toolsrc/ed.pla: 0604:         viewtop = cursrow
; toolsrc/ed.pla: 0605:     else
	!BYTE	$6A			; LAW	_D056+0
_F223 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B149
	!WORD	_B149-*
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D056+0
_F224 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D057+0
_F225 	!WORD	_D057+0		
	!BYTE	$7A			; SAW	_D042+0
_F226 	!WORD	_D042+0		
	!BYTE	$50			; BRNCH	_B148
	!WORD	_B148-*
_B149 
; toolsrc/ed.pla: 0606:         needredraw = FALSE
; toolsrc/ed.pla: 0607:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
_B148 
; toolsrc/ed.pla: 0608:     return needredraw
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 0609: end
; toolsrc/ed.pla: 0610: def curshome#0
_C018 					; curshome()
; toolsrc/ed.pla: 0611:     cursrow  = 0
; toolsrc/ed.pla: 0612:     curscol  = 0
; toolsrc/ed.pla: 0613:     cursx    = flags & gutter
; toolsrc/ed.pla: 0614:     cursy    = 0
; toolsrc/ed.pla: 0615:     viewleft = 0
; toolsrc/ed.pla: 0616:     viewtop  = 0
; toolsrc/ed.pla: 0617:     drawscrn
; toolsrc/ed.pla: 0618: end
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D057+0
_F227 	!WORD	_D057+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D058+0
_F228 	!WORD	_D058+0		
	!BYTE	$68			; LAB	_D046+0
_F229 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$7A			; SAW	_D055+0
_F230 	!WORD	_D055+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D056+0
_F231 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D041+0
_F232 	!WORD	_D041+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D042+0
_F233 	!WORD	_D042+0		
	!BYTE	$54			; CALL	_C015
_F234 	!WORD	_C015		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0619: def cursend#0
_C019 					; cursend()
; toolsrc/ed.pla: 0620:     if numlines > scrnheight - 1
; toolsrc/ed.pla: 0621:         cursrow  = numlines - 1
; toolsrc/ed.pla: 0622:         cursy    = scrnheight - 1
; toolsrc/ed.pla: 0623:         viewtop  = cursrow - (scrnheight - 1)
; toolsrc/ed.pla: 0624:     else
	!BYTE	$6A			; LAW	_D047+0
_F235 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D038+0
_F236 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B150
	!WORD	_B150-*
	!BYTE	$6A			; LAW	_D047+0
_F237 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D057+0
_F238 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D038+0
_F239 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D056+0
_F240 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D057+0
_F241 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D038+0
_F242 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D042+0
_F243 	!WORD	_D042+0		
	!BYTE	$50			; BRNCH	_B151
	!WORD	_B151-*
_B150 
; toolsrc/ed.pla: 0625:         cursrow  = numlines - 1
; toolsrc/ed.pla: 0626:         cursy    = numlines - 1
; toolsrc/ed.pla: 0627:         viewtop  = 0
; toolsrc/ed.pla: 0628:     fin
	!BYTE	$6A			; LAW	_D047+0
_F244 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D057+0
_F245 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F246 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D056+0
_F247 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D042+0
_F248 	!WORD	_D042+0		
_B151 
; toolsrc/ed.pla: 0629:     curscol  = 0
; toolsrc/ed.pla: 0630:     cursx    = flags & gutter
; toolsrc/ed.pla: 0631:     viewleft = 0
; toolsrc/ed.pla: 0632:     drawscrn
; toolsrc/ed.pla: 0633: end
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D058+0
_F249 	!WORD	_D058+0		
	!BYTE	$68			; LAB	_D046+0
_F250 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$7A			; SAW	_D055+0
_F251 	!WORD	_D055+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D041+0
_F252 	!WORD	_D041+0		
	!BYTE	$54			; CALL	_C015
_F253 	!WORD	_C015		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0634: def cursup#0
_C020 					; cursup()
; toolsrc/ed.pla: 0635:     if cursrow > 0
; toolsrc/ed.pla: 0636:         cursrow--
	!BYTE	$6A			; LAW	_D057+0
_F254 	!WORD	_D057+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B152
	!WORD	_B152-*
	!BYTE	$6A			; LAW	_D057+0
_F255 	!WORD	_D057+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0637:         drawgutterrow(cursy)
; toolsrc/ed.pla: 0638:         if cursy > 0
; toolsrc/ed.pla: 0639:             cursy--
	!BYTE	$7A			; SAW	_D057+0
_F256 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D056+0
_F257 	!WORD	_D056+0		
	!BYTE	$54			; CALL	_C012
_F258 	!WORD	_C012		
	!BYTE	$6A			; LAW	_D056+0
_F259 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B154
	!WORD	_B154-*
	!BYTE	$6A			; LAW	_D056+0
_F260 	!WORD	_D056+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0640:             drawgutterrow(cursy)
; toolsrc/ed.pla: 0641:         else
	!BYTE	$7E			; DAW	_D056+0
_F261 	!WORD	_D056+0		
	!BYTE	$54			; CALL	_C012
_F262 	!WORD	_C012		
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
_B154 
; toolsrc/ed.pla: 0642:             viewtop = cursrow
; toolsrc/ed.pla: 0643:             if conio:textctrl(ctrlscroll, DOWN)
; toolsrc/ed.pla: 0644:                 drawrows(0, 0)
; toolsrc/ed.pla: 0645:             else
	!BYTE	$6A			; LAW	_D057+0
_F263 	!WORD	_D057+0		
	!BYTE	$7A			; SAW	_D042+0
_F264 	!WORD	_D042+0		
	!BYTE	$0A			; CN	5
	!BYTE	$20			; MINUS ONE
	!BYTE	$6A			; LAW	_X033+12
_F265 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B156
	!WORD	_B156-*
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C014
_F266 	!WORD	_C014		
	!BYTE	$50			; BRNCH	_B157
	!WORD	_B157-*
_B156 
; toolsrc/ed.pla: 0646:                 drawscrn
; toolsrc/ed.pla: 0647:             fin
	!BYTE	$54			; CALL	_C015
_F267 	!WORD	_C015		
_B157 
; toolsrc/ed.pla: 0648:         fin
_B155 
; toolsrc/ed.pla: 0649:     fin
_B152 
_B153 
; toolsrc/ed.pla: 0650: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0651: def pgup#0
_C021 					; pgup()
; toolsrc/ed.pla: 0652:     word scroll
					; scroll -> [0]
; toolsrc/ed.pla: 0653: 
; toolsrc/ed.pla: 0654:     scroll = viewtop
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0655:     if cursvpos(cursrow - pgjmp)
; toolsrc/ed.pla: 0656:         scroll = viewtop - scroll
; toolsrc/ed.pla: 0657:         if scroll
; toolsrc/ed.pla: 0658:             if conio:textctrl(ctrlscroll, scroll)
; toolsrc/ed.pla: 0659:                 drawrows(0, -scroll - 1)
; toolsrc/ed.pla: 0660:                 drawgutter
; toolsrc/ed.pla: 0661:             else
	!BYTE	$6A			; LAW	_D042+0
_F268 	!WORD	_D042+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D057+0
_F269 	!WORD	_D057+0		
	!BYTE	$3A,$10			; SUBI	16
	!BYTE	$54			; CALL	_C017
_F270 	!WORD	_C017		
	!BYTE	$4C			; BRFLS	_B158
	!WORD	_B158-*
	!BYTE	$6A			; LAW	_D042+0
_F271 	!WORD	_D042+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B160
	!WORD	_B160-*
	!BYTE	$0A			; CN	5
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X033+12
_F272 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B162
	!WORD	_B162-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$90			; NEG
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C014
_F273 	!WORD	_C014		
	!BYTE	$54			; CALL	_C013
_F274 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B163
	!WORD	_B163-*
_B162 
; toolsrc/ed.pla: 0662:                 drawscrn
; toolsrc/ed.pla: 0663:             fin
	!BYTE	$54			; CALL	_C015
_F275 	!WORD	_C015		
_B163 
; toolsrc/ed.pla: 0664:         fin
_B160 
_B161 
; toolsrc/ed.pla: 0665:     else
	!BYTE	$50			; BRNCH	_B159
	!WORD	_B159-*
_B158 
; toolsrc/ed.pla: 0666:         drawgutter
; toolsrc/ed.pla: 0667:     fin
	!BYTE	$54			; CALL	_C013
_F276 	!WORD	_C013		
_B159 
; toolsrc/ed.pla: 0668: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0669: def cursdown#0
_C022 					; cursdown()
; toolsrc/ed.pla: 0670:     if cursrow < numlines - 1
; toolsrc/ed.pla: 0671:         cursrow++
	!BYTE	$6A			; LAW	_D057+0
_F277 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F278 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B164
	!WORD	_B164-*
	!BYTE	$6A			; LAW	_D057+0
_F279 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0672:         drawgutterrow(cursy)
; toolsrc/ed.pla: 0673:         if cursy < scrnheight - 1
; toolsrc/ed.pla: 0674:             cursy++
	!BYTE	$7A			; SAW	_D057+0
_F280 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D056+0
_F281 	!WORD	_D056+0		
	!BYTE	$54			; CALL	_C012
_F282 	!WORD	_C012		
	!BYTE	$6A			; LAW	_D056+0
_F283 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D038+0
_F284 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B166
	!WORD	_B166-*
	!BYTE	$6A			; LAW	_D056+0
_F285 	!WORD	_D056+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0675:             drawgutterrow(cursy)
; toolsrc/ed.pla: 0676:         else
	!BYTE	$7E			; DAW	_D056+0
_F286 	!WORD	_D056+0		
	!BYTE	$54			; CALL	_C012
_F287 	!WORD	_C012		
	!BYTE	$50			; BRNCH	_B167
	!WORD	_B167-*
_B166 
; toolsrc/ed.pla: 0677:             viewtop = cursrow - (scrnheight - 1)
; toolsrc/ed.pla: 0678:             if conio:textctrl(ctrlscroll, UP)
; toolsrc/ed.pla: 0679:                 drawrows(scrnheight - 1, scrnheight - 1)
; toolsrc/ed.pla: 0680:             else
	!BYTE	$6A			; LAW	_D057+0
_F288 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D038+0
_F289 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D042+0
_F290 	!WORD	_D042+0		
	!BYTE	$0A			; CN	5
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+12
_F291 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B168
	!WORD	_B168-*
	!BYTE	$6A			; LAW	_D038+0
_F292 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_D038+0
_F293 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C014
_F294 	!WORD	_C014		
	!BYTE	$50			; BRNCH	_B169
	!WORD	_B169-*
_B168 
; toolsrc/ed.pla: 0681:                 drawscrn
; toolsrc/ed.pla: 0682:             fin
	!BYTE	$54			; CALL	_C015
_F295 	!WORD	_C015		
_B169 
; toolsrc/ed.pla: 0683:         fin
_B167 
; toolsrc/ed.pla: 0684:     fin
_B164 
_B165 
; toolsrc/ed.pla: 0685: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0686: def pgdown#0
_C023 					; pgdown()
; toolsrc/ed.pla: 0687:     word scroll
					; scroll -> [0]
; toolsrc/ed.pla: 0688: 
; toolsrc/ed.pla: 0689:     scroll = viewtop
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0690:     if cursvpos(cursrow + pgjmp)
; toolsrc/ed.pla: 0691:         scroll = viewtop - scroll
; toolsrc/ed.pla: 0692:         if scroll
; toolsrc/ed.pla: 0693:             if conio:textctrl(ctrlscroll, scroll)
; toolsrc/ed.pla: 0694:                 drawrows(scrnheight - scroll, scrnheight - 1)
; toolsrc/ed.pla: 0695:                 drawgutter
; toolsrc/ed.pla: 0696:             else
	!BYTE	$6A			; LAW	_D042+0
_F296 	!WORD	_D042+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D057+0
_F297 	!WORD	_D057+0		
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$54			; CALL	_C017
_F298 	!WORD	_C017		
	!BYTE	$4C			; BRFLS	_B170
	!WORD	_B170-*
	!BYTE	$6A			; LAW	_D042+0
_F299 	!WORD	_D042+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B172
	!WORD	_B172-*
	!BYTE	$0A			; CN	5
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X033+12
_F300 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B174
	!WORD	_B174-*
	!BYTE	$6A			; LAW	_D038+0
_F301 	!WORD	_D038+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D038+0
_F302 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C014
_F303 	!WORD	_C014		
	!BYTE	$54			; CALL	_C013
_F304 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B175
	!WORD	_B175-*
_B174 
; toolsrc/ed.pla: 0697:                 drawscrn
; toolsrc/ed.pla: 0698:             fin
	!BYTE	$54			; CALL	_C015
_F305 	!WORD	_C015		
_B175 
; toolsrc/ed.pla: 0699:         fin
_B172 
_B173 
; toolsrc/ed.pla: 0700:     else
	!BYTE	$50			; BRNCH	_B171
	!WORD	_B171-*
_B170 
; toolsrc/ed.pla: 0701:         drawgutter
; toolsrc/ed.pla: 0702:     fin
	!BYTE	$54			; CALL	_C013
_F306 	!WORD	_C013		
_B171 
; toolsrc/ed.pla: 0703: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0704: def cursleft#0
_C024 					; cursleft()
; toolsrc/ed.pla: 0705:     if curshpos(curscol - 1); drawscrn; fin
	!BYTE	$6A			; LAW	_D058+0
_F307 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F308 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B176
	!WORD	_B176-*
	!BYTE	$54			; CALL	_C015
_F309 	!WORD	_C015		
_B176 
_B177 
; toolsrc/ed.pla: 0706: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0707: def pgleft#0
_C025 					; pgleft()
; toolsrc/ed.pla: 0708:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0709: 
; toolsrc/ed.pla: 0710:     strptr = txtlinbuf=>[cursrow]
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0711:     if curscol > ^strptr
; toolsrc/ed.pla: 0712:         i = ^strptr
; toolsrc/ed.pla: 0713:     else
	!BYTE	$6A			; LAW	_D053+0
_F310 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F311 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D058+0
_F312 	!WORD	_D058+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B178
	!WORD	_B178-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B179
	!WORD	_B179-*
_B178 
; toolsrc/ed.pla: 0714:         for i = 1 to ^strptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B180
	!WORD	_B180-*
_B181 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0715:             if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 0716:                 break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B183
	!WORD	_B183-*
	!BYTE	$50			; BRNCH	_B180
	!WORD	_B180-*
; toolsrc/ed.pla: 0717:             fin
_B183 
_B184 
; toolsrc/ed.pla: 0718:         next
_B182 
	!BYTE	$A4			; INCBRLE	_B181
	!WORD	_B181-*
_B180 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0719:         i--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0720:         if i >= curscol
; toolsrc/ed.pla: 0721:             i = 0
; toolsrc/ed.pla: 0722:         fin
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$6A			; LAW	_D058+0
_F313 	!WORD	_D058+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B185
	!WORD	_B185-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B185 
_B186 
; toolsrc/ed.pla: 0723:     fin
_B179 
; toolsrc/ed.pla: 0724:     if curshpos(i)
; toolsrc/ed.pla: 0725:         drawscrn
; toolsrc/ed.pla: 0726:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C016
_F314 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B187
	!WORD	_B187-*
	!BYTE	$54			; CALL	_C015
_F315 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B188
	!WORD	_B188-*
_B187 
; toolsrc/ed.pla: 0727:         drawgutter
; toolsrc/ed.pla: 0728:     fin
	!BYTE	$54			; CALL	_C013
_F316 	!WORD	_C013		
_B188 
; toolsrc/ed.pla: 0729: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0730: def cursright#0
_C026 					; cursright()
; toolsrc/ed.pla: 0731:     if curshpos(curscol + 1); drawscrn; fin
	!BYTE	$6A			; LAW	_D058+0
_F317 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C016
_F318 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B189
	!WORD	_B189-*
	!BYTE	$54			; CALL	_C015
_F319 	!WORD	_C015		
_B189 
_B190 
; toolsrc/ed.pla: 0732: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0733: def pgright#0
_C027 					; pgright()
; toolsrc/ed.pla: 0734:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0735: 
; toolsrc/ed.pla: 0736:     strptr = txtlinbuf=>[cursrow]
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0737:     if curscol >= ^strptr
; toolsrc/ed.pla: 0738:         i = curscol + 8
; toolsrc/ed.pla: 0739:     else
	!BYTE	$6A			; LAW	_D053+0
_F320 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F321 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D058+0
_F322 	!WORD	_D058+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B191
	!WORD	_B191-*
	!BYTE	$6A			; LAW	_D058+0
_F323 	!WORD	_D058+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
_B191 
; toolsrc/ed.pla: 0740:         for i = 1 to ^strptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B193
	!WORD	_B193-*
_B194 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0741:             if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 0742:                 break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B196
	!WORD	_B196-*
	!BYTE	$50			; BRNCH	_B193
	!WORD	_B193-*
; toolsrc/ed.pla: 0743:             fin
_B196 
_B197 
; toolsrc/ed.pla: 0744:         next
_B195 
	!BYTE	$A4			; INCBRLE	_B194
	!WORD	_B194-*
_B193 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0745:         i--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0746:         if curscol >= i
; toolsrc/ed.pla: 0747:             i = ^strptr
; toolsrc/ed.pla: 0748:         fin
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D058+0
_F324 	!WORD	_D058+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B198
	!WORD	_B198-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
_B198 
_B199 
; toolsrc/ed.pla: 0749:     fin
_B192 
; toolsrc/ed.pla: 0750:     if curshpos(i)
; toolsrc/ed.pla: 0751:         drawscrn
; toolsrc/ed.pla: 0752:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C016
_F325 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B200
	!WORD	_B200-*
	!BYTE	$54			; CALL	_C015
_F326 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B201
	!WORD	_B201-*
_B200 
; toolsrc/ed.pla: 0753:         drawgutter
; toolsrc/ed.pla: 0754:     fin
	!BYTE	$54			; CALL	_C013
_F327 	!WORD	_C013		
_B201 
; toolsrc/ed.pla: 0755: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0756: //
; toolsrc/ed.pla: 0757: // Find string in text
; toolsrc/ed.pla: 0758: //
; toolsrc/ed.pla: 0759: def findline(strptr, start)#1
					; strptr -> [0]
					; start -> [2]
_C028 					; findline()
; toolsrc/ed.pla: 0760:     byte scan, i, upstr[MAXLNLEN+1]
					; scan -> [4]
					; i -> [5]
					; upstr -> [6]
; toolsrc/ed.pla: 0761: 
; toolsrc/ed.pla: 0762:     if ^strptr >= findstr
	!BYTE	$58,$86,$02		; ENTER	134,2
; toolsrc/ed.pla: 0763:         lnupcpy(@upstr, strptr)
; toolsrc/ed.pla: 0764:         for scan = start to upstr - findstr + 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D044+0
_F328 	!WORD	_D044+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B202
	!WORD	_B202-*
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A001
_F329 	!WORD	_A001		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$68			; LAB	_D044+0
_F330 	!WORD	_D044+0		
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$A0			; BRGT	_B204
	!WORD	_B204-*
_B205 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0765:             if upstr[scan] == findstr[1]
; toolsrc/ed.pla: 0766:                 for i = 2 to findstr
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D044+1
_F331 	!WORD	_D044+1		
	!BYTE	$24			; BRNE	_B207
	!WORD	_B207-*
	!BYTE	$68			; LAB	_D044+0
_F332 	!WORD	_D044+0		
	!BYTE	$04			; CN	2
	!BYTE	$A0			; BRGT	_B209
	!WORD	_B209-*
_B210 
	!BYTE	$6C,$05			; DLB	[5]
; toolsrc/ed.pla: 0767:                     if upstr[scan + i - 1] <> findstr[i]
; toolsrc/ed.pla: 0768:                         break
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D044+0
_F333 	!WORD	_D044+0		
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B212
	!WORD	_B212-*
	!BYTE	$50			; BRNCH	_B209
	!WORD	_B209-*
; toolsrc/ed.pla: 0769:                     fin
_B212 
_B213 
; toolsrc/ed.pla: 0770:                 next
_B211 
	!BYTE	$A4			; INCBRLE	_B210
	!WORD	_B210-*
_B209 
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0771:                 if i > findstr
; toolsrc/ed.pla: 0772:                     curshpos(scan - 1)
; toolsrc/ed.pla: 0773:                     return TRUE
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$68			; LAB	_D044+0
_F334 	!WORD	_D044+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B214
	!WORD	_B214-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F335 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$86			; LEAVE	134
; toolsrc/ed.pla: 0774:                 fin
_B214 
_B215 
; toolsrc/ed.pla: 0775:             fin
_B207 
_B208 
; toolsrc/ed.pla: 0776:         next
_B206 
	!BYTE	$A4			; INCBRLE	_B205
	!WORD	_B205-*
_B204 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0777:     fin
_B202 
_B203 
; toolsrc/ed.pla: 0778:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$86			; LEAVE	134
; toolsrc/ed.pla: 0779: end
; toolsrc/ed.pla: 0780: def findtxt#0
_C029 					; findtxt()
; toolsrc/ed.pla: 0781:     word f
					; f -> [0]
; toolsrc/ed.pla: 0782: 
; toolsrc/ed.pla: 0783:     //
; toolsrc/ed.pla: 0784:     // Search from current pos to end
; toolsrc/ed.pla: 0785:     //
; toolsrc/ed.pla: 0786:     if findline(txtlinbuf=>[cursrow], curscol + 2)
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0787:         return
	!BYTE	$6A			; LAW	_D053+0
_F336 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F337 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D058+0
_F338 	!WORD	_D058+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$54			; CALL	_C028
_F339 	!WORD	_C028		
	!BYTE	$4C			; BRFLS	_B216
	!WORD	_B216-*
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0788:     fin
_B216 
_B217 
; toolsrc/ed.pla: 0789:     for f = cursrow + 1 to numlines - 1
	!BYTE	$6A			; LAW	_D047+0
_F340 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_D057+0
_F341 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B218
	!WORD	_B218-*
_B219 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0790:         if findline(txtlinbuf=>[f], 1)
; toolsrc/ed.pla: 0791:             cursvpos(f)
; toolsrc/ed.pla: 0792:             return
	!BYTE	$6A			; LAW	_D053+0
_F342 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C028
_F343 	!WORD	_C028		
	!BYTE	$4C			; BRFLS	_B221
	!WORD	_B221-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C017
_F344 	!WORD	_C017		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0793:         fin
_B221 
_B222 
; toolsrc/ed.pla: 0794:     next
_B220 
	!BYTE	$A4			; INCBRLE	_B219
	!WORD	_B219-*
_B218 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0795:     //
; toolsrc/ed.pla: 0796:     // Search from beginning to current pos
; toolsrc/ed.pla: 0797:     //
; toolsrc/ed.pla: 0798:     for f = 0 to cursrow
	!BYTE	$6A			; LAW	_D057+0
_F345 	!WORD	_D057+0		
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B223
	!WORD	_B223-*
_B224 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0799:         if findline(txtlinbuf=>[f], 1)
; toolsrc/ed.pla: 0800:             cursvpos(f)
; toolsrc/ed.pla: 0801:             return
	!BYTE	$6A			; LAW	_D053+0
_F346 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C028
_F347 	!WORD	_C028		
	!BYTE	$4C			; BRFLS	_B226
	!WORD	_B226-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C017
_F348 	!WORD	_C017		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0802:         fin
_B226 
_B227 
; toolsrc/ed.pla: 0803:     next
_B225 
	!BYTE	$A4			; INCBRLE	_B224
	!WORD	_B224-*
_B223 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0804:     bell
; toolsrc/ed.pla: 0805: end
	!BYTE	$54			; CALL	_C000
_F349 	!WORD	_C000		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0806: //
; toolsrc/ed.pla: 0807: // Printer routines
; toolsrc/ed.pla: 0808: //
; toolsrc/ed.pla: 0809: def printtxt(slot)#0
					; slot -> [0]
_C030 					; printtxt()
; toolsrc/ed.pla: 0810:     word i, scrncsw
					; i -> [2]
					; scrncsw -> [4]
; toolsrc/ed.pla: 0811: 
; toolsrc/ed.pla: 0812:     scrncsw = *CSW
	!BYTE	$58,$06,$01		; ENTER	6,1
; toolsrc/ed.pla: 0813:      *CSW = $C000 | (slot << 8)
; toolsrc/ed.pla: 0814:     for i = 0 to numlines - 1
	!BYTE	$6A,$36,$00		; LAW	54
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$7A,$36,$00		; SAW	54
	!BYTE	$6A			; LAW	_D047+0
_F350 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B228
	!WORD	_B228-*
_B229 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/ed.pla: 0815:         puts(txtlinbuf=>[i]); putln
; toolsrc/ed.pla: 0816:     next
	!BYTE	$6A			; LAW	_D053+0
_F351 	!WORD	_D053+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X004
_F352 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F353 	!WORD	0		
_B230 
	!BYTE	$A4			; INCBRLE	_B229
	!WORD	_B229-*
_B228 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0817:     *CSW = scrncsw
; toolsrc/ed.pla: 0818: end
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A,$36,$00		; SAW	54
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0819: def freesel#0
_C031 					; freesel()
; toolsrc/ed.pla: 0820:     word i
					; i -> [0]
; toolsrc/ed.pla: 0821: 
; toolsrc/ed.pla: 0822:     if numcliplines
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0823:         for i = 0 to numcliplines - 1
	!BYTE	$6A			; LAW	_D048+0
_F354 	!WORD	_D048+0		
	!BYTE	$4C			; BRFLS	_B231
	!WORD	_B231-*
	!BYTE	$6A			; LAW	_D048+0
_F355 	!WORD	_D048+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B233
	!WORD	_B233-*
_B234 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0824:             if cliplinbuf=>[i] <> @nullstr
; toolsrc/ed.pla: 0825:                 delstr(cliplinbuf=>[i])
; toolsrc/ed.pla: 0826:                 cliplinbuf=>[i] = @nullstr
; toolsrc/ed.pla: 0827:             fin
	!BYTE	$6A			; LAW	_D054+0
_F356 	!WORD	_D054+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D043+0
_F357 	!WORD	_D043+0		
	!BYTE	$22			; BREQ	_B236
	!WORD	_B236-*
	!BYTE	$6A			; LAW	_D054+0
_F358 	!WORD	_D054+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F359 	!WORD	_C003		
	!BYTE	$26			; LA	_D043+0
_F360 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D054+0
_F361 	!WORD	_D054+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
_B236 
_B237 
; toolsrc/ed.pla: 0828:         next
_B235 
	!BYTE	$A4			; INCBRLE	_B234
	!WORD	_B234-*
_B233 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0829:         numcliplines = 0
; toolsrc/ed.pla: 0830:     fin
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D048+0
_F362 	!WORD	_D048+0		
_B231 
_B232 
; toolsrc/ed.pla: 0831: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0832: def selrange#2
_C032 					; selrange()
; toolsrc/ed.pla: 0833:     word first, last
					; first -> [0]
					; last -> [2]
; toolsrc/ed.pla: 0834: 
; toolsrc/ed.pla: 0835:     if flags & selection
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0836:         if cursrow > selrow
; toolsrc/ed.pla: 0837:             first, last = selrow, cursrow
; toolsrc/ed.pla: 0838:         else
	!BYTE	$68			; LAB	_D046+0
_F363 	!WORD	_D046+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B238
	!WORD	_B238-*
	!BYTE	$6A			; LAW	_D057+0
_F364 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D059+0
_F365 	!WORD	_D059+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B240
	!WORD	_B240-*
	!BYTE	$6A			; LAW	_D059+0
_F366 	!WORD	_D059+0		
	!BYTE	$6A			; LAW	_D057+0
_F367 	!WORD	_D057+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B241
	!WORD	_B241-*
_B240 
; toolsrc/ed.pla: 0839:             first, last = cursrow, selrow
; toolsrc/ed.pla: 0840:         fin
	!BYTE	$6A			; LAW	_D057+0
_F368 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D059+0
_F369 	!WORD	_D059+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
_B241 
; toolsrc/ed.pla: 0841:     else
	!BYTE	$50			; BRNCH	_B239
	!WORD	_B239-*
_B238 
; toolsrc/ed.pla: 0842:         first = cursrow
; toolsrc/ed.pla: 0843:         last = first
; toolsrc/ed.pla: 0844:     fin
	!BYTE	$6A			; LAW	_D057+0
_F370 	!WORD	_D057+0		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$02			; SLW	[2]
_B239 
; toolsrc/ed.pla: 0845:     return first, last
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0846: end
; toolsrc/ed.pla: 0847: def beginsel#0
_C033 					; beginsel()
; toolsrc/ed.pla: 0848:     flags  = flags ^ selection
; toolsrc/ed.pla: 0849:     selrow = cursrow
; toolsrc/ed.pla: 0850:     drawgutter
; toolsrc/ed.pla: 0851: end
	!BYTE	$68			; LAB	_D046+0
_F371 	!WORD	_D046+0		
	!BYTE	$10			; CN	8
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D046+0
_F372 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_D057+0
_F373 	!WORD	_D057+0		
	!BYTE	$7A			; SAW	_D059+0
_F374 	!WORD	_D059+0		
	!BYTE	$54			; CALL	_C013
_F375 	!WORD	_C013		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0852: def copysel#0
_C034 					; copysel()
; toolsrc/ed.pla: 0853:     word firstsel, lastsel
					; firstsel -> [0]
					; lastsel -> [2]
; toolsrc/ed.pla: 0854: 
; toolsrc/ed.pla: 0855:     freesel
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0856:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 0857:     if lastsel - firstsel < MAXCLIPLINES
; toolsrc/ed.pla: 0858:         for numcliplines = 0 to lastsel - firstsel
	!BYTE	$54			; CALL	_C031
_F376 	!WORD	_C031		
	!BYTE	$54			; CALL	_C032
_F377 	!WORD	_C032		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B242
	!WORD	_B242-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B244
	!WORD	_B244-*
_B245 
	!BYTE	$7E			; DAW	_D048+0
_F378 	!WORD	_D048+0		
; toolsrc/ed.pla: 0859:             cliplinbuf=>[numcliplines] = newstr(txtlinbuf=>[firstsel + numcliplines])
; toolsrc/ed.pla: 0860:         next
	!BYTE	$6A			; LAW	_D053+0
_F379 	!WORD	_D053+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B6			; ADDAW	_D048+0
_F380 	!WORD	_D048+0		
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F381 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D054+0
_F382 	!WORD	_D054+0		
	!BYTE	$BE			; IDXAW	_D048+0
_F383 	!WORD	_D048+0		
	!BYTE	$72			; SW
_B246 
	!BYTE	$A4			; INCBRLE	_B245
	!WORD	_B245-*
_B244 
	!BYTE	$7A			; SAW	_D048+0
_F384 	!WORD	_D048+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0861:         flags = flags & ~selection
; toolsrc/ed.pla: 0862:         drawgutter
; toolsrc/ed.pla: 0863:     else
	!BYTE	$68			; LAB	_D046+0
_F385 	!WORD	_D046+0		
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D046+0
_F386 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_C013
_F387 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B243
	!WORD	_B243-*
_B242 
; toolsrc/ed.pla: 0864:         bell
; toolsrc/ed.pla: 0865:     fin
	!BYTE	$54			; CALL	_C000
_F388 	!WORD	_C000		
_B243 
; toolsrc/ed.pla: 0866: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0867: def cutsel#0
_C035 					; cutsel()
; toolsrc/ed.pla: 0868:     word firstsel, lastsel
					; firstsel -> [0]
					; lastsel -> [2]
; toolsrc/ed.pla: 0869: 
; toolsrc/ed.pla: 0870:     freesel
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0871:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 0872:     if lastsel - firstsel < MAXCLIPLINES
; toolsrc/ed.pla: 0873:         for numcliplines = 0 to lastsel - firstsel
	!BYTE	$54			; CALL	_C031
_F389 	!WORD	_C031		
	!BYTE	$54			; CALL	_C032
_F390 	!WORD	_C032		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B247
	!WORD	_B247-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B249
	!WORD	_B249-*
_B250 
	!BYTE	$7E			; DAW	_D048+0
_F391 	!WORD	_D048+0		
; toolsrc/ed.pla: 0874:             cliplinbuf=>[numcliplines] = txtlinbuf=>[firstsel + numcliplines]
; toolsrc/ed.pla: 0875:         next
	!BYTE	$6A			; LAW	_D053+0
_F392 	!WORD	_D053+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B6			; ADDAW	_D048+0
_F393 	!WORD	_D048+0		
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D054+0
_F394 	!WORD	_D054+0		
	!BYTE	$BE			; IDXAW	_D048+0
_F395 	!WORD	_D048+0		
	!BYTE	$72			; SW
_B251 
	!BYTE	$A4			; INCBRLE	_B250
	!WORD	_B250-*
_B249 
	!BYTE	$7A			; SAW	_D048+0
_F396 	!WORD	_D048+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0876:         memcpy(@txtlinbuf=>[firstsel], \
; toolsrc/ed.pla: 0877:         memcpy(@txtlinbuf=>[firstsel],                @txtlinbuf=>[lastsel + 1], \
; toolsrc/ed.pla: 0878:         memcpy(@txtlinbuf=>[firstsel],                @txtlinbuf=>[lastsel + 1],                (numlines - lastsel + 1) * 2)
; toolsrc/ed.pla: 0879:         numlines = numlines - numcliplines
; toolsrc/ed.pla: 0880:         for lastsel = numlines to numlines + numcliplines
	!BYTE	$6A			; LAW	_D053+0
_F397 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$6A			; LAW	_D053+0
_F398 	!WORD	_D053+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D047+0
_F399 	!WORD	_D047+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F400 	!WORD	0		
	!BYTE	$6A			; LAW	_D047+0
_F401 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D048+0
_F402 	!WORD	_D048+0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D047+0
_F403 	!WORD	_D047+0		
	!BYTE	$B6			; ADDAW	_D048+0
_F404 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D047+0
_F405 	!WORD	_D047+0		
	!BYTE	$A0			; BRGT	_B252
	!WORD	_B252-*
_B253 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/ed.pla: 0881:             txtlinbuf=>[lastsel] = @nullstr
; toolsrc/ed.pla: 0882:         next
	!BYTE	$26			; LA	_D043+0
_F406 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D053+0
_F407 	!WORD	_D053+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$72			; SW
_B254 
	!BYTE	$A4			; INCBRLE	_B253
	!WORD	_B253-*
_B252 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0883:         cursrow  = firstsel
; toolsrc/ed.pla: 0884:         if cursrow >= numlines
; toolsrc/ed.pla: 0885:             cursrow = numlines - 1
; toolsrc/ed.pla: 0886:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D057+0
_F408 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F409 	!WORD	_D047+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B255
	!WORD	_B255-*
	!BYTE	$6A			; LAW	_D047+0
_F410 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D057+0
_F411 	!WORD	_D057+0		
_B255 
_B256 
; toolsrc/ed.pla: 0887:         if cursrow < viewtop
; toolsrc/ed.pla: 0888:             viewtop = cursrow
; toolsrc/ed.pla: 0889:         fin
	!BYTE	$6A			; LAW	_D057+0
_F412 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D042+0
_F413 	!WORD	_D042+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B257
	!WORD	_B257-*
	!BYTE	$6A			; LAW	_D057+0
_F414 	!WORD	_D057+0		
	!BYTE	$7A			; SAW	_D042+0
_F415 	!WORD	_D042+0		
_B257 
_B258 
; toolsrc/ed.pla: 0890:         cursy = cursrow - viewtop
; toolsrc/ed.pla: 0891:         flags = flags | changed
; toolsrc/ed.pla: 0892:         flags = flags & ~selection
; toolsrc/ed.pla: 0893:         drawscrn
; toolsrc/ed.pla: 0894:     else
	!BYTE	$6A			; LAW	_D057+0
_F416 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D042+0
_F417 	!WORD	_D042+0		
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D056+0
_F418 	!WORD	_D056+0		
	!BYTE	$68			; LAB	_D046+0
_F419 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$7C			; DAB	_D046+0
_F420 	!WORD	_D046+0		
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D046+0
_F421 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_C015
_F422 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B248
	!WORD	_B248-*
_B247 
; toolsrc/ed.pla: 0895:         bell
; toolsrc/ed.pla: 0896:     fin
	!BYTE	$54			; CALL	_C000
_F423 	!WORD	_C000		
_B248 
; toolsrc/ed.pla: 0897: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0898: def pastesel#0
_C036 					; pastesel()
; toolsrc/ed.pla: 0899:     word p
					; p -> [0]
; toolsrc/ed.pla: 0900: 
; toolsrc/ed.pla: 0901:     if numcliplines and numcliplines + numlines < MAXLINES
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0902:         memcpy(@txtlinbuf=>[cursrow + numcliplines], \
; toolsrc/ed.pla: 0903:         memcpy(@txtlinbuf=>[cursrow + numcliplines],                @txtlinbuf=>[cursrow], \
; toolsrc/ed.pla: 0904:         memcpy(@txtlinbuf=>[cursrow + numcliplines],                @txtlinbuf=>[cursrow],                (numlines - cursrow) * 2)
; toolsrc/ed.pla: 0905:         for p = 0 to numcliplines - 1
	!BYTE	$6A			; LAW	_D048+0
_F424 	!WORD	_D048+0		
	!BYTE	$AC			; BRAND	_B259
	!WORD	_B259-*
	!BYTE	$6A			; LAW	_D048+0
_F425 	!WORD	_D048+0		
	!BYTE	$B6			; ADDAW	_D047+0
_F426 	!WORD	_D047+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
_B259 
	!BYTE	$4C			; BRFLS	_B260
	!WORD	_B260-*
	!BYTE	$6A			; LAW	_D053+0
_F427 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F428 	!WORD	_D057+0		
	!BYTE	$B6			; ADDAW	_D048+0
_F429 	!WORD	_D048+0		
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D053+0
_F430 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F431 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F432 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D057+0
_F433 	!WORD	_D057+0		
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F434 	!WORD	0		
	!BYTE	$6A			; LAW	_D048+0
_F435 	!WORD	_D048+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B262
	!WORD	_B262-*
_B263 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0906:             txtlinbuf=>[cursrow + p] = newstr(cliplinbuf=>[p])
; toolsrc/ed.pla: 0907:         next
	!BYTE	$6A			; LAW	_D054+0
_F436 	!WORD	_D054+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F437 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F438 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F439 	!WORD	_D057+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
_B264 
	!BYTE	$A4			; INCBRLE	_B263
	!WORD	_B263-*
_B262 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0908:         numlines = numlines + numcliplines
; toolsrc/ed.pla: 0909:         flags = flags | changed
; toolsrc/ed.pla: 0910:         drawscrn
; toolsrc/ed.pla: 0911:     else
	!BYTE	$6A			; LAW	_D047+0
_F440 	!WORD	_D047+0		
	!BYTE	$B6			; ADDAW	_D048+0
_F441 	!WORD	_D048+0		
	!BYTE	$7A			; SAW	_D047+0
_F442 	!WORD	_D047+0		
	!BYTE	$68			; LAB	_D046+0
_F443 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F444 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_C015
_F445 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B261
	!WORD	_B261-*
_B260 
; toolsrc/ed.pla: 0912:         bell
; toolsrc/ed.pla: 0913:     fin
	!BYTE	$54			; CALL	_C000
_F446 	!WORD	_C000		
_B261 
; toolsrc/ed.pla: 0914: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0915: def indentsel#0
_C037 					; indentsel()
; toolsrc/ed.pla: 0916:     byte indentstr[MAXLNLEN+1], j, l
					; indentstr -> [0]
					; j -> [128]
					; l -> [129]
; toolsrc/ed.pla: 0917:     word firstsel, lastsel, i
					; firstsel -> [130]
					; lastsel -> [132]
					; i -> [134]
; toolsrc/ed.pla: 0918: 
; toolsrc/ed.pla: 0919:     freesel
	!BYTE	$58,$88,$00		; ENTER	136,0
; toolsrc/ed.pla: 0920:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 0921:     for i = firstsel to lastsel
	!BYTE	$54			; CALL	_C031
_F447 	!WORD	_C031		
	!BYTE	$54			; CALL	_C032
_F448 	!WORD	_C032		
	!BYTE	$76,$84			; SLW	[132]
	!BYTE	$76,$82			; SLW	[130]
	!BYTE	$66,$84			; LLW	[132]
	!BYTE	$66,$82			; LLW	[130]
	!BYTE	$A0			; BRGT	_B265
	!WORD	_B265-*
_B266 
	!BYTE	$6E,$86			; DLW	[134]
; toolsrc/ed.pla: 0922:         l = ^(txtlinbuf=>[i])
; toolsrc/ed.pla: 0923:         if l and l < MAXLNLEN - 2
; toolsrc/ed.pla: 0924:             memcpy(@indentstr + 3, txtlinbuf=>[i] + 1, l)
; toolsrc/ed.pla: 0925:             indentstr[0] = l + 2
; toolsrc/ed.pla: 0926:             indentstr[1] = keyspace
; toolsrc/ed.pla: 0927:             indentstr[2] = keyspace
; toolsrc/ed.pla: 0928:             //
; toolsrc/ed.pla: 0929:             // Align indent
; toolsrc/ed.pla: 0930:             //
; toolsrc/ed.pla: 0931:             for j = 3 to indentstr[0]
	!BYTE	$6A			; LAW	_D053+0
_F449 	!WORD	_D053+0		
	!BYTE	$BA,$86			; IDXLW	[134]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$6C,$81			; DLB	[129]
	!BYTE	$AC			; BRAND	_B268
	!WORD	_B268-*
	!BYTE	$64,$81			; LLB	[129]
	!BYTE	$2A,$7D			; CB	125
	!BYTE	$46			; ISLT
_B268 
	!BYTE	$4C			; BRFLS	_B269
	!WORD	_B269-*
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$6A			; LAW	_D053+0
_F450 	!WORD	_D053+0		
	!BYTE	$BA,$86			; IDXLW	[134]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$81			; LLB	[129]
	!BYTE	$54			; CALL	_X018
_F451 	!WORD	0		
	!BYTE	$64,$81			; LLB	[129]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$06			; CN	3
	!BYTE	$A0			; BRGT	_B271
	!WORD	_B271-*
_B272 
	!BYTE	$6C,$80			; DLB	[128]
; toolsrc/ed.pla: 0932:                 if indentstr[j] <> keyspace
; toolsrc/ed.pla: 0933:                     if j & 1 == 0
; toolsrc/ed.pla: 0934:                         indentstr[0]--
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$B0,$80			; ADDLB	[128]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B274
	!WORD	_B274-*
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4E			; BRTRU	_B276
	!WORD	_B276-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0935:                         memcpy(@indentstr + 1, @indentstr + 2, indentstr[0])
; toolsrc/ed.pla: 0936:                     fin
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F452 	!WORD	0		
_B276 
_B277 
; toolsrc/ed.pla: 0937:                     break
	!BYTE	$50			; BRNCH	_B271
	!WORD	_B271-*
; toolsrc/ed.pla: 0938:                 fin
_B274 
_B275 
; toolsrc/ed.pla: 0939:             next
_B273 
	!BYTE	$A4			; INCBRLE	_B272
	!WORD	_B272-*
_B271 
	!BYTE	$74,$80			; SLB	[128]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0940:             delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 0941:             txtlinbuf=>[i] = newstr(@indentstr)
; toolsrc/ed.pla: 0942:             flags = flags | changed
; toolsrc/ed.pla: 0943:         fin
	!BYTE	$6A			; LAW	_D053+0
_F453 	!WORD	_D053+0		
	!BYTE	$BA,$86			; IDXLW	[134]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F454 	!WORD	_C003		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C004
_F455 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F456 	!WORD	_D053+0		
	!BYTE	$BA,$86			; IDXLW	[134]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D046+0
_F457 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F458 	!WORD	_D046+0		
_B269 
_B270 
; toolsrc/ed.pla: 0944:     next
_B267 
	!BYTE	$A4			; INCBRLE	_B266
	!WORD	_B266-*
_B265 
	!BYTE	$76,$86			; SLW	[134]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0945:     drawscrn
; toolsrc/ed.pla: 0946: end
	!BYTE	$54			; CALL	_C015
_F459 	!WORD	_C015		
	!BYTE	$5A,$88			; LEAVE	136
; toolsrc/ed.pla: 0947: def undentsel#0
_C038 					; undentsel()
; toolsrc/ed.pla: 0948:     byte undentstr[MAXLNLEN+1], l
					; undentstr -> [0]
					; l -> [128]
; toolsrc/ed.pla: 0949:     word firstsel, lastsel, i
					; firstsel -> [129]
					; lastsel -> [131]
					; i -> [133]
; toolsrc/ed.pla: 0950: 
; toolsrc/ed.pla: 0951:     freesel
	!BYTE	$58,$87,$00		; ENTER	135,0
; toolsrc/ed.pla: 0952:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 0953:     for i = firstsel to lastsel
	!BYTE	$54			; CALL	_C031
_F460 	!WORD	_C031		
	!BYTE	$54			; CALL	_C032
_F461 	!WORD	_C032		
	!BYTE	$76,$83			; SLW	[131]
	!BYTE	$76,$81			; SLW	[129]
	!BYTE	$66,$83			; LLW	[131]
	!BYTE	$66,$81			; LLW	[129]
	!BYTE	$A0			; BRGT	_B278
	!WORD	_B278-*
_B279 
	!BYTE	$6E,$85			; DLW	[133]
; toolsrc/ed.pla: 0954:         l = ^(txtlinbuf=>[i])
; toolsrc/ed.pla: 0955:         if l
; toolsrc/ed.pla: 0956:             memcpy(@undentstr + 1, txtlinbuf=>[i] + 1, l)
; toolsrc/ed.pla: 0957:             if undentstr[1] == keyspace
; toolsrc/ed.pla: 0958:                 memcpy(@undentstr + 1, @undentstr + 2, l - 1)
; toolsrc/ed.pla: 0959:                 l--
	!BYTE	$6A			; LAW	_D053+0
_F462 	!WORD	_D053+0		
	!BYTE	$BA,$85			; IDXLW	[133]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$6C,$80			; DLB	[128]
	!BYTE	$4C			; BRFLS	_B281
	!WORD	_B281-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D053+0
_F463 	!WORD	_D053+0		
	!BYTE	$BA,$85			; IDXLW	[133]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$54			; CALL	_X018
_F464 	!WORD	0		
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B283
	!WORD	_B283-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_X018
_F465 	!WORD	0		
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0960:                 if l and undentstr[1] == keyspace
; toolsrc/ed.pla: 0961:                     memcpy(@undentstr + 1, @undentstr + 2, l - 1)
; toolsrc/ed.pla: 0962:                     l--
	!BYTE	$6C,$80			; DLB	[128]
	!BYTE	$AC			; BRAND	_B285
	!WORD	_B285-*
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$40			; ISEQ
_B285 
	!BYTE	$4C			; BRFLS	_B286
	!WORD	_B286-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_X018
_F466 	!WORD	0		
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0963:                 fin
	!BYTE	$74,$80			; SLB	[128]
_B286 
_B287 
; toolsrc/ed.pla: 0964:                 undentstr[0] = l
; toolsrc/ed.pla: 0965:                 delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 0966:                 txtlinbuf=>[i] = newstr(@undentstr)
; toolsrc/ed.pla: 0967:                 flags = flags | changed
; toolsrc/ed.pla: 0968:             fin
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D053+0
_F467 	!WORD	_D053+0		
	!BYTE	$BA,$85			; IDXLW	[133]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F468 	!WORD	_C003		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C004
_F469 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F470 	!WORD	_D053+0		
	!BYTE	$BA,$85			; IDXLW	[133]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D046+0
_F471 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F472 	!WORD	_D046+0		
_B283 
_B284 
; toolsrc/ed.pla: 0969:         fin
_B281 
_B282 
; toolsrc/ed.pla: 0970:     next
_B280 
	!BYTE	$A4			; INCBRLE	_B279
	!WORD	_B279-*
_B278 
	!BYTE	$76,$85			; SLW	[133]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0971:     drawscrn
; toolsrc/ed.pla: 0972: end
	!BYTE	$54			; CALL	_C015
_F473 	!WORD	_C015		
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/ed.pla: 0973: def autoindent(strptr)#0
					; strptr -> [0]
_C039 					; autoindent()
; toolsrc/ed.pla: 0974:     byte i
					; i -> [2]
; toolsrc/ed.pla: 0975: 
; toolsrc/ed.pla: 0976:     for i = 1 to ^strptr
	!BYTE	$58,$03,$01		; ENTER	3,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B288
	!WORD	_B288-*
_B289 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/ed.pla: 0977:         if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 0978:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B291
	!WORD	_B291-*
	!BYTE	$50			; BRNCH	_B288
	!WORD	_B288-*
; toolsrc/ed.pla: 0979:         fin
_B291 
_B292 
; toolsrc/ed.pla: 0980:     next
_B290 
	!BYTE	$A4			; INCBRLE	_B289
	!WORD	_B289-*
_B288 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0981:     curshpos(i - 1)
; toolsrc/ed.pla: 0982: end
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F474 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 0983: def openline(row)
					; row -> [0]
_C040 					; openline()
; toolsrc/ed.pla: 0984:     if numlines < MAXLINES
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 0985:         memcpy(@txtlinbuf=>[row + 1], @txtlinbuf=>[row], (numlines - row) * 2)
; toolsrc/ed.pla: 0986:         txtlinbuf=>[row] = @nullstr
; toolsrc/ed.pla: 0987:         numlines++
	!BYTE	$6A			; LAW	_D047+0
_F475 	!WORD	_D047+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B293
	!WORD	_B293-*
	!BYTE	$6A			; LAW	_D053+0
_F476 	!WORD	_D053+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D053+0
_F477 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$6A			; LAW	_D047+0
_F478 	!WORD	_D047+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F479 	!WORD	0		
	!BYTE	$26			; LA	_D043+0
_F480 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D053+0
_F481 	!WORD	_D053+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D047+0
_F482 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0988:         flags = flags | changed
; toolsrc/ed.pla: 0989:         return TRUE
	!BYTE	$7A			; SAW	_D047+0
_F483 	!WORD	_D047+0		
	!BYTE	$68			; LAB	_D046+0
_F484 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F485 	!WORD	_D046+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0990:     fin
_B293 
_B294 
; toolsrc/ed.pla: 0991:     bell
; toolsrc/ed.pla: 0992:     return FALSE
	!BYTE	$54			; CALL	_C000
_F486 	!WORD	_C000		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0993: end
; toolsrc/ed.pla: 0994: def joinline#0
_C041 					; joinline()
; toolsrc/ed.pla: 0995:     word  joinlen, joinstr, stripjoin
					; joinlen -> [0]
					; joinstr -> [2]
					; stripjoin -> [4]
; toolsrc/ed.pla: 0996: 
; toolsrc/ed.pla: 0997:     if cursrow < numlines - 1
	!BYTE	$58,$06,$00		; ENTER	6,0
; toolsrc/ed.pla: 0998:         joinstr   = heapalloc(MAXLNLEN+1)
; toolsrc/ed.pla: 0999:         stripjoin = heapalloc(MAXLNLEN+1)
; toolsrc/ed.pla: 1000:         strstripcpy(joinstr, txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1001:         memcpy(stripjoin, txtlinbuf=>[cursrow + 1], ^(txtlinbuf=>[cursrow + 1]) + 1)
; toolsrc/ed.pla: 1002:         striplead(stripjoin, keyspace);
; toolsrc/ed.pla: 1003:         joinlen = ^joinstr + ^stripjoin
; toolsrc/ed.pla: 1004:         if joinlen <= MAXLNLEN
; toolsrc/ed.pla: 1005:             curshpos(^joinstr)
; toolsrc/ed.pla: 1006:             memcpy(joinstr + ^joinstr + 1, stripjoin + 1, ^stripjoin)
; toolsrc/ed.pla: 1007:             ^joinstr = joinlen
; toolsrc/ed.pla: 1008:             delstr(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1009:             txtlinbuf=>[cursrow] = newstr(joinstr)
; toolsrc/ed.pla: 1010:             delstr(txtlinbuf=>[cursrow + 1])
; toolsrc/ed.pla: 1011:             numlines--
	!BYTE	$6A			; LAW	_D057+0
_F487 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F488 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B295
	!WORD	_B295-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_X014
_F489 	!WORD	0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_X014
_F490 	!WORD	0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D053+0
_F491 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F492 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F493 	!WORD	_C002		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_D053+0
_F494 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F495 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D053+0
_F496 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F497 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F498 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C001
_F499 	!WORD	_C001		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B297
	!WORD	_B297-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C016
_F500 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F501 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D053+0
_F502 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F503 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F504 	!WORD	_C003		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F505 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F506 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F507 	!WORD	_D057+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D053+0
_F508 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F509 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F510 	!WORD	_C003		
	!BYTE	$6A			; LAW	_D047+0
_F511 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1012:             memcpy(@txtlinbuf=>[cursrow + 1], @txtlinbuf=>[cursrow + 2], (numlines - cursrow) * 2)
; toolsrc/ed.pla: 1013:             flags = flags | changed
; toolsrc/ed.pla: 1014:             heaprelease(joinstr)
; toolsrc/ed.pla: 1015:             return
	!BYTE	$7A			; SAW	_D047+0
_F512 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D053+0
_F513 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F514 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D053+0
_F515 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F516 	!WORD	_D057+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D047+0
_F517 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D057+0
_F518 	!WORD	_D057+0		
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F519 	!WORD	0		
	!BYTE	$68			; LAB	_D046+0
_F520 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F521 	!WORD	_D046+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X015
_F522 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 1016:         fin
_B297 
_B298 
; toolsrc/ed.pla: 1017:         heaprelease(joinstr)
; toolsrc/ed.pla: 1018:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X015
_F523 	!WORD	0		
	!BYTE	$30			; DROP 
_B295 
_B296 
; toolsrc/ed.pla: 1019:     bell
; toolsrc/ed.pla: 1020: end
	!BYTE	$54			; CALL	_C000
_F524 	!WORD	_C000		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 1021: def splitline#0
_C042 					; splitline()
; toolsrc/ed.pla: 1022:     byte splitstr[MAXLNLEN+1], splitlen, i
					; splitstr -> [0]
					; splitlen -> [128]
					; i -> [129]
; toolsrc/ed.pla: 1023: 
; toolsrc/ed.pla: 1024:     if openline(cursrow + 1)
	!BYTE	$58,$82,$00		; ENTER	130,0
; toolsrc/ed.pla: 1025:         if curscol
; toolsrc/ed.pla: 1026:             splitlen = ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1027:             if curscol < splitlen - 1
; toolsrc/ed.pla: 1028:                 splitstr = splitlen - curscol
; toolsrc/ed.pla: 1029:                 memcpy(@splitstr + 1, txtlinbuf=>[cursrow] + curscol + 1, splitstr)
; toolsrc/ed.pla: 1030:                 striplead(@splitstr, keyspace)
; toolsrc/ed.pla: 1031:                 for i = 1 to curscol
	!BYTE	$6A			; LAW	_D057+0
_F525 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C040
_F526 	!WORD	_C040		
	!BYTE	$4C			; BRFLS	_B299
	!WORD	_B299-*
	!BYTE	$6A			; LAW	_D058+0
_F527 	!WORD	_D058+0		
	!BYTE	$4C			; BRFLS	_B301
	!WORD	_B301-*
	!BYTE	$6A			; LAW	_D053+0
_F528 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F529 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$74,$80			; SLB	[128]
	!BYTE	$6A			; LAW	_D058+0
_F530 	!WORD	_D058+0		
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B303
	!WORD	_B303-*
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$6A			; LAW	_D058+0
_F531 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D053+0
_F532 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F533 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$B6			; ADDAW	_D058+0
_F534 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F535 	!WORD	0		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C001
_F536 	!WORD	_C001		
	!BYTE	$6A			; LAW	_D058+0
_F537 	!WORD	_D058+0		
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B305
	!WORD	_B305-*
_B306 
	!BYTE	$6C,$81			; DLB	[129]
; toolsrc/ed.pla: 1032:                     if ^(txtlinbuf=>[cursrow] + i) <> keyspace
; toolsrc/ed.pla: 1033:                         break
	!BYTE	$6A			; LAW	_D053+0
_F538 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F539 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$B0,$81			; ADDLB	[129]
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B308
	!WORD	_B308-*
	!BYTE	$50			; BRNCH	_B305
	!WORD	_B305-*
; toolsrc/ed.pla: 1034:                     fin
_B308 
_B309 
; toolsrc/ed.pla: 1035:                     memcpy(@splitstr + 2, @splitstr + 1, splitstr)
; toolsrc/ed.pla: 1036:                     splitstr[1] = keyspace
; toolsrc/ed.pla: 1037:                     splitstr++
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F540 	!WORD	0		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1038:                 next
	!BYTE	$74,$00			; SLB	[0]
_B307 
	!BYTE	$A4			; INCBRLE	_B306
	!WORD	_B306-*
_B305 
	!BYTE	$74,$81			; SLB	[129]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1039:                 txtlinbuf=>[cursrow + 1] = newstr(@splitstr)
; toolsrc/ed.pla: 1040:                 splitstr = curscol
; toolsrc/ed.pla: 1041:                 memcpy(@splitstr + 1, txtlinbuf=>[cursrow] + 1, splitstr)
; toolsrc/ed.pla: 1042:                 delstr(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1043:                 txtlinbuf=>[cursrow] = newstr(@splitstr)
; toolsrc/ed.pla: 1044:                 curshpos(i - 1)
; toolsrc/ed.pla: 1045:             else
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C004
_F541 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F542 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F543 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D058+0
_F544 	!WORD	_D058+0		
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D053+0
_F545 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F546 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F547 	!WORD	0		
	!BYTE	$6A			; LAW	_D053+0
_F548 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F549 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F550 	!WORD	_C003		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C004
_F551 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F552 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F553 	!WORD	_D057+0		
	!BYTE	$72			; SW
	!BYTE	$64,$81			; LLB	[129]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F554 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B304
	!WORD	_B304-*
_B303 
; toolsrc/ed.pla: 1046:                 if splitlen > 0
; toolsrc/ed.pla: 1047:                     for curscol = 1 to splitlen - 1
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B310
	!WORD	_B310-*
	!BYTE	$64,$80			; LLB	[128]
	!BYTE	$8E			; DECR
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B312
	!WORD	_B312-*
_B313 
	!BYTE	$7E			; DAW	_D058+0
_F555 	!WORD	_D058+0		
; toolsrc/ed.pla: 1048:                         if ^(txtlinbuf=>[cursrow] + curscol) <> keyspace
; toolsrc/ed.pla: 1049:                             break
	!BYTE	$6A			; LAW	_D053+0
_F556 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F557 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$B6			; ADDAW	_D058+0
_F558 	!WORD	_D058+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B315
	!WORD	_B315-*
	!BYTE	$50			; BRNCH	_B312
	!WORD	_B312-*
; toolsrc/ed.pla: 1050:                         fin
_B315 
_B316 
; toolsrc/ed.pla: 1051:                     next
_B314 
	!BYTE	$A4			; INCBRLE	_B313
	!WORD	_B313-*
_B312 
	!BYTE	$7A			; SAW	_D058+0
_F559 	!WORD	_D058+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1052:                     curshpos(curscol - 1)
; toolsrc/ed.pla: 1053:                 fin
	!BYTE	$6A			; LAW	_D058+0
_F560 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F561 	!WORD	_C016		
	!BYTE	$30			; DROP 
_B310 
_B311 
; toolsrc/ed.pla: 1054:             fin
_B304 
; toolsrc/ed.pla: 1055:          else
	!BYTE	$50			; BRNCH	_B302
	!WORD	_B302-*
_B301 
; toolsrc/ed.pla: 1056:             txtlinbuf=>[cursrow + 1] = txtlinbuf=>[cursrow]
; toolsrc/ed.pla: 1057:             txtlinbuf=>[cursrow]     = @nullstr
; toolsrc/ed.pla: 1058:         fin
	!BYTE	$6A			; LAW	_D053+0
_F562 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F563 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D053+0
_F564 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F565 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D043+0
_F566 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D053+0
_F567 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F568 	!WORD	_D057+0		
	!BYTE	$72			; SW
_B302 
; toolsrc/ed.pla: 1059:     fin
_B299 
_B300 
; toolsrc/ed.pla: 1060: end
	!BYTE	$5A,$82			; LEAVE	130
; toolsrc/ed.pla: 1061: //
; toolsrc/ed.pla: 1062: // Keyboard routines
; toolsrc/ed.pla: 1063: //
; toolsrc/ed.pla: 1064: def waitkey#1
_C043 					; waitkey()
; toolsrc/ed.pla: 1065:     word delay
					; delay -> [0]
; toolsrc/ed.pla: 1066: 
; toolsrc/ed.pla: 1067:     for delay = 0 to cursflash
	!BYTE	$58,$02,$00		; ENTER	2,0
	!BYTE	$6A			; LAW	_D060+0
_F569 	!WORD	_D060+0		
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B317
	!WORD	_B317-*
_B318 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 1068:         if conio:keypressed()
; toolsrc/ed.pla: 1069:             return conio:getkey()
	!BYTE	$6A			; LAW	_X033+0
_F570 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B320
	!WORD	_B320-*
	!BYTE	$32			; DROP2
	!BYTE	$6A			; LAW	_X033+2
_F571 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1070:         fin
_B320 
_B321 
; toolsrc/ed.pla: 1071:     next
_B319 
	!BYTE	$A4			; INCBRLE	_B318
	!WORD	_B318-*
_B317 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1072:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1073: end
; toolsrc/ed.pla: 1074: def keyin
_C044 					; keyin()
; toolsrc/ed.pla: 1075:     byte key, underchr, curschr
					; key -> [0]
					; underchr -> [1]
					; curschr -> [2]
; toolsrc/ed.pla: 1076: 
; toolsrc/ed.pla: 1077:     underchr = curscol >= ^(txtlinbuf=>[cursrow]) ?? ' ' :: txtlinbuf=>[cursrow]->[curscol + 1]
	!BYTE	$58,$03,$00		; ENTER	3,0
; toolsrc/ed.pla: 1078:     curschr  = flags & insmode ?? '+' :: '_'
; toolsrc/ed.pla: 1079:     if conio:keypressed()
; toolsrc/ed.pla: 1080:         key = conio:getkey()
; toolsrc/ed.pla: 1081:         conio:gotoxy(cursx, cursy)
; toolsrc/ed.pla: 1082:     else
	!BYTE	$6A			; LAW	_D058+0
_F572 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D053+0
_F573 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F574 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B322
	!WORD	_B322-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$50			; BRNCH	_B323
	!WORD	_B323-*
_B322 
	!BYTE	$6A			; LAW	_D053+0
_F575 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F576 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D058+0
_F577 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
_B323 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$68			; LAB	_D046+0
_F578 	!WORD	_D046+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B324
	!WORD	_B324-*
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$50			; BRNCH	_B325
	!WORD	_B325-*
_B324 
	!BYTE	$2A,$5F			; CB	95
_B325 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$6A			; LAW	_X033+0
_F579 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B326
	!WORD	_B326-*
	!BYTE	$6A			; LAW	_X033+2
_F580 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D055+0
_F581 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D056+0
_F582 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_X033+8
_F583 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B327
	!WORD	_B327-*
_B326 
; toolsrc/ed.pla: 1083:         conio:gotoxy(cursx, cursy)
; toolsrc/ed.pla: 1084:         repeat
	!BYTE	$6A			; LAW	_D055+0
_F584 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D056+0
_F585 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_X033+8
_F586 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B329 
; toolsrc/ed.pla: 1085:             conio:textctrl(ctrlattr,   INVERSE)
; toolsrc/ed.pla: 1086:             conio:putchars(1, curschr)
; toolsrc/ed.pla: 1087:             conio:gotoxy(cursx, cursy)
; toolsrc/ed.pla: 1088:             key = waitkey
; toolsrc/ed.pla: 1089:             conio:textctrl(ctrlattr, NORMAL)
; toolsrc/ed.pla: 1090:             if not key
; toolsrc/ed.pla: 1091:                 conio:putchars(1, underchr)
; toolsrc/ed.pla: 1092:                 conio:gotoxy(cursx, cursy)
; toolsrc/ed.pla: 1093:                 key = waitkey
; toolsrc/ed.pla: 1094:             fin
	!BYTE	$02			; CN	1
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$6A			; LAW	_X033+12
_F587 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$6A			; LAW	_X033+4
_F588 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D055+0
_F589 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D056+0
_F590 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_X033+8
_F591 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C043
_F592 	!WORD	_C043		
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$02			; CN	1
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$6A			; LAW	_X033+12
_F593 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$4E			; BRTRU	_B331
	!WORD	_B331-*
	!BYTE	$02			; CN	1
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$6A			; LAW	_X033+4
_F594 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D055+0
_F595 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D056+0
_F596 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_X033+8
_F597 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C043
_F598 	!WORD	_C043		
	!BYTE	$74,$00			; SLB	[0]
_B331 
_B332 
; toolsrc/ed.pla: 1095:         until key
_B330 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$4C			; BRFLS	_B329
	!WORD	_B329-*
_B328 
; toolsrc/ed.pla: 1096:     fin
_B327 
; toolsrc/ed.pla: 1097:     conio:putchars(1, underchr)
; toolsrc/ed.pla: 1098:     if (key & ~keyoptmod) >= '0' and (key & ~keyoptmod) <= '9'
; toolsrc/ed.pla: 1099:         key = key ^ (flags & numlock) // numlock == keyoptmod
; toolsrc/ed.pla: 1100:     fin
	!BYTE	$02			; CN	1
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$6A			; LAW	_X033+4
_F599 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5E,$7F			; CFFB	-129
	!BYTE	$94			; AND 
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B333
	!WORD	_B333-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5E,$7F			; CFFB	-129
	!BYTE	$94			; AND 
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B333 
	!BYTE	$4C			; BRFLS	_B334
	!WORD	_B334-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$68			; LAB	_D046+0
_F600 	!WORD	_D046+0		
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$98			; XOR
	!BYTE	$74,$00			; SLB	[0]
_B334 
_B335 
; toolsrc/ed.pla: 1101:     if key & keyoptmod // Closed-Apple/Option pressed
; toolsrc/ed.pla: 1102:         when key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B336
	!WORD	_B336-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$52			; SEL
	!WORD	_B339-*
; toolsrc/ed.pla: 1103:             is keyarrowleft | keyoptmod
_B340 
; toolsrc/ed.pla: 1104:                 key = keyctrla; break
	!BYTE	$02			; CN	1
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1105:             is keyarrowright | keyoptmod
_B341 
; toolsrc/ed.pla: 1106:                 key = keyctrls; break
	!BYTE	$2A,$13			; CB	19
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1107:             is keyarrowup | keyoptmod
_B342 
; toolsrc/ed.pla: 1108:                 key = keyctrlw; break
	!BYTE	$2A,$17			; CB	23
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1109:             is keyarrowdown | keyoptmod
_B343 
; toolsrc/ed.pla: 1110:                 key = keyctrlz; break
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1111:             is keyenter | keyoptmod
_B344 
; toolsrc/ed.pla: 1112:                 key = keyctrlf; break
	!BYTE	$0C			; CN	6
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1113:             is keytab | keyoptmod
_B345 
; toolsrc/ed.pla: 1114:                 key = keydetab; break
	!BYTE	$2A,$1D			; CB	29
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1115:            is '\\' | keyoptmod
_B346 
; toolsrc/ed.pla: 1116:                 key = keydelete; break // Delete
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1117:             //
; toolsrc/ed.pla: 1118:             // Map option+keypad on Platinum //e
; toolsrc/ed.pla: 1119:             //
; toolsrc/ed.pla: 1120:             is '4' | keyoptmod
_B347 
; toolsrc/ed.pla: 1121:                 key = keyarrowleft; break
	!BYTE	$10			; CN	8
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1122:             is '6' | keyoptmod
_B348 
; toolsrc/ed.pla: 1123:                 key = keyarrowright; break
	!BYTE	$2A,$15			; CB	21
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1124:             is '8' | keyoptmod
_B349 
; toolsrc/ed.pla: 1125:                 key = keyarrowup; break
	!BYTE	$16			; CN	11
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1126:             is '2' | keyoptmod
_B350 
; toolsrc/ed.pla: 1127:                 key = keyarrowdown; break
	!BYTE	$14			; CN	10
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1128:             is '7' | keyoptmod
_B351 
; toolsrc/ed.pla: 1129:                 key = keyctrlq; break // Top
	!BYTE	$2A,$11			; CB	17
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1130:             is '1' | keyoptmod
_B352 
; toolsrc/ed.pla: 1131:                 key = keyctrle; break // Bottom
	!BYTE	$0A			; CN	5
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1132:             is '9' | keyoptmod
_B353 
; toolsrc/ed.pla: 1133:                 key = keyctrlw; break // Pg Up
	!BYTE	$2A,$17			; CB	23
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1134:             is '3' | keyoptmod
_B354 
; toolsrc/ed.pla: 1135:                 key = keyctrlz; break // Pg Dn
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1136:             is '5' | keyoptmod
_B355 
; toolsrc/ed.pla: 1137:                 key = keyctrlb; break // Selection start/end
	!BYTE	$04			; CN	2
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1138:             is '0' | keyoptmod
_B356 
; toolsrc/ed.pla: 1139:                 key = keyctrld; break // Del
	!BYTE	$08			; CN	4
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1140:             is '.' | keyoptmod
_B357 
; toolsrc/ed.pla: 1141:                 key = keyctrlv; break // Paste
	!BYTE	$2A,$16			; CB	22
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1142:             is '-' | keyoptmod
_B358 
; toolsrc/ed.pla: 1143:                 key = keyctrlx; break // Cut
	!BYTE	$2A,$18			; CB	24
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1144:             is '+' | keyoptmod
_B359 
; toolsrc/ed.pla: 1145:                 key = keyctrlc; break // Copy
	!BYTE	$06			; CN	3
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1146:             is '*' | keyoptmod
_B360 
; toolsrc/ed.pla: 1147:                 key = keyctrlo; break // Open line
	!BYTE	$1E			; CN	15
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1148:             is '/' | keyoptmod
_B361 
; toolsrc/ed.pla: 1149:                 key = keyctrlt; break // Insert/Overwrite
	!BYTE	$2A,$14			; CB	20
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1150:             is '=' | keyoptmod
_B362 
; toolsrc/ed.pla: 1151:                 flags = flags ^ numlock
; toolsrc/ed.pla: 1152:                 if flags & numlock
; toolsrc/ed.pla: 1153:                     bell
; toolsrc/ed.pla: 1154:                 fin
	!BYTE	$68			; LAB	_D046+0
_F601 	!WORD	_D046+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$98			; XOR
	!BYTE	$7C			; DAB	_D046+0
_F602 	!WORD	_D046+0		
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B363
	!WORD	_B363-*
	!BYTE	$54			; CALL	_C000
_F603 	!WORD	_C000		
_B363 
_B364 
; toolsrc/ed.pla: 1155:                 bell
; toolsrc/ed.pla: 1156:                 key = 0
; toolsrc/ed.pla: 1157:                 break
	!BYTE	$54			; CALL	_C000
_F604 	!WORD	_C000		
	!BYTE	$00			; CN	0
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B338
	!WORD	_B338-*
; toolsrc/ed.pla: 1158:             otherwise
_B339 
	!BYTE	$17			; CASEBLOCK
	!WORD	$0088
	!WORD	_B340-*
	!WORD	$0089
	!WORD	_B345-*
	!WORD	$008A
	!WORD	_B343-*
	!WORD	$008B
	!WORD	_B342-*
	!WORD	$008D
	!WORD	_B344-*
	!WORD	$0095
	!WORD	_B341-*
	!WORD	$00AA
	!WORD	_B360-*
	!WORD	$00AB
	!WORD	_B359-*
	!WORD	$00AD
	!WORD	_B358-*
	!WORD	$00AE
	!WORD	_B357-*
	!WORD	$00AF
	!WORD	_B361-*
	!WORD	$00B0
	!WORD	_B356-*
	!WORD	$00B1
	!WORD	_B352-*
	!WORD	$00B2
	!WORD	_B350-*
	!WORD	$00B3
	!WORD	_B354-*
	!WORD	$00B4
	!WORD	_B347-*
	!WORD	$00B5
	!WORD	_B355-*
	!WORD	$00B6
	!WORD	_B348-*
	!WORD	$00B7
	!WORD	_B351-*
	!WORD	$00B8
	!WORD	_B349-*
	!WORD	$00B9
	!WORD	_B353-*
	!WORD	$00BD
	!WORD	_B362-*
	!WORD	$00DC
	!WORD	_B346-*
; toolsrc/ed.pla: 1159:                 key = key & ~keyoptmod
; toolsrc/ed.pla: 1160:         wend
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5E,$7F			; CFFB	-129
	!BYTE	$94			; AND 
	!BYTE	$74,$00			; SLB	[0]
_B338 
; toolsrc/ed.pla: 1161:     fin
_B336 
_B337 
; toolsrc/ed.pla: 1162:     return key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 1163: end
; toolsrc/ed.pla: 1164: def editkey(key)
					; key -> [0]
_C045 					; editkey()
; toolsrc/ed.pla: 1165:     if key >= keyspace or key == keyctrld or key == keyctrlr
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 1166:         return TRUE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$48			; ISGE
	!BYTE	$AE			; BROR	_B365
	!WORD	_B365-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B366
	!WORD	_B366-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$12			; CB	18
	!BYTE	$40			; ISEQ
_B366 
_B365 
	!BYTE	$4C			; BRFLS	_B367
	!WORD	_B367-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1167:     fin
_B367 
_B368 
; toolsrc/ed.pla: 1168:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1169: end
; toolsrc/ed.pla: 1170: def editline(key)
					; key -> [0]
_C046 					; editline()
; toolsrc/ed.pla: 1171:     word undoline
					; undoline -> [2]
; toolsrc/ed.pla: 1172:     byte undopos, localchange, editstr[], editlen, editchars[MAXLNLEN+1]
					; undopos -> [4]
					; localchange -> [5]
					; editstr -> [6]
					; editlen -> [6]
					; editchars -> [7]
; toolsrc/ed.pla: 1173: 
; toolsrc/ed.pla: 1174:     if (editkey(key))
	!BYTE	$58,$87,$01		; ENTER	135,1
; toolsrc/ed.pla: 1175:         localchange = FALSE
; toolsrc/ed.pla: 1176:         undopos     = curscol
; toolsrc/ed.pla: 1177:         undoline    = txtlinbuf=>[cursrow]
; toolsrc/ed.pla: 1178:         editlen     = MAXLNLEN
; toolsrc/ed.pla: 1179:         memcpy(@editchars, undoline + 1, ^undoline)
; toolsrc/ed.pla: 1180:         memset(@editchars + ^undoline, keyspace | (keyspace << 8), MAXLNLEN - ^undoline)
; toolsrc/ed.pla: 1181:         txtlinbuf=>[cursrow] = @editstr
; toolsrc/ed.pla: 1182:         repeat
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C045
_F605 	!WORD	_C045		
	!BYTE	$4C			; BRFLS	_B369
	!WORD	_B369-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$6A			; LAW	_D058+0
_F606 	!WORD	_D058+0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$6A			; LAW	_D053+0
_F607 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F608 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F609 	!WORD	0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$2C,$20,$20		; CW	8224
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X017
_F610 	!WORD	0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$6A			; LAW	_D053+0
_F611 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F612 	!WORD	_D057+0		
	!BYTE	$72			; SW
_B372 
; toolsrc/ed.pla: 1183:             when key
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$52			; SEL
	!WORD	_B375-*
; toolsrc/ed.pla: 1184:                 is keyctrld
_B376 
; toolsrc/ed.pla: 1185:                     memcpy(@editchars[curscol], @editchars[curscol + 1], MAXLNLEN - 1 - curscol)
; toolsrc/ed.pla: 1186:                     editchars[MAXLNLEN - 1] = keyspace
; toolsrc/ed.pla: 1187:                     drawstr(cursy, @editstr)
; toolsrc/ed.pla: 1188:                     localchange = TRUE
; toolsrc/ed.pla: 1189:                     break
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D058+0
_F613 	!WORD	_D058+0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D058+0
_F614 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$2A,$7E			; CB	126
	!BYTE	$6A			; LAW	_D058+0
_F615 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F616 	!WORD	0		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$74,$85			; SLB	[133]
	!BYTE	$6A			; LAW	_D056+0
_F617 	!WORD	_D056+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C011
_F618 	!WORD	_C011		
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
; toolsrc/ed.pla: 1190:                 is keyctrlr
_B377 
; toolsrc/ed.pla: 1191:                     memset(@editchars, $A0A0, MAXLNLEN)
; toolsrc/ed.pla: 1192:                     memcpy(@editchars, undoline + 1, ^undoline)
; toolsrc/ed.pla: 1193:                     if curshpos(undopos)
; toolsrc/ed.pla: 1194:                         drawscrn
; toolsrc/ed.pla: 1195:                     else
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$54			; CALL	_X017
_F619 	!WORD	0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F620 	!WORD	0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$54			; CALL	_C016
_F621 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B378
	!WORD	_B378-*
	!BYTE	$54			; CALL	_C015
_F622 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B379
	!WORD	_B379-*
_B378 
; toolsrc/ed.pla: 1196:                         drawstr(cursy, @editstr)
; toolsrc/ed.pla: 1197:                     fin
	!BYTE	$6A			; LAW	_D056+0
_F623 	!WORD	_D056+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C011
_F624 	!WORD	_C011		
_B379 
; toolsrc/ed.pla: 1198:                     localchange = FALSE
; toolsrc/ed.pla: 1199:                     break
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
; toolsrc/ed.pla: 1200:                 is keydelete
_B380 
; toolsrc/ed.pla: 1201:                     if curscol > 0
; toolsrc/ed.pla: 1202:                         memcpy(@editchars[curscol - 1], @editchars[curscol], MAXLNLEN - curscol)
; toolsrc/ed.pla: 1203:                         editchars[MAXLNLEN - 1] = keyspace
; toolsrc/ed.pla: 1204:                         if curshpos(curscol - 1)
; toolsrc/ed.pla: 1205:                             drawscrn
; toolsrc/ed.pla: 1206:                         else
	!BYTE	$6A			; LAW	_D058+0
_F625 	!WORD	_D058+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B381
	!WORD	_B381-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D058+0
_F626 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D058+0
_F627 	!WORD	_D058+0		
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$6A			; LAW	_D058+0
_F628 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F629 	!WORD	0		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$74,$85			; SLB	[133]
	!BYTE	$6A			; LAW	_D058+0
_F630 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C016
_F631 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B383
	!WORD	_B383-*
	!BYTE	$54			; CALL	_C015
_F632 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B384
	!WORD	_B384-*
_B383 
; toolsrc/ed.pla: 1207:                             drawstr(cursy, @editstr)
; toolsrc/ed.pla: 1208:                         fin
	!BYTE	$6A			; LAW	_D056+0
_F633 	!WORD	_D056+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C011
_F634 	!WORD	_C011		
_B384 
; toolsrc/ed.pla: 1209:                         localchange = TRUE
; toolsrc/ed.pla: 1210:                     fin
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
_B381 
_B382 
; toolsrc/ed.pla: 1211:                     break
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
; toolsrc/ed.pla: 1212:                 otherwise
_B375 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0004
	!WORD	_B376-*
	!WORD	$0012
	!WORD	_B377-*
	!WORD	$007F
	!WORD	_B380-*
; toolsrc/ed.pla: 1213:                     if flags & insmode
; toolsrc/ed.pla: 1214:                         if editchars[MAXLNLEN - 1] == keyspace
; toolsrc/ed.pla: 1215:                             memcpy(@editchars[curscol+1], @editchars[curscol], MAXLNLEN - 1 - curscol)
; toolsrc/ed.pla: 1216:                         else
	!BYTE	$68			; LAB	_D046+0
_F635 	!WORD	_D046+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B385
	!WORD	_B385-*
	!BYTE	$64,$85			; LLB	[133]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B387
	!WORD	_B387-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D058+0
_F636 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D058+0
_F637 	!WORD	_D058+0		
	!BYTE	$2A,$7E			; CB	126
	!BYTE	$6A			; LAW	_D058+0
_F638 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F639 	!WORD	0		
	!BYTE	$50			; BRNCH	_B388
	!WORD	_B388-*
_B387 
; toolsrc/ed.pla: 1217:                             bell
; toolsrc/ed.pla: 1218:                             break
	!BYTE	$54			; CALL	_C000
_F640 	!WORD	_C000		
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
; toolsrc/ed.pla: 1219:                         fin
_B388 
; toolsrc/ed.pla: 1220:                     fin
_B385 
_B386 
; toolsrc/ed.pla: 1221:                     editchars[curscol] = key
; toolsrc/ed.pla: 1222:                     if curshpos(curscol + 1)
; toolsrc/ed.pla: 1223:                         drawscrn
; toolsrc/ed.pla: 1224:                     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D058+0
_F641 	!WORD	_D058+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D058+0
_F642 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C016
_F643 	!WORD	_C016		
	!BYTE	$4C			; BRFLS	_B389
	!WORD	_B389-*
	!BYTE	$54			; CALL	_C015
_F644 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B390
	!WORD	_B390-*
_B389 
; toolsrc/ed.pla: 1225:                         drawstr(cursy, @editstr)
; toolsrc/ed.pla: 1226:                     fin
	!BYTE	$6A			; LAW	_D056+0
_F645 	!WORD	_D056+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C011
_F646 	!WORD	_C011		
_B390 
; toolsrc/ed.pla: 1227:                     localchange = TRUE
; toolsrc/ed.pla: 1228:                     break
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
; toolsrc/ed.pla: 1229:             wend
_B374 
; toolsrc/ed.pla: 1230:             key = keyin
; toolsrc/ed.pla: 1231:         until not editkey(key)
	!BYTE	$54			; CALL	_C044
_F647 	!WORD	_C044		
	!BYTE	$76,$00			; SLW	[0]
_B373 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C045
_F648 	!WORD	_C045		
	!BYTE	$4E			; BRTRU	_B372
	!WORD	_B372-*
_B371 
; toolsrc/ed.pla: 1232:         if localchange
; toolsrc/ed.pla: 1233:             flags = flags | changed
; toolsrc/ed.pla: 1234:             delstr(undoline)
; toolsrc/ed.pla: 1235:             txtlinbuf=>[cursrow] = newstr(@editstr)
; toolsrc/ed.pla: 1236:         else
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$4C			; BRFLS	_B391
	!WORD	_B391-*
	!BYTE	$68			; LAB	_D046+0
_F649 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F650 	!WORD	_D046+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F651 	!WORD	_C003		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C004
_F652 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D053+0
_F653 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F654 	!WORD	_D057+0		
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B392
	!WORD	_B392-*
_B391 
; toolsrc/ed.pla: 1237:             txtlinbuf=>[cursrow] = undoline
; toolsrc/ed.pla: 1238:         fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D053+0
_F655 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F656 	!WORD	_D057+0		
	!BYTE	$72			; SW
_B392 
; toolsrc/ed.pla: 1239:     fin
_B369 
_B370 
; toolsrc/ed.pla: 1240:     return key
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/ed.pla: 1241: end
; toolsrc/ed.pla: 1242: def editmode#0
_C047 					; editmode()
; toolsrc/ed.pla: 1243:     conio:textctrl(ctrlecho, OFF)
; toolsrc/ed.pla: 1244:     conio:textctrl(ctrlcursor, OFF)
; toolsrc/ed.pla: 1245:     repeat
	!BYTE	$04			; CN	2
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+12
_F657 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+12
_F658 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B394 
; toolsrc/ed.pla: 1246:         when editline(keyin)
	!BYTE	$54			; CALL	_C044
_F659 	!WORD	_C044		
	!BYTE	$54			; CALL	_C046
_F660 	!WORD	_C046		
	!BYTE	$52			; SEL
	!WORD	_B397-*
; toolsrc/ed.pla: 1247:             is keyarrowup
_B398 
; toolsrc/ed.pla: 1248:                 cursup; break
	!BYTE	$54			; CALL	_C020
_F661 	!WORD	_C020		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1249:             is keyarrowdown
_B399 
; toolsrc/ed.pla: 1250:                 cursdown; break
	!BYTE	$54			; CALL	_C022
_F662 	!WORD	_C022		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1251:             is keyarrowleft
_B400 
; toolsrc/ed.pla: 1252:                 cursleft; break
	!BYTE	$54			; CALL	_C024
_F663 	!WORD	_C024		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1253:             is keyarrowright
_B401 
; toolsrc/ed.pla: 1254:                 cursright; break
	!BYTE	$54			; CALL	_C026
_F664 	!WORD	_C026		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1255:             is keyctrlw
_B402 
; toolsrc/ed.pla: 1256:                 pgup; break
	!BYTE	$54			; CALL	_C021
_F665 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1257:             is keyctrlz
_B403 
; toolsrc/ed.pla: 1258:                 pgdown; break
	!BYTE	$54			; CALL	_C023
_F666 	!WORD	_C023		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1259:             is keyctrla
_B404 
; toolsrc/ed.pla: 1260:                 pgleft; break
	!BYTE	$54			; CALL	_C025
_F667 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1261:             is keyctrls
_B405 
; toolsrc/ed.pla: 1262:                 pgright; break
	!BYTE	$54			; CALL	_C027
_F668 	!WORD	_C027		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1263:             is keyctrlq
_B406 
; toolsrc/ed.pla: 1264:                 curshome; break
	!BYTE	$54			; CALL	_C018
_F669 	!WORD	_C018		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1265:             is keyctrle
_B407 
; toolsrc/ed.pla: 1266:                 cursend; break
	!BYTE	$54			; CALL	_C019
_F670 	!WORD	_C019		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1267:             is keyctrlb
_B408 
; toolsrc/ed.pla: 1268:                 beginsel; break
	!BYTE	$54			; CALL	_C033
_F671 	!WORD	_C033		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1269:             is keyctrlc
_B409 
; toolsrc/ed.pla: 1270:                 copysel; break
	!BYTE	$54			; CALL	_C034
_F672 	!WORD	_C034		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1271:             is keyctrlx
_B410 
; toolsrc/ed.pla: 1272:                 cutsel; break
	!BYTE	$54			; CALL	_C035
_F673 	!WORD	_C035		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1273:             is keyctrlv
_B411 
; toolsrc/ed.pla: 1274:                 pastesel; break
	!BYTE	$54			; CALL	_C036
_F674 	!WORD	_C036		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1275:             is keyctrlf
_B412 
; toolsrc/ed.pla: 1276:                 if cursrow == (numlines - 1)
; toolsrc/ed.pla: 1277:                     if numlines < MAXLINES
; toolsrc/ed.pla: 1278:                         numlines++
	!BYTE	$6A			; LAW	_D057+0
_F675 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D047+0
_F676 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$24			; BRNE	_B413
	!WORD	_B413-*
	!BYTE	$6A			; LAW	_D047+0
_F677 	!WORD	_D047+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B415
	!WORD	_B415-*
	!BYTE	$6A			; LAW	_D047+0
_F678 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1279:                         cursdown
; toolsrc/ed.pla: 1280:                         flags = flags | changed
; toolsrc/ed.pla: 1281:                         drawgutter
; toolsrc/ed.pla: 1282:                     else
	!BYTE	$7A			; SAW	_D047+0
_F679 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_C022
_F680 	!WORD	_C022		
	!BYTE	$68			; LAB	_D046+0
_F681 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F682 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_C013
_F683 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B416
	!WORD	_B416-*
_B415 
; toolsrc/ed.pla: 1283:                         bell
; toolsrc/ed.pla: 1284:                     fin
	!BYTE	$54			; CALL	_C000
_F684 	!WORD	_C000		
_B416 
; toolsrc/ed.pla: 1285:                     break
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1286:                 fin
_B413 
_B414 
; toolsrc/ed.pla: 1287:                 cursdown
; toolsrc/ed.pla: 1288:             is keyctrlo
	!BYTE	$54			; CALL	_C022
_F685 	!WORD	_C022		
_B417 
; toolsrc/ed.pla: 1289:                 openline(cursrow)
; toolsrc/ed.pla: 1290:                 if cursrow
; toolsrc/ed.pla: 1291:                     autoindent(txtlinbuf=>[cursrow - 1])
; toolsrc/ed.pla: 1292:                 else
	!BYTE	$6A			; LAW	_D057+0
_F686 	!WORD	_D057+0		
	!BYTE	$54			; CALL	_C040
_F687 	!WORD	_C040		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D057+0
_F688 	!WORD	_D057+0		
	!BYTE	$4C			; BRFLS	_B418
	!WORD	_B418-*
	!BYTE	$6A			; LAW	_D053+0
_F689 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D057+0
_F690 	!WORD	_D057+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F691 	!WORD	_C039		
	!BYTE	$50			; BRNCH	_B419
	!WORD	_B419-*
_B418 
; toolsrc/ed.pla: 1293:                     curshpos(0)
; toolsrc/ed.pla: 1294:                 fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F692 	!WORD	_C016		
	!BYTE	$30			; DROP 
_B419 
; toolsrc/ed.pla: 1295:                 drawscrn
; toolsrc/ed.pla: 1296:                 break
	!BYTE	$54			; CALL	_C015
_F693 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1297:             is keyenter
_B420 
; toolsrc/ed.pla: 1298:                 if flags & insmode
; toolsrc/ed.pla: 1299:                     splitline
; toolsrc/ed.pla: 1300:                 else
	!BYTE	$68			; LAB	_D046+0
_F694 	!WORD	_D046+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B421
	!WORD	_B421-*
	!BYTE	$54			; CALL	_C042
_F695 	!WORD	_C042		
	!BYTE	$50			; BRNCH	_B422
	!WORD	_B422-*
_B421 
; toolsrc/ed.pla: 1301:                     openline(cursrow + 1)
; toolsrc/ed.pla: 1302:                 fin
	!BYTE	$6A			; LAW	_D057+0
_F696 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C040
_F697 	!WORD	_C040		
	!BYTE	$30			; DROP 
_B422 
; toolsrc/ed.pla: 1303:                 autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1304:                 cursvpos(cursrow + 1)
; toolsrc/ed.pla: 1305:                 drawscrn
; toolsrc/ed.pla: 1306:                 break
	!BYTE	$6A			; LAW	_D053+0
_F698 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F699 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F700 	!WORD	_C039		
	!BYTE	$6A			; LAW	_D057+0
_F701 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C017
_F702 	!WORD	_C017		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C015
_F703 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1307:             is keyctrly
_B423 
; toolsrc/ed.pla: 1308:                 joinline
; toolsrc/ed.pla: 1309:                 drawscrn
; toolsrc/ed.pla: 1310:                 break
	!BYTE	$54			; CALL	_C041
_F704 	!WORD	_C041		
	!BYTE	$54			; CALL	_C015
_F705 	!WORD	_C015		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1311:             is keytab
_B424 
; toolsrc/ed.pla: 1312:                 if flags & insmode
; toolsrc/ed.pla: 1313:                     indentsel
; toolsrc/ed.pla: 1314:                     if not ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1315:                         curshpos((curscol + 2) & $FE)
; toolsrc/ed.pla: 1316:                     else
	!BYTE	$68			; LAB	_D046+0
_F706 	!WORD	_D046+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B425
	!WORD	_B425-*
	!BYTE	$54			; CALL	_C037
_F707 	!WORD	_C037		
	!BYTE	$6A			; LAW	_D053+0
_F708 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F709 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B427
	!WORD	_B427-*
	!BYTE	$6A			; LAW	_D058+0
_F710 	!WORD	_D058+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$3C,$FE			; ANDI	254
	!BYTE	$54			; CALL	_C016
_F711 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B428
	!WORD	_B428-*
_B427 
; toolsrc/ed.pla: 1317:                         autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1318:                     fin
	!BYTE	$6A			; LAW	_D053+0
_F712 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F713 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F714 	!WORD	_C039		
_B428 
; toolsrc/ed.pla: 1319:                     break
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1320:                 fin
_B425 
_B426 
; toolsrc/ed.pla: 1321:            is keydetab
_B429 
; toolsrc/ed.pla: 1322:                 undentsel
; toolsrc/ed.pla: 1323:                 if not ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1324:                     curshpos((curscol - 2) & $FFFE)
; toolsrc/ed.pla: 1325:                 else
	!BYTE	$54			; CALL	_C038
_F715 	!WORD	_C038		
	!BYTE	$6A			; LAW	_D053+0
_F716 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F717 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B430
	!WORD	_B430-*
	!BYTE	$6A			; LAW	_D058+0
_F718 	!WORD	_D058+0		
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$5E,$FE			; CFFB	65534
	!BYTE	$94			; AND 
	!BYTE	$54			; CALL	_C016
_F719 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B431
	!WORD	_B431-*
_B430 
; toolsrc/ed.pla: 1326:                     autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1327:                 fin
	!BYTE	$6A			; LAW	_D053+0
_F720 	!WORD	_D053+0		
	!BYTE	$BE			; IDXAW	_D057+0
_F721 	!WORD	_D057+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F722 	!WORD	_C039		
_B431 
; toolsrc/ed.pla: 1328:                 break
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1329:             is keyctrlt
_B432 
; toolsrc/ed.pla: 1330:                 flags = flags ^ insmode
; toolsrc/ed.pla: 1331:                 break
	!BYTE	$68			; LAB	_D046+0
_F723 	!WORD	_D046+0		
	!BYTE	$04			; CN	2
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D046+0
_F724 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
; toolsrc/ed.pla: 1332:             is keyescape
_B433 
; toolsrc/ed.pla: 1333:                 cmdmode
; toolsrc/ed.pla: 1334:                 if not (flags & exit)
; toolsrc/ed.pla: 1335:                     conio:clear(cls)
; toolsrc/ed.pla: 1336:                     conio:textctrl(ctrlecho, OFF)
; toolsrc/ed.pla: 1337:                     conio:textctrl(ctrlcursor, OFF)
; toolsrc/ed.pla: 1338:                     drawscrn
; toolsrc/ed.pla: 1339:                 fin
	!BYTE	$54			; CALL	_P000
_F725 	!WORD	_P000		
	!BYTE	$68			; LAB	_D046+0
_F726 	!WORD	_D046+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4E			; BRTRU	_B434
	!WORD	_B434-*
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X033+6
_F727 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+12
_F728 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+12
_F729 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C015
_F730 	!WORD	_C015		
_B434 
_B435 
; toolsrc/ed.pla: 1340:         wend
	!BYTE	$50			; BRNCH	_B396
	!WORD	_B396-*
_B397 
	!BYTE	$16			; CASEBLOCK
	!WORD	$0001
	!WORD	_B404-*
	!WORD	$0002
	!WORD	_B408-*
	!WORD	$0003
	!WORD	_B409-*
	!WORD	$0005
	!WORD	_B407-*
	!WORD	$0006
	!WORD	_B412-*
	!WORD	$0008
	!WORD	_B400-*
	!WORD	$0009
	!WORD	_B424-*
	!WORD	$000A
	!WORD	_B399-*
	!WORD	$000B
	!WORD	_B398-*
	!WORD	$000D
	!WORD	_B420-*
	!WORD	$000F
	!WORD	_B417-*
	!WORD	$0011
	!WORD	_B406-*
	!WORD	$0013
	!WORD	_B405-*
	!WORD	$0014
	!WORD	_B432-*
	!WORD	$0015
	!WORD	_B401-*
	!WORD	$0016
	!WORD	_B411-*
	!WORD	$0017
	!WORD	_B402-*
	!WORD	$0018
	!WORD	_B410-*
	!WORD	$0019
	!WORD	_B423-*
	!WORD	$001A
	!WORD	_B403-*
	!WORD	$001B
	!WORD	_B433-*
	!WORD	$001D
	!WORD	_B429-*
_B396 
; toolsrc/ed.pla: 1341:     until flags & exit
_B395 
	!BYTE	$68			; LAB	_D046+0
_F731 	!WORD	_D046+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B394
	!WORD	_B394-*
_B393 
; toolsrc/ed.pla: 1342: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1343: //
; toolsrc/ed.pla: 1344: // Command mode
; toolsrc/ed.pla: 1345: //
; toolsrc/ed.pla: 1346: def prfiles(optpath)
					; optpath -> [0]
_C048 					; prfiles()
; toolsrc/ed.pla: 1347:     byte path[64]
					; path -> [2]
; toolsrc/ed.pla: 1348:     byte refnum
					; refnum -> [66]
; toolsrc/ed.pla: 1349:     byte firstblk
					; firstblk -> [67]
; toolsrc/ed.pla: 1350:     byte entrylen, entriesblk
					; entrylen -> [68]
					; entriesblk -> [69]
; toolsrc/ed.pla: 1351:     byte i, type, len
					; i -> [70]
					; type -> [71]
					; len -> [72]
; toolsrc/ed.pla: 1352:     word databuff, entry
					; databuff -> [73]
					; entry -> [75]
; toolsrc/ed.pla: 1353: 
; toolsrc/ed.pla: 1354:     if ^optpath
	!BYTE	$58,$4D,$01		; ENTER	77,1
; toolsrc/ed.pla: 1355:         strstripcpy(@path, optpath)
; toolsrc/ed.pla: 1356:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B436
	!WORD	_B436-*
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C002
_F732 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B437
	!WORD	_B437-*
_B436 
; toolsrc/ed.pla: 1357:         fileio:getpfx(@path)
; toolsrc/ed.pla: 1358:         puts(@path)
; toolsrc/ed.pla: 1359:         putln
; toolsrc/ed.pla: 1360:     fin
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X031+0
_F733 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$54			; CALL	_X004
_F734 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F735 	!WORD	0		
_B437 
; toolsrc/ed.pla: 1361:     databuff = heapalloc(512)
; toolsrc/ed.pla: 1362:     refnum = fileio:open(@path)
; toolsrc/ed.pla: 1363:     if perr
; toolsrc/ed.pla: 1364:         return perr
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X014
_F736 	!WORD	0		
	!BYTE	$76,$49			; SLW	[73]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X031+14
_F737 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$74,$42			; SLB	[66]
	!BYTE	$68			; LAB	_X032+0
_F738 	!WORD	0+0		
	!BYTE	$4C			; BRFLS	_B438
	!WORD	_B438-*
	!BYTE	$68			; LAB	_X032+0
_F739 	!WORD	0+0		
	!BYTE	$5A,$4D			; LEAVE	77
; toolsrc/ed.pla: 1365:     fin
_B438 
_B439 
; toolsrc/ed.pla: 1366:     firstblk = 1
; toolsrc/ed.pla: 1367:     while fileio:read(refnum, databuff, 512) == 512
	!BYTE	$02			; CN	1
	!BYTE	$74,$43			; SLB	[67]
	!BYTE	$50			; BRNCH	_B442
	!WORD	_B442-*
_B440 
; toolsrc/ed.pla: 1368:         entry = databuff + 4
; toolsrc/ed.pla: 1369:         if firstblk
; toolsrc/ed.pla: 1370:             entrylen   = databuff->$23
; toolsrc/ed.pla: 1371:             entriesblk = databuff->$24
; toolsrc/ed.pla: 1372:             entry      = entry + entrylen
; toolsrc/ed.pla: 1373:         fin
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$76,$4B			; SLW	[75]
	!BYTE	$64,$43			; LLB	[67]
	!BYTE	$4C			; BRFLS	_B443
	!WORD	_B443-*
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$23			; ADDI	35
	!BYTE	$60			; LB
	!BYTE	$74,$44			; SLB	[68]
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$60			; LB
	!BYTE	$74,$45			; SLB	[69]
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$B0,$44			; ADDLB	[68]
	!BYTE	$76,$4B			; SLW	[75]
_B443 
_B444 
; toolsrc/ed.pla: 1374:         for i = firstblk to entriesblk
	!BYTE	$64,$45			; LLB	[69]
	!BYTE	$64,$43			; LLB	[67]
	!BYTE	$A0			; BRGT	_B445
	!WORD	_B445-*
_B446 
	!BYTE	$6C,$46			; DLB	[70]
; toolsrc/ed.pla: 1375:             type = ^entry
; toolsrc/ed.pla: 1376:             if type <> 0
; toolsrc/ed.pla: 1377:                 len = type & $0F
; toolsrc/ed.pla: 1378:                 ^entry = len
; toolsrc/ed.pla: 1379:                 puts(entry)
; toolsrc/ed.pla: 1380:                 if type & $F0 == $D0 // Is it a directory?
; toolsrc/ed.pla: 1381:                     putc('/')
; toolsrc/ed.pla: 1382:                     len++
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$60			; LB
	!BYTE	$6C,$47			; DLB	[71]
	!BYTE	$4C			; BRFLS	_B448
	!WORD	_B448-*
	!BYTE	$64,$47			; LLB	[71]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$6C,$48			; DLB	[72]
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$70			; SB
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$54			; CALL	_X004
_F740 	!WORD	0		
	!BYTE	$64,$47			; LLB	[71]
	!BYTE	$3C,$F0			; ANDI	240
	!BYTE	$2A,$D0			; CB	208
	!BYTE	$24			; BRNE	_B450
	!WORD	_B450-*
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$54			; CALL	_X002
_F741 	!WORD	0		
	!BYTE	$64,$48			; LLB	[72]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1383:                 fin
	!BYTE	$74,$48			; SLB	[72]
_B450 
_B451 
; toolsrc/ed.pla: 1384:                 for len = 20 - len downto 1
	!BYTE	$02			; CN	1
	!BYTE	$2A,$14			; CB	20
	!BYTE	$64,$48			; LLB	[72]
	!BYTE	$84			; SUB 
	!BYTE	$A2			; BRLT	_B452
	!WORD	_B452-*
_B453 
	!BYTE	$6C,$48			; DLB	[72]
; toolsrc/ed.pla: 1385:                     putc(' ')
; toolsrc/ed.pla: 1386:                 next
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F742 	!WORD	0		
_B454 
	!BYTE	$A8			; DECBRGE	_B453
	!WORD	_B453-*
_B452 
	!BYTE	$74,$48			; SLB	[72]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1387:             fin
_B448 
_B449 
; toolsrc/ed.pla: 1388:             entry = entry + entrylen
; toolsrc/ed.pla: 1389:         next
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$B0,$44			; ADDLB	[68]
	!BYTE	$76,$4B			; SLW	[75]
_B447 
	!BYTE	$A4			; INCBRLE	_B446
	!WORD	_B446-*
_B445 
	!BYTE	$74,$46			; SLB	[70]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1390:         firstblk = 0
; toolsrc/ed.pla: 1391:     loop
	!BYTE	$00			; CN	0
	!BYTE	$74,$43			; SLB	[67]
_B442 
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$6A			; LAW	_X031+18
_F743 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$22			; BREQ	_B440
	!WORD	_B440-*
_B441 
; toolsrc/ed.pla: 1392:     fileio:close(refnum)
; toolsrc/ed.pla: 1393:     heaprelease(databuff)
; toolsrc/ed.pla: 1394:     putln
; toolsrc/ed.pla: 1395:     return 0
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$6A			; LAW	_X031+16
_F744 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$54			; CALL	_X015
_F745 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_X003
_F746 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$4D			; LEAVE	77
; toolsrc/ed.pla: 1396: end
; toolsrc/ed.pla: 1397: def parsecmd(strptr)
					; strptr -> [0]
_C049 					; parsecmd()
; toolsrc/ed.pla: 1398:     byte cmd
					; cmd -> [2]
; toolsrc/ed.pla: 1399: 
; toolsrc/ed.pla: 1400:     cmd = 0
	!BYTE	$58,$03,$01		; ENTER	3,1
; toolsrc/ed.pla: 1401:     striplead(strptr, ' ')
; toolsrc/ed.pla: 1402:     if ^strptr
; toolsrc/ed.pla: 1403:         cmd = ^(strptr + 1)
; toolsrc/ed.pla: 1404:         memcpy(strptr + 1, strptr + 2, ^strptr)
; toolsrc/ed.pla: 1405:         ^strptr--
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C001
_F747 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B455
	!WORD	_B455-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F748 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1406:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
_B455 
_B456 
; toolsrc/ed.pla: 1407:     if ^strptr
; toolsrc/ed.pla: 1408:         striplead(strptr, ' ')
; toolsrc/ed.pla: 1409:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B457
	!WORD	_B457-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C001
_F749 	!WORD	_C001		
_B457 
_B458 
; toolsrc/ed.pla: 1410:     return cmd
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 1411: end
; toolsrc/ed.pla: 1412: def chkchng
_C050 					; chkchng()
; toolsrc/ed.pla: 1413:     if flags & changed
; toolsrc/ed.pla: 1414:         puts("LOSE CHANGES TO FILE (Y/N)?")
	!BYTE	$68			; LAB	_D046+0
_F750 	!WORD	_D046+0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B459
	!WORD	_B459-*
	!BYTE	$2E			; CS
	!BYTE	$1B
	!BYTE	$4C,$4F,$53,$45,$20,$43,$48,$41
	!BYTE	$4E,$47,$45,$53,$20,$54,$4F,$20
	!BYTE	$46,$49,$4C,$45,$20,$28,$59,$2F
	!BYTE	$4E,$29,$3F
	!BYTE	$54			; CALL	_X004
_F751 	!WORD	0		
; toolsrc/ed.pla: 1415:         if toupper(getc) == 'N'
; toolsrc/ed.pla: 1416:             putln
; toolsrc/ed.pla: 1417:             return FALSE
	!BYTE	$54			; CALL	_X006
_F752 	!WORD	0		
	!BYTE	$54			; CALL	_X021
_F753 	!WORD	0		
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$24			; BRNE	_B461
	!WORD	_B461-*
	!BYTE	$54			; CALL	_X003
_F754 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1418:         fin
_B461 
_B462 
; toolsrc/ed.pla: 1419:         putln
; toolsrc/ed.pla: 1420:     fin
	!BYTE	$54			; CALL	_X003
_F755 	!WORD	0		
_B459 
_B460 
; toolsrc/ed.pla: 1421:     return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1422: end
; toolsrc/ed.pla: 1423: def cmdmode#0
_P000 					; cmdmode#0()
_C051 					; cmdmode()
; toolsrc/ed.pla: 1424:     byte slot, b
					; slot -> [0]
					; b -> [1]
; toolsrc/ed.pla: 1425:     word cmdptr, line
					; cmdptr -> [2]
					; line -> [4]
; toolsrc/ed.pla: 1426:     var i, freepool
					; i -> [6]
					; freepool -> [8]
; toolsrc/ed.pla: 1427: 
; toolsrc/ed.pla: 1428:     conio:gotoxy(0, scrnheight - 1)
	!BYTE	$58,$0A,$00		; ENTER	10,0
; toolsrc/ed.pla: 1429:     conio:clear(cleol)
; toolsrc/ed.pla: 1430:     conio:textctrl(ctrlecho, ON)
; toolsrc/ed.pla: 1431:     conio:textctrl(ctrlcursor, ON)
; toolsrc/ed.pla: 1432:     perr = 0 // Reset perr
; toolsrc/ed.pla: 1433:     line = 0
; toolsrc/ed.pla: 1434:     while not (flags & exit)
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D038+0
_F756 	!WORD	_D038+0		
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_X033+8
_F757 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+6
_F758 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+12
_F759 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X033+12
_F760 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_X032+0
_F761 	!WORD	0+0		
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B465
	!WORD	_B465-*
_B463 
; toolsrc/ed.pla: 1435:         puts(@filename)
; toolsrc/ed.pla: 1436:         cmdptr = gets($BA)
; toolsrc/ed.pla: 1437:         when toupper(parsecmd(cmdptr))
	!BYTE	$26			; LA	_D045+0
_F762 	!WORD	_D045+0		
	!BYTE	$54			; CALL	_X004
_F763 	!WORD	0		
	!BYTE	$2A,$BA			; CB	186
	!BYTE	$54			; CALL	_X007
_F764 	!WORD	0		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$54			; CALL	_C049
_F765 	!WORD	_C049		
	!BYTE	$54			; CALL	_X021
_F766 	!WORD	0		
	!BYTE	$52			; SEL
	!WORD	_B467-*
; toolsrc/ed.pla: 1438:             is 'F' // Find string
_B468 
; toolsrc/ed.pla: 1439:                 if ^cmdptr
; toolsrc/ed.pla: 1440:                     lnupcpy(@findstr, cmdptr)
; toolsrc/ed.pla: 1441:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B469
	!WORD	_B469-*
	!BYTE	$26			; LA	_D044+0
_F767 	!WORD	_D044+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_A001
_F768 	!WORD	_A001		
_B469 
_B470 
; toolsrc/ed.pla: 1442:                 findtxt
; toolsrc/ed.pla: 1443:                 return
	!BYTE	$54			; CALL	_C029
_F769 	!WORD	_C029		
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 1444:             is 'T' // Toggle upper/lower case display
_B471 
; toolsrc/ed.pla: 1445:                 if ^cmdptr
; toolsrc/ed.pla: 1446:                     when toupper(^(cmdptr + 1))
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B472
	!WORD	_B472-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F770 	!WORD	0		
	!BYTE	$52			; SEL
	!WORD	_B475-*
; toolsrc/ed.pla: 1447:                         is 'G' // Gutter view
_B476 
; toolsrc/ed.pla: 1448:                             flags = flags ^ gutter
; toolsrc/ed.pla: 1449:                             viewwidth = scrnwidth - (flags & gutter) - 1
; toolsrc/ed.pla: 1450:                             curshpos(curscol)
; toolsrc/ed.pla: 1451:                             break
	!BYTE	$68			; LAB	_D046+0
_F771 	!WORD	_D046+0		
	!BYTE	$08			; CN	4
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D046+0
_F772 	!WORD	_D046+0		
	!BYTE	$68			; LAB	_D039+0
_F773 	!WORD	_D039+0		
	!BYTE	$68			; LAB	_D046+0
_F774 	!WORD	_D046+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$78			; SAB	_D040+0
_F775 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D058+0
_F776 	!WORD	_D058+0		
	!BYTE	$54			; CALL	_C016
_F777 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B474
	!WORD	_B474-*
; toolsrc/ed.pla: 1452:                         is 'C' // Lower case chip (Apple ][/][+ only)
_B477 
; toolsrc/ed.pla: 1453:                             conio:textctrl(ctrlcase, 0)
; toolsrc/ed.pla: 1454:                             break
	!BYTE	$08			; CN	4
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+12
_F778 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B474
	!WORD	_B474-*
; toolsrc/ed.pla: 1455:                     wend
	!BYTE	$50			; BRNCH	_B474
	!WORD	_B474-*
_B475 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0043
	!WORD	_B477-*
	!WORD	$0047
	!WORD	_B476-*
_B474 
; toolsrc/ed.pla: 1456:                 fin
_B472 
_B473 
; toolsrc/ed.pla: 1457:                 return
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 1458:             is '9' // Goto line #
_B478 
; toolsrc/ed.pla: 1459:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1460:             is '8'
	!BYTE	$76,$04			; SLW	[4]
_B479 
; toolsrc/ed.pla: 1461:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1462:             is '7'
	!BYTE	$76,$04			; SLW	[4]
_B480 
; toolsrc/ed.pla: 1463:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1464:             is '6'
	!BYTE	$76,$04			; SLW	[4]
_B481 
; toolsrc/ed.pla: 1465:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1466:             is '5'
	!BYTE	$76,$04			; SLW	[4]
_B482 
; toolsrc/ed.pla: 1467:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1468:             is '4'
	!BYTE	$76,$04			; SLW	[4]
_B483 
; toolsrc/ed.pla: 1469:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1470:             is '3'
	!BYTE	$76,$04			; SLW	[4]
_B484 
; toolsrc/ed.pla: 1471:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1472:             is '2'
	!BYTE	$76,$04			; SLW	[4]
_B485 
; toolsrc/ed.pla: 1473:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1474:             is '1'
	!BYTE	$76,$04			; SLW	[4]
_B486 
; toolsrc/ed.pla: 1475:                 line++
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1476:             is '0'
	!BYTE	$76,$04			; SLW	[4]
_B487 
; toolsrc/ed.pla: 1477:                 memcpy(cmdptr + 2, cmdptr + 1, ^cmdptr)
; toolsrc/ed.pla: 1478:                 ^(cmdptr + 1) = line + '0' // Push number back on cmdptr
; toolsrc/ed.pla: 1479:                 ^cmdptr++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F779 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1480:                 line = strtonum(cmdptr)
; toolsrc/ed.pla: 1481:                 if line
; toolsrc/ed.pla: 1482:                     curshpos(0)
; toolsrc/ed.pla: 1483:                     cursvpos(line - 1)
; toolsrc/ed.pla: 1484:                fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C007
_F780 	!WORD	_C007		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B488
	!WORD	_B488-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F781 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C017
_F782 	!WORD	_C017		
	!BYTE	$30			; DROP 
_B488 
_B489 
; toolsrc/ed.pla: 1485:             is 'E' // Edit mode
_B490 
; toolsrc/ed.pla: 1486:             is 0
_B491 
; toolsrc/ed.pla: 1487:                 return
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 1488:             is 'A' // Append file
_B492 
; toolsrc/ed.pla: 1489:                 readtxt(cmdptr, numlines)
; toolsrc/ed.pla: 1490:                 flags = flags | changed
; toolsrc/ed.pla: 1491:                 break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D047+0
_F783 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_C009
_F784 	!WORD	_C009		
	!BYTE	$68			; LAB	_D046+0
_F785 	!WORD	_D046+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D046+0
_F786 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1492:             is 'R' // Read file
_B493 
; toolsrc/ed.pla: 1493:                 if chkchng
; toolsrc/ed.pla: 1494:                     inittxtbuf
; toolsrc/ed.pla: 1495:                     strstripcpy(@filename, cmdptr)
; toolsrc/ed.pla: 1496:                     readtxt(@filename, 0)
; toolsrc/ed.pla: 1497:                     flags = flags & ~changed
; toolsrc/ed.pla: 1498:                 fin
	!BYTE	$54			; CALL	_C050
_F787 	!WORD	_C050		
	!BYTE	$4C			; BRFLS	_B494
	!WORD	_B494-*
	!BYTE	$54			; CALL	_C005
_F788 	!WORD	_C005		
	!BYTE	$26			; LA	_D045+0
_F789 	!WORD	_D045+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F790 	!WORD	_C002		
	!BYTE	$26			; LA	_D045+0
_F791 	!WORD	_D045+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C009
_F792 	!WORD	_C009		
	!BYTE	$68			; LAB	_D046+0
_F793 	!WORD	_D046+0		
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D046+0
_F794 	!WORD	_D046+0		
_B494 
_B495 
; toolsrc/ed.pla: 1499:                 break
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1500:             is 'W' // Write file
_B496 
; toolsrc/ed.pla: 1501:                 if ^cmdptr
; toolsrc/ed.pla: 1502:                     strstripcpy(@filename, cmdptr)
; toolsrc/ed.pla: 1503:                 fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B497
	!WORD	_B497-*
	!BYTE	$26			; LA	_D045+0
_F795 	!WORD	_D045+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F796 	!WORD	_C002		
_B497 
_B498 
; toolsrc/ed.pla: 1504:                 writetxt(@filename)
; toolsrc/ed.pla: 1505:                 //if flags & changed; fin
; toolsrc/ed.pla: 1506:                 flags = flags & ~changed
; toolsrc/ed.pla: 1507:                 break
	!BYTE	$26			; LA	_D045+0
_F797 	!WORD	_D045+0		
	!BYTE	$54			; CALL	_C010
_F798 	!WORD	_C010		
	!BYTE	$68			; LAB	_D046+0
_F799 	!WORD	_D046+0		
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D046+0
_F800 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1508:             is 'C' // Catalog
_B499 
; toolsrc/ed.pla: 1509:                 prfiles(cmdptr); break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C048
_F801 	!WORD	_C048		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1510:             is 'P' // Prefix
_B500 
; toolsrc/ed.pla: 1511:                 fileio:setpfx(cmdptr); break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_X031+2
_F802 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1512:             is 'H' // Hardcopy
_B501 
; toolsrc/ed.pla: 1513:                 if ^cmdptr
; toolsrc/ed.pla: 1514:                     slot = cmdptr.1 - '0'
; toolsrc/ed.pla: 1515:                 else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B502
	!WORD	_B502-*
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B503
	!WORD	_B503-*
_B502 
; toolsrc/ed.pla: 1516:                     slot = 1
; toolsrc/ed.pla: 1517:                 fin
	!BYTE	$02			; CN	1
	!BYTE	$74,$00			; SLB	[0]
_B503 
; toolsrc/ed.pla: 1518:                 printtxt(slot)
; toolsrc/ed.pla: 1519:                 break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_C030
_F803 	!WORD	_C030		
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1520:             is 'Q' // Quit
_B504 
; toolsrc/ed.pla: 1521:                 flags = flags | (chkchng ?? exit :: 0)
; toolsrc/ed.pla: 1522:                 if not (flags & exit)
; toolsrc/ed.pla: 1523:                     return
	!BYTE	$68			; LAB	_D046+0
_F804 	!WORD	_D046+0		
	!BYTE	$54			; CALL	_C050
_F805 	!WORD	_C050		
	!BYTE	$4C			; BRFLS	_B505
	!WORD	_B505-*
	!BYTE	$2A,$10			; CB	16
	!BYTE	$50			; BRNCH	_B506
	!WORD	_B506-*
_B505 
	!BYTE	$00			; CN	0
_B506 
	!BYTE	$96			; OR 
	!BYTE	$7C			; DAB	_D046+0
_F806 	!WORD	_D046+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4E			; BRTRU	_B507
	!WORD	_B507-*
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 1524:                 fin
_B507 
_B508 
; toolsrc/ed.pla: 1525:                 break
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1526:            is 'N'
_B509 
; toolsrc/ed.pla: 1527:                 if chkchng
; toolsrc/ed.pla: 1528:                     inittxtbuf
; toolsrc/ed.pla: 1529:                     strstripcpy(@filename, "UNTITLED")
	!BYTE	$54			; CALL	_C050
_F807 	!WORD	_C050		
	!BYTE	$4C			; BRFLS	_B510
	!WORD	_B510-*
	!BYTE	$54			; CALL	_C005
_F808 	!WORD	_C005		
	!BYTE	$26			; LA	_D045+0
_F809 	!WORD	_D045+0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$55,$4E,$54,$49,$54,$4C,$45,$44
	!BYTE	$54			; CALL	_C002
_F810 	!WORD	_C002		
; toolsrc/ed.pla: 1530:                 fin
_B510 
_B511 
; toolsrc/ed.pla: 1531:                 break
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1532:             is 'D' // Dump stats
_B512 
; toolsrc/ed.pla: 1533:                 freepool = 0
; toolsrc/ed.pla: 1534:                 for i = strplmapsize - 1 downto 0
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D051+0
_F811 	!WORD	_D051+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B513
	!WORD	_B513-*
_B514 
	!BYTE	$6E,$06			; DLW	[6]
; toolsrc/ed.pla: 1535:                     slot = ^(strpoolmap + i)
; toolsrc/ed.pla: 1536:                     if slot <> $FF
; toolsrc/ed.pla: 1537:                         for b = 0 to 7
	!BYTE	$6A			; LAW	_D052+0
_F812 	!WORD	_D052+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$60			; LB
	!BYTE	$6C,$00			; DLB	[0]
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$22			; BREQ	_B516
	!WORD	_B516-*
	!BYTE	$0E			; CN	7
	!BYTE	$00			; CN	0
_B519 
	!BYTE	$6C,$01			; DLB	[1]
; toolsrc/ed.pla: 1538:                             if not ((1 << b) & slot)
; toolsrc/ed.pla: 1539:                                 freepool++
	!BYTE	$02			; CN	1
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$9A			; SHL
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B521
	!WORD	_B521-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1540:                             fin
	!BYTE	$76,$08			; SLW	[8]
_B521 
_B522 
; toolsrc/ed.pla: 1541:                         next
_B520 
	!BYTE	$A4			; INCBRLE	_B519
	!WORD	_B519-*
_B518 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1542:                     fin
_B516 
_B517 
; toolsrc/ed.pla: 1543:                 next
_B515 
	!BYTE	$A8			; DECBRGE	_B514
	!WORD	_B514-*
_B513 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1544:                 puts("Pool size: "); puti(strplmapsize*128); putln
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$50,$6F,$6F,$6C,$20,$73,$69,$7A
	!BYTE	$65,$3A,$20
	!BYTE	$54			; CALL	_X004
_F813 	!WORD	0		
; toolsrc/ed.pla: 1545:                 puts("Pool free: "); puti(freepool*16); putln
	!BYTE	$6A			; LAW	_D051+0
_F814 	!WORD	_D051+0		
	!BYTE	$0E			; CN	7
	!BYTE	$9A			; SHL
	!BYTE	$54			; CALL	_X005
_F815 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F816 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$50,$6F,$6F,$6C,$20,$66,$72,$65
	!BYTE	$65,$3A,$20
	!BYTE	$54			; CALL	_X004
_F817 	!WORD	0		
; toolsrc/ed.pla: 1546:                 puts("Num lines: "); puti(numlines); putln
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$54			; CALL	_X005
_F818 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F819 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$4E,$75,$6D,$20,$6C,$69,$6E,$65
	!BYTE	$73,$3A,$20
	!BYTE	$54			; CALL	_X004
_F820 	!WORD	0		
; toolsrc/ed.pla: 1547:                 puts("Clip lines: "); puti(numcliplines); putln
	!BYTE	$6A			; LAW	_D047+0
_F821 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_X005
_F822 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F823 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0C
	!BYTE	$43,$6C,$69,$70,$20,$6C,$69,$6E
	!BYTE	$65,$73,$3A,$20
	!BYTE	$54			; CALL	_X004
_F824 	!WORD	0		
; toolsrc/ed.pla: 1548:                 break
	!BYTE	$6A			; LAW	_D048+0
_F825 	!WORD	_D048+0		
	!BYTE	$54			; CALL	_X005
_F826 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F827 	!WORD	0		
	!BYTE	$50			; BRNCH	_B466
	!WORD	_B466-*
; toolsrc/ed.pla: 1549:             otherwise
_B467 
	!BYTE	$17			; CASEBLOCK
	!WORD	$0000
	!WORD	_B491-*
	!WORD	$0030
	!WORD	_B487-*
	!WORD	$0031
	!WORD	_B486-*
	!WORD	$0032
	!WORD	_B485-*
	!WORD	$0033
	!WORD	_B484-*
	!WORD	$0034
	!WORD	_B483-*
	!WORD	$0035
	!WORD	_B482-*
	!WORD	$0036
	!WORD	_B481-*
	!WORD	$0037
	!WORD	_B480-*
	!WORD	$0038
	!WORD	_B479-*
	!WORD	$0039
	!WORD	_B478-*
	!WORD	$0041
	!WORD	_B492-*
	!WORD	$0043
	!WORD	_B499-*
	!WORD	$0044
	!WORD	_B512-*
	!WORD	$0045
	!WORD	_B490-*
	!WORD	$0046
	!WORD	_B468-*
	!WORD	$0048
	!WORD	_B501-*
	!WORD	$004E
	!WORD	_B509-*
	!WORD	$0050
	!WORD	_B500-*
	!WORD	$0051
	!WORD	_B504-*
	!WORD	$0052
	!WORD	_B493-*
	!WORD	$0054
	!WORD	_B471-*
	!WORD	$0057
	!WORD	_B496-*
; toolsrc/ed.pla: 1550:                 bell
; toolsrc/ed.pla: 1551:                 putc('?')
; toolsrc/ed.pla: 1552:                 putln
; toolsrc/ed.pla: 1553:         wend
	!BYTE	$54			; CALL	_C000
_F828 	!WORD	_C000		
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$54			; CALL	_X002
_F829 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F830 	!WORD	0		
_B466 
; toolsrc/ed.pla: 1554:         if perr
; toolsrc/ed.pla: 1555:             puts("ERROR: $")
	!BYTE	$68			; LAB	_X032+0
_F831 	!WORD	0+0		
	!BYTE	$4C			; BRFLS	_B523
	!WORD	_B523-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$45,$52,$52,$4F,$52,$3A,$20,$24
	!BYTE	$54			; CALL	_X004
_F832 	!WORD	0		
; toolsrc/ed.pla: 1556:             putb(perr)
; toolsrc/ed.pla: 1557:         putln
; toolsrc/ed.pla: 1558:         fin
	!BYTE	$68			; LAB	_X032+0
_F833 	!WORD	0+0		
	!BYTE	$54			; CALL	_X008
_F834 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F835 	!WORD	0		
_B523 
_B524 
; toolsrc/ed.pla: 1559:     loop
_B465 
	!BYTE	$68			; LAB	_D046+0
_F836 	!WORD	_D046+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B463
	!WORD	_B463-*
_B464 
; toolsrc/ed.pla: 1560: end
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/ed.pla: 1561: //
; toolsrc/ed.pla: 1562: // Init editor
; toolsrc/ed.pla: 1563: //
; toolsrc/ed.pla: 1564: arg = argNext(argFirst)
_INIT 
; toolsrc/ed.pla: 1565: if ^arg
; toolsrc/ed.pla: 1566:     while ^(arg+1) == '-'
	!BYTE	$54			; CALL	_X029
_F837 	!WORD	0		
	!BYTE	$54			; CALL	_X030
_F838 	!WORD	0		
	!BYTE	$7A			; SAW	_D049+0
_F839 	!WORD	_D049+0		
	!BYTE	$6A			; LAW	_D049+0
_F840 	!WORD	_D049+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B525
	!WORD	_B525-*
	!BYTE	$50			; BRNCH	_B529
	!WORD	_B529-*
_B527 
; toolsrc/ed.pla: 1567:         when ^(arg+2)
	!BYTE	$6A			; LAW	_D049+0
_F841 	!WORD	_D049+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B531-*
; toolsrc/ed.pla: 1568:             is '4' // Force 40 columns
_B532 
; toolsrc/ed.pla: 1569:                 scrnwidth = 40
; toolsrc/ed.pla: 1570:                 break
	!BYTE	$2A,$28			; CB	40
	!BYTE	$78			; SAB	_D039+0
_F842 	!WORD	_D039+0		
	!BYTE	$50			; BRNCH	_B530
	!WORD	_B530-*
; toolsrc/ed.pla: 1571:             is 'U' // Use extended VIDEX UltraTerm mode
_B533 
; toolsrc/ed.pla: 1572:                 scrnwidth = 80 + ^(arg+3) - '0'
; toolsrc/ed.pla: 1573:                 break
	!BYTE	$2A,$50			; CB	80
	!BYTE	$6A			; LAW	_D049+0
_F843 	!WORD	_D049+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$78			; SAB	_D039+0
_F844 	!WORD	_D039+0		
	!BYTE	$50			; BRNCH	_B530
	!WORD	_B530-*
; toolsrc/ed.pla: 1574:         wend
	!BYTE	$50			; BRNCH	_B530
	!WORD	_B530-*
_B531 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0034
	!WORD	_B532-*
	!WORD	$0055
	!WORD	_B533-*
_B530 
; toolsrc/ed.pla: 1575:         arg = argNext(arg)
; toolsrc/ed.pla: 1576:     loop
	!BYTE	$6A			; LAW	_D049+0
_F845 	!WORD	_D049+0		
	!BYTE	$54			; CALL	_X030
_F846 	!WORD	0		
	!BYTE	$7A			; SAW	_D049+0
_F847 	!WORD	_D049+0		
_B529 
	!BYTE	$6A			; LAW	_D049+0
_F848 	!WORD	_D049+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$22			; BREQ	_B527
	!WORD	_B527-*
_B528 
; toolsrc/ed.pla: 1577:     strcpy(@filename, arg)
; toolsrc/ed.pla: 1578:     arg = argNext(arg)
; toolsrc/ed.pla: 1579: fin
	!BYTE	$26			; LA	_D045+0
_F849 	!WORD	_D045+0		
	!BYTE	$6A			; LAW	_D049+0
_F850 	!WORD	_D049+0		
	!BYTE	$54			; CALL	_X019
_F851 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D049+0
_F852 	!WORD	_D049+0		
	!BYTE	$54			; CALL	_X030
_F853 	!WORD	0		
	!BYTE	$7A			; SAW	_D049+0
_F854 	!WORD	_D049+0		
_B525 
_B526 
; toolsrc/ed.pla: 1580: if waitVBL
; toolsrc/ed.pla: 1581:     cursflash = waitVBL
; toolsrc/ed.pla: 1582: fin
	!BYTE	$54			; CALL	_X035
_F855 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B534
	!WORD	_B534-*
	!BYTE	$54			; CALL	_X035
_F856 	!WORD	0		
	!BYTE	$7A			; SAW	_D060+0
_F857 	!WORD	_D060+0		
_B534 
_B535 
; toolsrc/ed.pla: 1583: flags     = flags | insmode | gutter
; toolsrc/ed.pla: 1584: scrnwidth = conio:textmode(scrnwidth)
; toolsrc/ed.pla: 1585: if scrnwidth > 80 // Lookup UltraTerm screen dimensions
; toolsrc/ed.pla: 1586:     scrnheight = UltraTermHeight[scrnwidth - 81]
; toolsrc/ed.pla: 1587:     scrnwidth  = UltraTermWidth[scrnwidth  - 81]
; toolsrc/ed.pla: 1588: fin
	!BYTE	$68			; LAB	_D046+0
_F858 	!WORD	_D046+0		
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$3E,$04			; ORI	4
	!BYTE	$78			; SAB	_D046+0
_F859 	!WORD	_D046+0		
	!BYTE	$68			; LAB	_D039+0
_F860 	!WORD	_D039+0		
	!BYTE	$6A			; LAW	_X033+14
_F861 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$7C			; DAB	_D039+0
_F862 	!WORD	_D039+0		
	!BYTE	$2A,$50			; CB	80
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B536
	!WORD	_B536-*
	!BYTE	$26			; LA	_D037+0
_F863 	!WORD	_D037+0		
	!BYTE	$68			; LAB	_D039+0
_F864 	!WORD	_D039+0		
	!BYTE	$3A,$51			; SUBI	81
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$7A			; SAW	_D038+0
_F865 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D036+0
_F866 	!WORD	_D036+0		
	!BYTE	$68			; LAB	_D039+0
_F867 	!WORD	_D039+0		
	!BYTE	$3A,$51			; SUBI	81
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$78			; SAB	_D039+0
_F868 	!WORD	_D039+0		
_B536 
_B537 
; toolsrc/ed.pla: 1589: puts("PLEIADES Editor v2.20\n")
	!BYTE	$2E			; CS
	!BYTE	$16
	!BYTE	$50,$4C,$45,$49,$41,$44,$45,$53
	!BYTE	$20,$45,$64,$69,$74,$6F,$72,$20
	!BYTE	$76,$32,$2E,$32,$30,$0D
	!BYTE	$54			; CALL	_X004
_F869 	!WORD	0		
; toolsrc/ed.pla: 1590: inittxtbuf
; toolsrc/ed.pla: 1591: puts(@filename)
; toolsrc/ed.pla: 1592: readtxt(@filename, 0)
; toolsrc/ed.pla: 1593: if ^arg
; toolsrc/ed.pla: 1594:     curshpos(0)
; toolsrc/ed.pla: 1595:     cursvpos(strtonum(arg) - 1)
; toolsrc/ed.pla: 1596: fin
	!BYTE	$54			; CALL	_C005
_F870 	!WORD	_C005		
	!BYTE	$26			; LA	_D045+0
_F871 	!WORD	_D045+0		
	!BYTE	$54			; CALL	_X004
_F872 	!WORD	0		
	!BYTE	$26			; LA	_D045+0
_F873 	!WORD	_D045+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C009
_F874 	!WORD	_C009		
	!BYTE	$6A			; LAW	_D049+0
_F875 	!WORD	_D049+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B538
	!WORD	_B538-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F876 	!WORD	_C016		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D049+0
_F877 	!WORD	_D049+0		
	!BYTE	$54			; CALL	_C007
_F878 	!WORD	_C007		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C017
_F879 	!WORD	_C017		
	!BYTE	$30			; DROP 
_B538 
_B539 
; toolsrc/ed.pla: 1597: conio:clear(cls)
; toolsrc/ed.pla: 1598: drawscrn
; toolsrc/ed.pla: 1599: editmode
; toolsrc/ed.pla: 1600: conio:textmode(0) // Set default mode
; toolsrc/ed.pla: 1601: done
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X033+6
_F880 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C015
_F881 	!WORD	_C015		
	!BYTE	$54			; CALL	_C047
_F882 	!WORD	_C047		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X033+14
_F883 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_DEFCNT	=	53
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C050		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C051		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F361-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F363-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F364-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F365-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F367-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F368-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F369-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F370-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F372-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F373-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F375-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F376-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F377-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F378-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F379-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F382-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F384-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F385-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F386-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F388-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F389-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F390-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F391-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F393-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F395-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F396-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F398-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F400-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F401-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F402-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F403-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F404-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F405-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F406-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F407-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F408-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F410-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F411-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F413-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F414-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F415-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F418-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F420-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F421-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F422-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F423-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F425-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F426-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F429-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F430-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F431-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F432-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F433-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F434-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F435-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F436-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F438-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F440-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F441-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F442-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F443-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F444-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F446-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F448-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F449-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F451-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F452-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F453-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F456-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F458-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F460-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F461-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F464-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F465-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F466-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F467-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F468-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F469-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F470-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F473-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F475-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F477-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F478-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F479-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F482-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F483-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F485-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F487-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F488-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F489-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F490-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F491-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F492-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F493-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F495-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F496-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F497-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F498-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F501-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F504-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F505-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F506-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F507-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F510-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F513-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F515-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F516-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F517-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F518-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F519-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F520-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F521-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F522-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F523-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F525-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F526-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F527-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F528-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F529-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F530-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F532-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F533-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F534-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F535-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F538-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F540-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F541-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F543-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F544-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F545-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F546-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F547-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F548-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F549-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F552-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F561-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F562-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F563-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F564-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F565-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F568-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F569-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F570-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F571-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F572-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F573-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F574-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F578-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F579-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F580-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F581-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F582-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F583-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F586-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F587-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F588-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F589-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F590-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F591-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F592-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F593-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F594-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F595-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F596-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F597-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F598-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F599-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F600-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F601-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F602-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F603-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F604-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F605-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F606-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F607-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F608-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F609-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F610-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F611-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F612-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F613-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F614-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F615-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F616-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F617-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F618-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F619-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F620-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F621-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F622-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F623-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F624-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F625-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F626-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F627-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F628-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F629-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F630-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F631-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F632-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F633-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F634-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F635-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F636-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F637-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F638-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F639-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F640-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F641-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F642-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F643-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F644-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F645-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F646-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F647-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F648-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F649-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F650-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F651-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F652-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F653-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F654-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F655-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F656-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F657-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F658-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F659-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F660-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F661-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F662-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F663-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F664-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F665-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F666-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F667-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F668-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F669-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F670-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F671-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F672-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F673-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F674-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F675-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F676-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F677-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F678-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F679-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F680-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F681-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F682-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F683-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F684-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F685-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F686-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F687-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F688-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F689-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F690-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F691-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F692-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F693-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F694-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F695-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F696-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F697-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F698-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F699-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F700-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F701-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F702-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F703-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F704-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F705-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F706-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F707-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F708-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F709-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F710-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F711-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F712-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F713-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F714-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F715-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F716-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F717-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F718-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F719-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F720-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F721-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F722-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F723-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F724-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F725-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F726-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F727-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F728-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F729-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F730-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F731-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F732-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F733-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F734-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F735-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F736-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F737-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F738-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F739-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F740-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F741-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F742-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F743-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F744-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F745-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F746-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F747-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F748-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F749-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F750-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F751-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F752-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F753-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F754-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F755-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F756-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F757-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F758-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F759-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F760-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F761-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F762-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F763-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F764-_SEGBEGIN		
	!BYTE	7			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F765-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F766-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F767-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F768-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F769-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F770-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F771-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F772-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F773-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F774-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F775-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F776-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F777-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F778-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F779-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F780-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F781-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F782-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F783-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F784-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F785-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F786-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F787-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F788-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F789-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F790-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F791-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F792-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F793-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F794-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F795-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F796-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F797-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F798-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F799-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F800-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F801-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F802-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F803-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F804-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F805-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F806-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F807-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F808-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F809-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F810-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F811-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F812-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F813-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F814-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F815-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F816-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F817-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F818-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F819-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F820-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F821-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F822-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F823-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F824-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F825-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F826-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F827-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F828-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F829-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F830-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F831-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F832-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F833-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F834-_SEGBEGIN		
	!BYTE	8			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F835-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F836-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F837-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F838-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F839-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F840-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F841-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F842-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F843-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F844-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F845-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F846-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F847-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F848-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F849-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F850-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F851-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F852-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F853-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F854-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F855-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F856-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F857-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F858-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F859-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F860-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F861-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F862-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F863-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F864-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F865-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F866-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F867-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F868-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F869-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F870-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F871-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F872-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F873-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F874-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F875-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F876-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F877-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F878-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F879-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F880-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F881-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F882-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F883-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTI
	!BYTE	$D0,$D5,$D4,$49
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	5			; ESD INDEX
	; DCI STRING: GETC
	!BYTE	$C7,$C5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	6			; ESD INDEX
	; DCI STRING: GETS
	!BYTE	$C7,$C5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	7			; ESD INDEX
	; DCI STRING: PUTB
	!BYTE	$D0,$D5,$D4,$42
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	8			; ESD INDEX
	; DCI STRING: PUTH
	!BYTE	$D0,$D5,$D4,$48
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	9			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: HEAPAVAIL
	!BYTE	$C8,$C5,$C1,$D0,$C1,$D6,$C1,$C9,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	16			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: STRCPY
	!BYTE	$D3,$D4,$D2,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	19			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: DIVMOD
	!BYTE	$C4,$C9,$D6,$CD,$CF,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	23			; ESD INDEX
	; DCI STRING: ARGFIRST
	!BYTE	$C1,$D2,$C7,$C6,$C9,$D2,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: ARGNEXT
	!BYTE	$C1,$D2,$C7,$CE,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: PERR
	!BYTE	$D0,$C5,$D2,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	33			; ESD INDEX
	; DCI STRING: WAITVBL
	!BYTE	$D7,$C1,$C9,$D4,$D6,$C2,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	35			; ESD INDEX
	!BYTE	$00			; END OF ESD
