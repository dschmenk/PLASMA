include "inc/cmdsys.plh"

const OP_SRC    = 0
const OP_XOR    = 1
const OP_AND    = 2
const OP_OR     = 3
//
// Apple II graphics soft switches
//
const store80dis   = $C000
const store80ena   = $C001
const show40col    = $C00C
const show80col    = $C00D
const showgraphics = $C050
const showtext     = $C051
const showfull     = $C052
const showmix      = $C053
const page1m       = $C054
const page1x       = $C055
const showhires    = $C057
const dhresena     = $C05E
const dhresdis     = $C05F
const IOUdis       = $C07E
const IOUena       = $C07F
//
// Tile screen addresses
//
byte[] tilebttml = $00,$80,$00,$80,$00,$80,$00,$80
byte             = $28,$A8,$28,$A8,$28,$A8,$28,$A8
byte             = $50,$D0,$50,$D0,$50,$D0,$50,$D0
byte[] tilebttmh = $3C,$3C,$3D,$3D,$3E,$3E,$3F,$3F
byte             = $3C,$3C,$3D,$3D,$3E,$3E,$3F,$3F
byte             = $3C,$3C,$3D,$3D,$3E,$3E,$3F,$3F
//
// HiRes scanline addresses
//
byte hgrscanl[]= $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte hgrscanh[]= $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
//
// Pixel masks for 7 contiguous pixels
//
byte auxclrmsk[] = $0F
byte             = $70
byte             = $00
byte             = $03|$80
byte             = $3C|$80
byte             = $40|$80
byte             = $00
byte memclrmsk[] = $00
byte             = $01
byte             = $1E
byte             = $60
byte             = $00
byte             = $07|$80
byte             = $78|$80
//
// Solid colors
//
byte auxclrsl[] = $00 // black
byte            = $08 // magenta
byte            = $11 // dark blue
byte            = $19 // purple
byte            = $22 // dark green
byte            = $2A // gray 1
byte            = $33 // medium blue
byte            = $3B // light blue
byte            = $44 // brown
byte            = $4C // orange
byte            = $55 // gray 2
byte            = $5D // pink
byte            = $66 // green
byte            = $6E // yellow
byte            = $77 // aqua
byte            = $7F // white
byte auxclrsh[] = $00 // black
byte            = $22 // magenta
byte            = $44 // dark blue
byte            = $66 // purple
byte            = $08 // dark green
byte            = $2A // gray 1
byte            = $4C // medium blue
byte            = $6E // light blue
byte            = $11 // brown
byte            = $33 // orange
byte            = $55 // gray 2
byte            = $77 // pink
byte            = $19 // green
byte            = $3B // yellow
byte            = $5D // aqua
byte            = $7F // white
byte memclrsl[] = $00 // black
byte            = $11 // magenta
byte            = $22 // dark blue
byte            = $33 // purple
byte            = $44 // dark green
byte            = $55 // gray 1
byte            = $66 // medium blue
byte            = $77 // light blue
byte            = $08 // brown
byte            = $19 // orange
byte            = $2A // gray 2
byte            = $3B // pink
byte            = $4C // green
byte            = $5D // yellow
byte            = $6E // aqua
byte            = $7F // white
byte memclrsh[] = $00 // black
byte            = $44 // magenta
byte            = $08 // dark blue
byte            = $4C // purple
byte            = $11 // dark green
byte            = $55 // gray 1
byte            = $19 // medium blue
byte            = $5D // light blue
byte            = $22 // brown
byte            = $66 // orange
byte            = $2A // gray 2
byte            = $6E // pink
byte            = $33 // green
byte            = $77 // yellow
byte            = $3B // aqua
byte            = $7F // white
byte auxclrl, auxclrh, memclrl, memclrh
//
// Divide 7 combined with Modulo 7
//
byte divmod7[]  =   0+0,   0+1,   0+2,   0+3,   0+4,   0+5,   0+6
byte            =   8+0,   8+1,   8+2,   8+3,   8+4,   8+5,   8+6
byte            =  16+0,  16+1,  16+2,  16+3,  16+4,  16+5,  16+6
byte            =  24+0,  24+1,  24+2,  24+3,  24+4,  24+5,  24+6
byte            =  32+0,  32+1,  32+2,  32+3,  32+4,  32+5,  32+6
byte            =  40+0,  40+1,  40+2,  40+3,  40+4,  40+5,  40+6
byte            =  48+0,  48+1,  48+2,  48+3,  48+4,  48+5,  48+6
byte            =  56+0,  56+1,  56+2,  56+3,  56+4,  56+5,  56+6
byte            =  64+0,  64+1,  64+2,  64+3,  64+4,  64+5,  64+6
byte            =  72+0,  72+1,  72+2,  72+3,  72+4,  72+5,  72+6
byte            =  80+0,  80+1,  80+2,  80+3,  80+4,  80+5,  80+6
byte            =  88+0,  88+1,  88+2,  88+3,  88+4,  88+5,  88+6
byte            =  96+0,  96+1,  96+2,  96+3,  96+4,  96+5,  96+6
byte            = 104+0, 104+1, 104+2, 104+3, 104+4, 104+5, 104+6
byte            = 112+0, 112+1, 112+2, 112+3, 112+4, 112+5, 112+6
byte            = 120+0, 120+1, 120+2, 120+3, 120+4, 120+5, 120+6
byte            = 128+0, 128+1, 128+2, 128+3, 128+4, 128+5, 128+6
byte            = 136+0, 136+1, 136+2, 136+3, 136+4, 136+5, 136+6
byte            = 144+0, 144+1, 144+2, 144+3, 144+4, 144+5, 144+6
byte            = 152+0, 152+1, 152+2, 152+3, 152+4, 152+5, 152+6
byte            = 160+0, 160+1, 160+2, 160+3, 160+4, 160+5, 160+6
byte            = 168+0, 168+1, 168+2, 168+3, 168+4, 168+5, 168+6
byte            = 176+0, 176+1, 176+2, 176+3, 176+4, 176+5, 176+6
byte            = 184+0, 184+1, 184+2, 184+3, 184+4, 184+5, 184+6
byte            = 192+0, 192+1, 192+2, 192+3, 192+4, 192+5, 192+6
byte            = 200+0, 200+1, 200+2, 200+3, 200+4, 200+5, 200+6
byte            = 208+0, 208+1, 208+2, 208+3, 208+4, 208+5, 208+6
byte            = 216+0, 216+1, 216+2, 216+3, 216+4, 216+5, 216+6
byte            = 224+0, 224+1, 224+2, 224+3, 224+4, 224+5, 224+6
byte            = 232+0, 232+1, 232+2, 232+3, 232+4, 232+5, 232+6
byte            = 240+0, 240+1, 240+2, 240+3, 240+4, 240+5, 240+6
byte            = 248+0, 248+1, 248+2, 248+3, 248+4, 248+5, 248+6
//
// Color -> DHGR pixel
//
byte[] dhgrPix  = 2, 4, 8, 1
byte[] dhgrMask = 13, 12, 7, 14
///
// Destination surface values
//
const DST_SCREEN    = 0
const DST_MEMORY    = 1
word surfWidth, surfWidth7, surfHeight, surfPtr, surfSpan
byte dhgrSurface, opScr, opMem
//
// Surface independent entrypoints
//
asm plvmzp#0
!SOURCE    "vmsrc/apple/plvmzp.inc"
end
export asm dcgrPixel(x, y)#0
        JMP     $1000
end
export asm dcgrHLin(x1, x2, y)#0
        JMP     $1000
end
export asm dcgrVLin(y1, y2, x)#0
        JMP     $1000
end
export asm dcgrBitMap(x, y, bitw, bith, bitptr)#0
        JMP     $1000
end
export asm dcgrPixMap(x, y, pixw, pixh, pixptr)#0
        JMP     $1000
end
export asm dcgrRleMap(x, y, pixw, pixh, pixptr)#0
        JMP     $1000
end
export asm dhgrScrBl7(x7, y, w7, h)#0
        JMP     $1000
end
export asm dhgrMemBl7(x7, y, w7, h, memptr, memspan)#0
        JMP     $1000
end
export asm dhgrClearBl7(x7, y, w7, h)#0
        JMP     $1000
end
export asm dhgrTiles(x7, y8, strptr, strlen, tileset)#0
        JMP     $1000
end
//
// Internal routine to clip x7 and width7 to destination width in A REG
//
asm _clipX#0
        STA     TMPL        ; DST_WIDTH
        LDA     ESTKH-1,X   ; X COORD
        BMI     NEGX        ; IS NEG?
        LDA     ESTKL-1,X   ; X COORD
        CMP     TMPL        ; > DST_WIDTH?
        BCS     INVISX      ; YEP, X OFF RIGHT EDGE
        ;CLC
        ADC     ESTKL-3,X   ; X + WIDTH
        CMP     TMPL        ; >= DST_WIDTH?
        BCS     +
        LDA     #$00        ; FULLY VISIBLE
        RTS
+       LDA     TMPL        ; CLIP WIDTH TO DST_WIDTH
        ;SEC
        SBC     ESTKL-1,X
        STA     ESTKL-3,X   ; WIDTH = DST_WIDTH - X
        CLC
        LDA     #$00        ; VISIBLE WITH WIDTH CLIP
        RTS
; X NEGATIVE, CHECK WITH W ADDED
NEGX    LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; X + WIDTH
        PHA
        LDA     ESTKH-1,X
        ADC     ESTKH-3,X
        BMI     ++          ; STILL NEG?, OFF LEFT EDGE
        PLA
        BEQ     INVISX      ; OR ZERO WIDTH?
        CMP     TMPL        ; > DST_WIDTH?
        BCC     +           ; YEP, SPANS DST_WIDTH
        LDA     TMPL        ; WIDTH = DST_WIDTH
+       STA     ESTKL-3,X   ; WIDTH = VISIBLE AMOUNT
        LDA     #$00
        SEC
        SBC     ESTKL-1,X   ; -X COORD
        PHA                 ; SAVE FOR SRC/DST CLIP OFFSET
        LDA     #$00
        STA     ESTKL-1,X   ; CLIP X COORD TO LEFT EDGE
        STA     ESTKH-1,X
        PLA                 ; VISIBLE WITH X CLIP
        CLC
        RTS
++      PLA
INVISX  SEC
        RTS
end
asm _clipY#0
        STA     TMPL        ; DST_HEIGHT
        LDA     ESTKH-2,X   ; Y COORD
        BMI     NEGY        ; IS NEG?
        LDA     ESTKL-2,X   ; Y COORD
        CMP     TMPL        ; > DST_HEIGHT?
        BCS     INVISY      ; YEP, Y OFF BOTTOM EDGE
        ;CLC
        ADC     ESTKL-4,X   ; Y + HEIGHT
        CMP     TMPL        ; >= DST_HEIGHT
        BCS     +
        LDA     #$00        ; FULLY VISIBLE
        RTS
+       LDA     TMPL        ; CLIP HEIGHT TO DST_HEIGHT
        ;SEC
        SBC     ESTKL-2,X
        STA     ESTKL-4,X   ; HEIGHT = DST_HEIGHT - Y
        CLC
        LDA     #$00        ; VISIBLE WITH HEIGHT CLIP
        RTS
; Y NEGATIVE, CHECK WITH H ADDED
NEGY    LDA     ESTKL-2,X   ; Y COORD
        CLC
        ADC     ESTKL-4,X   ; Y + HEIGHT
        PHA
        LDA     ESTKH-2,X
        ADC     ESTKH-4,X
        BMI     ++          ; STILL NEG?, OFF TOP EDGE
        PLA
        BEQ     INVISY      ; OR ZERO HEIGHT?
        CMP     TMPL        ; > DST_HEIGHT?
        BCC     +           ; YEP, SPANS DST_HEIGHT
        LDA     TMPL        ; HEIGHT = DST_HEIGHT
+       STA     ESTKL-4,X   ; HEIGHT = VISIBLE AMOUNT
        LDA     #$00
        SEC
        SBC     ESTKL-2,X   ; -Y COORD
        PHA                 ; SAVE FOR SRC/DST CLIP OFFSET
        LDA     #$00
        STA     ESTKL-2,X   ; CLIP Y COORD TO TOP EDGE
        STA     ESTKH-2,X
        PLA                 ; VISIBLE WITH Y CLIP
        CLC
        RTS
++      PLA
INVISY  SEC
        RTS
end
//
// Exported assembly routines for double color functions
//
export asm dcgrColor(c)#0
        LDA     ESTKL,X
        INX
        AND     #$0F
        TAY
end
asm _dcgrColorA
        LDA     $1000,Y     ; AUXCLRSL
        STA     $5000       ; AUXCLRL
        LDA     $2000,Y     ; AUXCLRSH
        STA     $5001       ; AUXCLRH
        LDA     $3000,Y     ; MEMCLRSL
        STA     $5002       ; MEMCLRL
        LDA     $4000,Y     ; MEMCLRSH
        STA     $5003       ; MEMCLRH
        RTS
end
//===============================\\
//                               \\
// Double Color pixel operations \\
//                               \\
//===============================\\
//
// Screen functions
//
asm dcgrPlotScr(x, y)#0
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; Y COORD
        CPY     #192
        BCS     RETPLTS
end
asm     _dcgrPlotScrA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-1,X   ; X COORD
        CPY     #140
        BCS     RETPLTS
end
asm     _jmpOpPlotScr
        JMP     $A000
end
//
// Plot OP_SRC
//
asm     _dcgrPlotScrB
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; MOD7
end
asm     _dcgrPlotScrC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +
end
asm     _dcgrPlotScrD
        LDA     $5000       ; AUXCLRL
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+       INY
end
asm     _dcgrPlotScrE
        LDA     $5001       ; AUXCLRH
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrPlotScrF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     RETPLTS
        STA     $C054       ; PAGE1M
        BMI     +
end
asm     _dcgrPlotScrG
        LDA     $5002       ; MEMCLRL
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
+       INY
end
asm     _dcgrPlotScrH
        LDA     $5003       ; MEMCLRH
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
RETPLTS LDX     ESP
        RTS
end
//
// Plot OP_XOR,OP_AND,OP_OR
//
asm     _dcgrOpPlotScrB
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; MOD7
end
asm     _dcgrOpPlotScrC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +
end
asm     _dcgrOpPlotScrD
        AND     $5000       ; AUXCLRL
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+       INY
end
asm     _dcgrOpPlotScrE
        AND     $5001       ; AUXCLRH
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrOpPlotScrF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     RETPLTS
        STA     $C054       ; PAGE1M
        BMI     +
end
asm     _dcgrOpPlotScrG
        AND     $5002       ; MEMCLRL
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
+       INY
end
asm     _dcgrOpPlotScrH
        AND     $5003       ; MEMCLRH
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
end
asm dcgrHLinScr(x1, x2, y)#0
        INX
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; ADJUST FOR BNE BELOW
        INY
        STY     TMPH
        LDY     ESTKL-3,X   ; Y COORD
end
asm     _dcgrHLinScrA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-1,X   ; X1 COORD
end
asm     _dcgrHLinScrB
-       JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        INC     ESTKL-1,X
        LDY     ESTKL-1,X   ; X1 COORD
        CPY     TMPH        ; X2 COORD
        BNE     -
        RTS
end
asm dcgrVLinScr(y1, y2, x)#0
        INX
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; ADJUST BNE BELOW
        INY
        STY     TMPH
        LDY     ESTKL-1,X   ; Y1 COORD
end
asm     _dcgrVLinScrA
-       LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-3,X   ; X COORD
end
asm     _dcgrVLinScrB
        JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        INC     ESTKL-1,X
        LDY     ESTKL-1,X   ; Y1 COORD
        CPY     TMPH        ; Y2 COORD
        BNE     -
        RTS
end
asm dcgrBitMapScr(x, y, bitw, bith, bitptr)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKH-2,X   ; MSB YCOORD
        BPL     ++
-       LDA     ESTKL-3,X   ; WIDTH
        CLC
        ADC     #$07
        LSR                 ; WIDTH/8
        LSR
        LSR
        CLC
        ADC     ESTKL-5,X   ; BITPTR += SPAN
        STA     ESTKL-5,X
        BCC     +
        INC     ESTKH-5,X
+       DEC     ESTKL-4,X   ; HEIGHT
        BEQ     RETBITS
        INC     ESTKL-2,X
        BNE     -
;        INC     ESTKH-2,X
;        BMI     -
++      LDA     ESTKL-5,X   ; BITPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        ADC     ESTKL-3,X   ; WIDTH
        STA     TMPH        ; RIGHT EDGE
YBITS   LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        CPY     #192        ; OFF SCREEN?
        BCS     RETBITS
end
asm     _dcgrBitmapScrA
+       LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     ESTKL-1,X   ; X1 COORD
        STA     ESTKH-1,X   ; CURRENT X COORD
BITS8   LDY     #$08
        STY     TMPL        ; BIT COUNT
        LDY     #$00
        LDA     (SRC),Y     ; SRC BITS
        INC     SRCL
        BNE     +
        INC     SRCH
+       LDY     ESTKH-1,X   ; CURRENT X COORD
BITSCR  LSR
        BCC     +
        CPY     #140        ; OFF SCREEN?
        BCS     +
        PHA
end
asm     _dcgrBitmapScrB
        JSR     $1000       ; PLOT PIXEL
        PLA
+       INC     ESTKH-1,X   ; X++
        LDY     ESTKH-1,X   ; CURRENT X COORD
        CPY     TMPH        ; AT RIGHT EDGE?
        BEQ     NXTBITS
        DEC     TMPL        ; BIT COUNT
        BNE     BITSCR
        BEQ     BITS8
NXTBITS DEC     ESTKL-4,X   ; HEIGHT
        BNE     YBITS       ; NEXT ROW
RETBITS RTS
end
asm dcgrPixMapScr(x, y, pixw, pixh, pixptr)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKH-2,X   ; MSB YCOORD
        BPL     ++
-       LDA     ESTKL-3,X   ; WIDTH
        LSR                 ; WIDTH/2
        ADC     ESTKL-5,X   ; PIXPTR += SPAN
        STA     ESTKL-5,X
        BCC     +
        INC     ESTKH-5,X
+       DEC     ESTKL-4,X   ; HEIGHT
        BEQ     RETBITS
        INC     ESTKL-2,X
        BNE     -
;        INC     ESTKH-2,X
;        BMI     -
++      LDA     ESTKL-5,X   ; PIXPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKH-3,X   ; -> RIGHT EDGE
YPIXS   LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        CPY     #192        ; OFF SCREEN?
        BCS     RETPIXS
end
asm     _dcgrPixmapScrA
+       LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     ESTKL-1,X   ; X COORD
        STA     TMPL
        LDY     #$00
PIXSCRL CMP     #140        ; OFF SCREEN?
        BCS     PIXSCRH
        LDA     (SRC),Y     ; LO NIBBLE SRC PIXEL
        AND     #$0F
        CMP     #$05        ; TRANSPARENT?
        BEQ     PIXSCRH
        TAY
end
asm     _dcgrPixmapScrB
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrPixmapScrC
        JSR     $1000       ; PLOT PIXEL
        LDY     #$00
PIXSCRH INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     ++
        CMP     #140        ; OFF SCREEN?
        BCS     +
        LDA     (SRC),Y     ; HI NIBBLE SRC PIXEL
        LSR
        LSR
        LSR
        LSR
        CMP     #$05        ; TRANSPARENT?
        BEQ     +
        TAY
end
asm     _dcgrPixmapScrD
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrPixmapScrE
        JSR     $1000       ; PLOT PIXEL
        LDY     #$00
+       INC     TMPL
        LDA     TMPL
++      INC     SRCL
        BNE     +
        INC     SRCH
+       CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BNE     PIXSCRL
NXTPIXS DEC     ESTKL-4,X   ; HEIGHT
        BNE     YPIXS       ; NEXT ROW
RETPIXS RTS
end
asm dcgrRleMapScr(x, y, pixw, pixh, pixptr)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKL-5,X   ; PIXPTR
        SEC
        SBC     #$02
        STA     SRCL
        LDA     ESTKH-5,X
        SBC     #$00
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKH-3,X   ; -> RIGHT EDGE
YRLES   LDA     ESTKL-1,X   ; X COORD
        STA     TMPL
        LDY     ESTKL-2,X   ; Y COORD
        end
asm     _dcgrRlemapScrA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
RUNLENS LDA     SRCL        ; NEXT RUN
        CLC
        ADC     #$02
        STA     SRCL
        BCC     +
        INC     SRCH
+       LDA     ESTKL-2,X   ; Y COORD
        CMP     #192        ; OFF SCREEN?
        BCS     SKPRUNS
        LDY     #$00
        LDA     (SRC),Y     ; RUN LENGTH
        STA     TMPH
        INY
        LDA     (SRC),Y     ; SRC PIXELS
        CMP     #$55        ; FULLY XPARENT RUN
        BEQ     SKPRUNS
        LDA     TMPL        ; X COORD
RLESCRL CMP     #140        ; OFF SCREEN?
        BCS     RLESCRH
        LDA     (SRC),Y     ; LO NIBBLE SRC PIXEL
        AND     #$0F
        CMP     #$05        ; TRANSPARENT?
        BEQ     RLESCRH
        TAY
end
asm     _dcgrRLEmapScrB
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrRlemapScrC
        JSR     $1000       ; PLOT PIXEL
        LDY     #$01
RLESCRH INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTRLES
        DEC     TMPH        ; RUN LENGTH
        BEQ     RUNLENS
        CMP     #140        ; OFF SCREEN?
        BCS     +
        LDA     (SRC),Y     ; HI NIBBLE SRC PIXEL
        LSR
        LSR
        LSR
        LSR
        CMP     #$05        ; TRANSPARENT?
        BEQ     +
        TAY
end
asm     _dcgrRlemapScrD
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrRlemapScrE
        JSR     $1000       ; PLOT PIXEL
        LDY     #$01
+       INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTRLES
        DEC     TMPH        ; RUN LENGTH
        BNE     RLESCRL
        BEQ     RUNLENS
NXTRLES INC     ESTKL-2,X   ; Y COORD++
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YRLES       ; NEXT ROW
        RTS
SKPRUNS LDY     #$00
        LDA     (SRC),Y     ; RUN LENGTH
        CLC
        ADC     TMPL
        STA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTRLES
        BCC     RUNLENS
end
//
// Memory destination functions
// Memory Block format: AUX scanline followed by MAIN scanline
//
asm dcgrPlotMem(x, y, memptr, memspan)#0
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKL-3,X   ; MEMPTR
        STA     DSTL
        LDA     ESTKH-3,X
        STA     DSTH
        LDY     ESTKL-2,X   ; Y COORD
        BEQ     +
-       CLC                 ; ADVANCE TO Y SCANLINE
        LDA     ESTKL-4,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-4,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDA     ESTKL-4,X   ; SPAN
        LDY     ESTKL-1,X   ; X COORD
end
asm     _jmpOpPlotMem
        JMP     $A000
end
asm     _dcgrPlotMemB
        LSR
        STA     TMPH
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; MOD7
end
//
// Plot OP_SRC
//
asm     _dcgrPlotMemC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        BMI     +
end
asm     _dcgrPlotMemD
        LDA     $5000       ; AUXCLRL
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+       INY
end
asm     _dcgrPlotMemE
        LDA     $5001       ; AUXCLRH
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        DEY
++      TYA
        CLC
        ADC     TMPH        ; ADVANCE TO MEM HALF OF SCANLINE
        TAY                 ; SPAN / 2
end
asm     _dcgrPlotMemF
        LDA     $4001,X     ; MEMCLRMSK
        BEQ     RETPLTM
        BMI     +
end
asm     _dcgrPlotMemG
        LDA     $5002       ; MEMCLRL
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
+       INY
end
asm     _dcgrPlotMemH
        LDA     $5003       ; MEMCLRH
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
RETPLTM LDX     ESP
        RTS
end
//
// Plot OP_XOR,OP_AND,OP_OR
//
asm     _dcgrOpPlotMemB
        LSR
        STA     TMPH
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; MOD7
end
asm     _dcgrOpPlotMemC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        BMI     +
end
asm     _dcgrOpPlotMemD
        AND     $5000       ; AUXCLRL
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+       INY
end
asm     _dcgrOpPlotMemE
        AND     $5001       ; AUXCLRH
        EOR     (DST),Y
        STA     (DST),Y
        DEY
++      TYA
        CLC
        ADC     TMPH        ; ADVANCE TO MEM HALF OF SCANLINE
        TAY                 ; SPAN / 2
end
asm     _dcgrOpPlotMemF
        LDA     $4001,X     ; MEMCLRMSK
        BEQ     RETPLTM
        BMI     +
end
asm     _dcgrOpPlotMemG
        AND     $5002       ; MEMCLRL
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
+       INY
end
asm     _dcgrOpPlotMemH
        AND     $5003       ; MEMCLRH
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
end
asm dcgrHLinMem(x1, x2, y, memptr, memspan)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKL-4,X   ; MEMPTR
        STA     DSTL
        LDA     ESTKH-4,X
        STA     DSTH
        LDA     ESTKL-3,X   ; Y COORD
        BEQ     +
        TAY
-       CLC                 ; ADVANCE TO Y SCANLINE
        LDA     ESTKL-5,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-5,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDY     ESTKL-1,X   ; X1 COORD
-       TYA
        PHA
        LDA     ESTKL-5,X   ; SPAN
end
asm     _dcgrHLinMemB
        JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        PLA
        TAY
        INY
        CMP     ESTKL-2,X   ; X2 COORD
        BNE     -
        RTS
end
asm dcgrVLinMem(y1, y2, x, memptr, memspan)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKL-4,X   ; MEMPTR
        STA     DSTL
        LDA     ESTKH-4,X
        STA     DSTH
        LDY     ESTKL-1,X   ; Y1
        BEQ     YVM
        CLC                 ; ADVANCE TO Y SCANLINE
-       LDA     ESTKL-5,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-5,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
YVM     LDY     ESTKL-3,X   ; X COORD
        LDA     ESTKL-5,X   ; SPAN
end
asm     _dcgrVLinMemB
        JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        CLC
        LDA     ESTKL-5,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-5,X
        ADC     DSTH
        STA     DSTH
        LDA     ESTKL-1,X   ; Y1 COORD
        INC     ESTKL-1,X   ; Y1++
        CMP     ESTKL-2,X   ; Y2 COORD
        BNE     YVM
RETVLM  RTS
end
asm dcgrBitMapMem(x, y, bitw, bith, bitptr, memw, memh, memptr, memspan)#0
        TXA
        CLC
        ADC     #9
        TAX
        STX     ESP
        LDA     ESTKH-2,X   ; MSB YCOORD
        BPL     ++
-       LDA     ESTKL-3,X   ; WIDTH
        CLC
        ADC     #$07
        LSR                 ; WIDTH/8
        LSR
        LSR
        CLC
        ADC     ESTKL-5,X   ; BITPTR += SPAN
        STA     ESTKL-5,X
        BCC     +
        INC     ESTKH-5,X
+       DEC     ESTKL-4,X   ; HEIGHT
        BEQ     RETVLM
        INC     ESTKL-2,X
        BNE     -
;        INC     ESTKH-2,X
;        BMI     -
++      LDA     ESTKL-8,X   ; DST PTR
        STA     DSTL
        LDA     ESTKH-8,X
        STA     DSTH
        LDY     ESTKL-2,X   ; Y COORD
        BEQ     +
        ;CLC                ; ADVANCE TO Y SCANLINE
-       LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDA     ESTKL-5,X   ; BITPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKH-3,X   ; RIGHT EDGE
YBITM   LDA     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        CMP     ESTKL-7,X   ; OUT OF DST BOUNDS?
        BCS     RETBITM
        LDA     ESTKL-1,X   ; X COORD
        STA     ESTKH-1,X   ; CURRENT X COORD
BITM8   LDA     #8
        STA     ESTKH-2,X   ; BIT COUNT
        LDY     #$00
        LDA     (SRC),Y     ; SRC BITMAP
        STA     TMPL
        INC     SRCL
        BNE     +
        INC     SRCH
+       LDA     ESTKH-1,X   ; CURRENT X COORD
BITMEM  LSR     TMPL
        BCC     +
        CMP     ESTKL-6,X   ; OUT OF DST BOUNDS?
        BCS     +
        TAY
        LDA     ESTKL-9,X   ; SPAN
end
asm     _dcgrBitmapMemA
        JSR     $1000       ; PLOT PIXEL
+       INC     ESTKH-1,X   ; X++
        LDA     ESTKH-1,X   ; CURRENT X COORD
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTBITM
        DEC     ESTKH-2,X   ; BIT COUNT--
        BNE     BITMEM
        BEQ     BITM8
NXTBITM CLC
        LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YBITM       ; NEXT ROW
RETBITM RTS
end
asm dcgrPixMapMem(x, y, pixw, pixh, pixptr, memw, memh, memptr, memspan)#0
        TXA
        CLC
        ADC     #9
        TAX
        STX     ESP
        LDA     ESTKH-2,X   ; MSB YCOORD
        BPL     ++
-       LDA     ESTKL-3,X   ; WIDTH
        LSR                 ; WIDTH/2
        ADC     ESTKL-5,X   ; PIXPTR += SPAN
        STA     ESTKL-5,X
        BCC     +
        INC     ESTKH-5,X
+       DEC     ESTKL-4,X   ; HEIGHT
        BEQ     RETBITM
        INC     ESTKL-2,X
        BNE     -
;        INC     ESTKH-2,X
;        BMI     -
++      LDA     ESTKL-8,X   ; DST PTR
        STA     DSTL
        LDA     ESTKH-8,X
        STA     DSTH
        LDY     ESTKL-2,X   ; Y COORD
        BEQ     +
-       CLC                 ; ADVANCE TO Y SCANLINE
        LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDA     ESTKL-5,X   ; PIXPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKH-3,X   ; -> RIGHT EDGE
YPIXM   LDA     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        CMP     ESTKL-7,X   ; OUT OF DST BOUNDS?
        BCS     RETPIXM
end
asm     _dcgrPixmapMemA
        LDA     ESTKL-1,X   ; X COORD
        STA     TMPL
        LDY     #$00
PIXMEML CMP     ESTKL-6,X   ; OUT OF DST BOUNDS?
        BCS     PIXMEMH
        LDA     (SRC),Y     ; LO NIBBLE SRC PIXEL
        AND     #$0F
        CMP     #$05        ; TRANSPARENT?
        BEQ     PIXMEMH
        TAY
end
asm     _dcgrPixmapMemB
        JSR     $2000       ; SET COLOR
        LDA     ESTKL-9,X   ; SPAN
        LDY     TMPL
end
asm     _dcgrPixmapMemC
        JSR     $1000       ; PLOT PIXEL
        LDY     #$00
PIXMEMH INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     ++          ; NEXT ROW
        CMP     ESTKL-6,X   ; OUT OF DST BOUNDS?
        BCS     +
        LDA     (SRC),Y     ; HI NIBBLE SRC PIXEL
        LSR
        LSR
        LSR
        LSR
        CMP     #$05        ; TRANSPARENT?
        BEQ     +
        TAY
end
asm     _dcgrPixmapMemD
        JSR     $2000       ; SET COLOR
        LDA     ESTKL-9,X   ; SPAN
        LDY     TMPL
end
asm     _dcgrPixmapMemE
        JSR     $1000       ; PLOT PIXEL
        LDY     #$00
+       INC     TMPL
        LDA     TMPL
++      INC     SRCL        ; PIXPTR
        BNE     +
        INC     SRCH
+       CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BNE     PIXMEML
NXTPIXM CLC
        LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YPIXM       ; NEXT ROW
RETPIXM RTS
end
asm dcgrRleMapMem(x, y, pixw, pixh, pixptr, memw, memh, memptr, memspan)#0
        TXA
        CLC
        ADC     #9
        TAX
        STX     ESP
        LDA     ESTKL-8,X   ; DST PTR
        STA     DSTL
        LDA     ESTKH-8,X
        STA     DSTH
        LDY     ESTKL-2,X   ; Y COORD
        BEQ     +
-       CLC                 ; ADVANCE TO Y SCANLINE
        LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDA     ESTKL-5,X   ; PIXPTR
        SEC
        SBC     #$02
        STA     SRCL
        LDA     ESTKH-5,X
        SBC     #$00
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKH-3,X   ; -> RIGHT EDGE
        BNE     YRLEM       ; BRA

SKPRUNM LDY     #$00
        LDA     (SRC),Y     ; RUN LENGTH
        CLC
        ADC     TMPL
        STA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BNE     RUNLENM
        ;BCS     NXTRLEM
NXTRLEM CLC
        LDA     ESTKL-9,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-9,X
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YRLEM       ; NEXT ROW
        RTS

YRLEM   LDA     ESTKL-1,X   ; X COORD
        STA     TMPL
RUNLENM LDA     SRCL        ; NEXT RUN
        CLC
        ADC     #$02
        STA     SRCL
        BCC     +
        INC     SRCH
+       LDA     ESTKL-2,X   ; Y COORD
        CMP     ESTKL-7,X   ; OUT OF DST BOUNDS?
        BCS     SKPRUNM
        LDY     #$00
        LDA     (SRC),Y     ; RUN LENGTH
        STA     ESTKH-4,X
        INY
        LDA     (SRC),Y     ; SRC PIXELS
        CMP     #$55        ; FULLY XPARENT RUN
        BEQ     SKPRUNM
        LDA     TMPL        ; X COORD
RLEMEML CMP     ESTKL-6,X   ; OUT OF DST BOUNDS?
        BCS     RLEMEMH
        LDA     (SRC),Y     ; LO NIBBLE SRC PIXEL
        AND     #$0F
        CMP     #$05        ; TRANSPARENT?
        BEQ     RLEMEMH
        TAY
end
asm     _dcgrRlemapMemB
        JSR     $2000       ; SET COLOR
        LDA     ESTKL-9,X   ; SPAN
        LDY     TMPL
end
asm     _dcgrRlemapMemC
        JSR     $1000       ; PLOT PIXEL
        LDY     #$01
RLEMEMH INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTRLEM     ; NEXT
        DEC     ESTKH-4,X   ; RUN LENGTH
        BEQ     RUNLENM
        CMP     ESTKL-6,X   ; OUT OF DST BOUNDS?
        BCS     +
        LDA     (SRC),Y     ; HI NIBBLE SRC PIXEL
        LSR
        LSR
        LSR
        LSR
        CMP     #$05        ; TRANSPARENT?
        BEQ     +
        TAY
end
asm     _dcgrRlemapMemD
        JSR     $2000       ; SET COLOR
        LDA     ESTKL-9,X   ; SPAN
        LDY     TMPL
end
asm     _dcgrRlemapMemE
        JSR     $1000       ; PLOT PIXEL
        LDY     #$01
+       INC     TMPL
        LDA     TMPL
        CMP     ESTKH-3,X   ; AT RIGHT EDGE?
        BEQ     NXTRLEM
        DEC     ESTKH-4,X   ; RUN LENGTH
        BNE     RLEMEML
        BEQ     RUNLENM
end
//===================\\
//                   \\
// Block7 operations \\
//                   \\
//===================\\
//
// Screen -> Memory Block7 Transfer
//
asm dhgrScrBl7Mem(x7, y, w7, h, memptr, memspan)#0
        TXA
        CLC
        ADC     #6
        TAX
        LDA     ESTKL-5,X   ; MEMPTR
        SEC
        SBC     #$01
        STA     DSTL
        LDA     ESTKH-5,X
        SBC     #$00
        STA     DSTH
        ;LSR     ESTKH-6,X   ; SPAN / 2
        ;ROR     ESTKL-6,X
        LSR     ESTKL-6,X   ; SPAN / 2
        ASL     ESTKL-1,X   ; X7 COORD * 2
        ASL     ESTKL-3,X   ; WIDTH7 * 2
YS7M    LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        LDA     ESTKL-1,X   ; X7 COORD
        ;CLC
end
asm     _dcgrScrBl7MemA
        ADC     $2000,Y     ; HGRSCANL
        STA     SRCL
        LDA     #$00
        ADC     $3000,Y     ; HGRSCANH
        STA     SRCH
        LDA     SRCL
        BNE     +
        DEC     SRCH
+       DEC     SRCL
        STA     $C055       ; PAGE1X
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        STA     $C054       ; PAGE1M
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YS7M
RETS7M  RTS
end
//
// Memory -> Screen Block7 Transfer
//
asm dhgrMemBl7Scr(x7, y, w7, h, memptr, memspan)#0
        TXA
        CLC
        ADC     #6
        TAX
        LDA     #20
end
asm     _clipXMemBl7Src
        JSR     $F000
        BCS     RETS7M
        ASL
        ;CLC
        ADC     ESTKL-5,X   ; MEMPTR
        STA     SRCL
        LDA     #$00
        ADC     ESTKH-5,X
        STA     SRCH
        LDA     #192
end
asm     _clipYMemBl7Scr
        JSR     $E000       ; CLIPY
        BCS     RETS7M      ; CLIPPED AWAY
        BEQ     +
        TAY
-       ;CLC                 ; ADVANCE TO MEM Y SCANLINE
        LDA     ESTKL-6,X   ; SPAN
        ADC     SRCL
        STA     SRCL
        LDA     #$00        ; ESTKH-6,X
        ADC     SRCH
        STA     SRCH
        DEY
        BNE     -
+       ;LSR     ESTKH-6,X   ; SPAN / 2
        ;ROR     ESTKL-6,X
        LSR     ESTKL-6,X
        ASL     ESTKL-1,X   ; X7 COORD * 2
        ASL     ESTKL-3,X   ; WIDTH7 * 2
        LDA     SRCL
        BNE     +
        DEC     SRCH
+       DEC     SRCL
end
asm     _jmpOpMemBl7Scr
        JMP     $A000
end
asm     _dcgrMemBl7ScrA
YM7S    LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        LDA     ESTKL-1,X   ; X7 COORD
        ;CLC
end
asm     _dcgrMemBl7ScrB
        ADC     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     DSTL
        BNE     +
        DEC     DSTH
+       DEC     DSTL
        STA     $C055       ; PAGE1X
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        STA     $C054       ; PAGE1M
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YM7S
RETM7S  RTS
end
asm     _dcgrOpMemBl7ScrA
YOM7S   LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        LDA     ESTKL-1,X   ; X7 COORD
        ;CLC
end
asm     _dcgrOpMemBl7ScrB
        ADC     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     DSTL
        BNE     +
        DEC     DSTH
+       DEC     DSTL
        STA     $C055       ; PAGE1X
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
end
asm     _dcgrOpMemBl7ScrC
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        STA     $C054       ; PAGE1M
        LDY     ESTKL-3,X   ; WIDTH7*2
-       LDA     (SRC),Y
end
asm     _dcgrOpMemBl7ScrD
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        BNE     -
        ;CLC
        LDA     ESTKL-6,X   ; HALF SPAN
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YOM7S
RETOM7S RTS
end
//
// Memory -> Memory Block7 function
//
asm dhgrMemBl7Mem(x7, y, srcw7, srch, srcptr, srcspan, dstw7, dsth, dstptr)#0
        TXA
        CLC
        ADC     #9
        TAX
        LDA     ESTKL-7,X   ; DST WIDTH7
end
asm     _clipXMemBl7Mem
        JSR     $F000       ; CLIPX
        BCS     RETOM7S     ; CLIPPED AWAY
        ASL
        PHA
        ;CLC
        ADC     ESTKL-5,X   ; SRC PTR
        STA     SRCL
        LDA     #$00
        ADC     ESTKH-5,X
        STA     SRCH
        PLA
        ;CLC
        ADC     ESTKL-1,X   ; X7 COORD
        ADC     ESTKL-1,X   ; X7 COORD * 2
        ADC     ESTKL-9,X   ; DST PTR
        STA     DSTL        ; DSTPTR = CLIPX * 2 + X7 * 2
        LDA     #$00
        ADC     ESTKH-9,X
        STA     DSTH
        LDA     ESTKL-7,X   ; DST WIDTH7
        ASL
        STA     ESTKH-10,X  ; DST SPAN / 2
        ASL
        STA     ESTKL-10,X  ; DST SPAN
        LDA     ESTKL-8,X   ; DST HEIGHT
end
asm     _clipYMemBl7Mem
        JSR     $E000       ; CLIPY
        BCS     RETOM7S     ; CLIPPED AWAY
        PHA
        BEQ     +
        TAY
-       ;CLC                ; ADVANCE TO SRC Y SCANLINE
        LDA     ESTKL-6,X   ; SRC SPAN
        ADC     SRCL
        STA     SRCL
        LDA     #$00        ; ESTKH-6,X
        ADC     SRCH
        STA     SRCH
        DEY
        BNE     -
+       PLA
        ;CLC
        ADC     ESTKL-2,X   ; Y COORD
        BEQ     +
        TAY
-       ;CLC                ; ADVANCE TO DST Y SCANLINE
        LDA     ESTKL-10,X  ; DST SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-10,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       ;LSR     ESTKH-6,X   ; SRC SPAN / 2
        ;ROR     ESTKL-6,X
        LSR     ESTKL-6,X
        ;LSR     ESTKH-10,X  ; DST SPAN / 2
        ;ROR     ESTKL-10,X
        ;LSR     ESTKL-10,X
        LDA     SRCL
        BNE     +
        DEC     SRCH
+       DEC     SRCL
        LDA     DSTL
        BNE     +
        DEC     DSTH
+       DEC     DSTL
        ASL     ESTKL-3,X   ; SRC WIDTH7 * 2
end
asm     _jmpOpMemBl7Mem
        JMP     $F000
end
asm     _dcgrMemBl7MemB
YM7M    LDY     ESTKL-3,X   ; SRC WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        LDA     ESTKL-6,X
        ;CLC
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        LDA     ESTKH-10,X  ; ESTKL-10,X HALF DST SPAN
        ;CLC
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-10,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        LDY     ESTKL-3,X   ; SRC WIDTH7*2
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BNE     -
        LDA     ESTKL-6,X
        ;CLC
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        LDA     ESTKH-10,X  ; ESTKL-10,X HALF DST SPAN
        ;CLC
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-10,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; SRC HEIGHT
        BNE     YM7M
RETM7M  RTS
end
asm     _dcgrOpMemBl7MemB
YOM7M   LDY     ESTKL-3,X   ; SRC WIDTH7*2
-       LDA     (SRC),Y
end
asm     _dcgrOpMemBl7MemC
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        BNE     -
        LDA     ESTKL-6,X   ; HALF SRC SPAN
        ;CLC
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        LDA     ESTKH-10,X  ; ESTKL-10,X HALF DST SPAN
        ;CLC
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-10,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        LDY     ESTKL-3,X   ; SRC WIDTH7*2
-       LDA     (SRC),Y
end
asm     _dcgrOpMemBl7MemD
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        LDA     (SRC),Y
        EOR     (DST),Y
        STA     (DST),Y
        DEY
        BNE     -
        LDA     ESTKL-6,X   ; HALF SRC SPAN
        ;CLC
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
        LDA     ESTKH-10,X  ; ESTKL-10,X HALF DST SPAN
        ;CLC
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-10,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        DEC     ESTKL-4,X   ; SRC HEIGHT
        BNE     YOM7M
        RTS
end
//
// Clear Screen/Memory Block7
//
asm dhgrClearBl7Scr(x7, y, w7, h)#0
        INX
        INX
        INX
        INX
        LDA     #20
end
asm     _clipXClearBl7Scr
        JSR     $F000       ; CLIPX7
        BCS     RETFILS
        LDA     #192
end
asm     _clipYClearBl7Scr
        JSR     $E000       ; CLIPY
        BCS     RETFILS     ; CLIPPED AWAY
        ASL     ESTKL-3,X   ; WIDTH7 * 2
        ASL     ESTKL-1,X   ; X7 COORD * 2
YFILS   LDY     ESTKL-2,X   ; Y COORD
        INC     ESTKL-2,X   ; Y COORD++
        LDA     ESTKL-1,X   ; X7 COORD
        ;CLC
end
asm     _dcgrClearBl7ScrA
        ADC     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     DSTL
        BNE     +
        DEC     DSTH
+       DEC     DSTL
        STA     $C055       ; PAGE1X
        LDY     ESTKL-3,X   ; WIDTH7
end
asm     _dcgrClearBl7ScrB
-       LDA     $3002       ; AUXCLRH
        STA     (DST),Y
        DEY
        LDA     $3000       ; AUXCLRL
        STA     (DST),Y
        DEY
        BNE     -
        STA     $C054       ; PAGE1M
        LDY     ESTKL-3,X   ; WIDTH7
end
asm     _dcgrClearBl7ScrC
-       LDA     $3003       ; MEMCLRH
        STA     (DST),Y
        DEY
        LDA     $3001       ; MEMCLRL
        STA     (DST),Y
        DEY
        BNE     -
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YFILS
RETFILS RTS
end
asm dhgrClearBl7Mem(x7, y, w7, h, memptr, memspan)#0
        TXA
        CLC
        ADC     #6
        TAX
        ASL     ESTKL-3,X   ; WIDTH7 * 2
        LDA     ESTKL-1,X   ; X7 * 2
        ASL
        ADC     ESTKL-5,X   ; MEMPTR
        STA     DSTL
        LDA     #$00
        ADC     ESTKH-5,X
        STA     DSTH
        LDY     ESTKL-2,X   ; Y COORD
        BEQ     +
-       ;CLC                ; ADVANCE TO DST Y SCANLINE
        LDA     ESTKL-6,X   ; SPAN
        ADC     DSTL
        STA     DSTL
        LDA     #$00        ; ESTKH-6,X
        ADC     DSTH
        STA     DSTH
        DEY
        BNE     -
+       LDA     DSTL
        BNE     +
        DEC     DSTH
+       DEC     DSTL
        ;LDA     ESTKH-6,X   ; SRC POINTS TO MEM HALF OF SCANLINE
        ;LSR
        ;PHA
        LDA     ESTKL-6,X   ; SPAN
        LSR                 ; ROR SPAN / 2
        ADC     DSTL
        STA     SRCL
        LDA     #$00        ; PLA
        ADC     DSTH
        STA     SRCH
        BNE     +           ; BRA
YFILM   LDA     ESTKL-6,X   ; HALF SPAN
        ADC     DSTL
        STA     DSTL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     DSTH
        STA     DSTH
        LDA     ESTKL-6,X   ; SPAN
        ADC     SRCL
        STA     SRCL
        ;LDA     ESTKH-6,X
        TYA     ;LDA #$00
        ADC     SRCH
        STA     SRCH
+       LDY     ESTKL-3,X   ; WIDTH7
end
asm     _dcgrClearBl7MemB
-       LDA     $3002       ; AUXCLRH
        STA     (DST),Y
        LDA     $3003       ; MEMCLRH
        STA     (SRC),Y
        DEY
        LDA     $3000       ; AUXCLRL
        STA     (DST),Y
        LDA     $3001       ; MEMCLRL
        STA     (SRC),Y
        DEY
        BNE     -
        DEC     ESTKL-4,X   ; HEIGHT
        BNE     YFILM
        RTS
end
//
// Tile -> Screen Transfer
//
asm dhgrTilesScr(x7, y8, strptr, strlen, tileset)#0
        INX
        INX
        INX
        INX
        INX
        LDA     ESTKL-5,X   ; TILESETPTRL
        STA     DSTL
        LDA     ESTKH-5,X   ; TILESETPTRH
        STA     DSTH
        LDA     ESTKL-3,X   ; STRPTRL
        STA     TMPL
        LDA     ESTKH-3,X   ; STRPTRH
        STA     TMPH
        LDY     ESTKL-2,X   ; Y8 COORD
        LDA     ESTKL-1,X   ; X7 COORD*2
        ASL
        ;CLC
end
asm     _dcgrTileScrA
        ADC     $1000,Y     ; SCANBTTML
        STA     $D700       ; SELF MODIFY LOOP
        STA     $D600
        STA     $D500
        STA     $D400
        STA     $D300
        STA     $D200
        STA     $D100
        STA     $D000
end
asm     _dcgrTileScrB
        LDA     $2000,Y     ; SCANBTTMH
        STA     $E700       ; SELF MODIFY LOOP
        SEC                 ; MOVE TO NEXT SCAN ADDRESS (BOTTOM TO TOP)
        SBC     #$04
        STA     $E600
        SBC     #$04
        STA     $E500
        SBC     #$04
        STA     $E400
        SBC     #$04
        STA     $E300
        SBC     #$04
        STA     $E200
        SBC     #$04
        STA     $E100
        SBC     #$04
        STA     $E000
        LDA     ESTKL-4,X   ; STRLEN
        BEQ     RETTS
        STX     ESP
        ASL                 ; TWO SCREEN BYTES PER TILE
        TAX                 ; DRAW RIGHT TO LEFT
        DEX
LPTS    TXA
        LSR
        TAY
        LDA     (TMP),Y     ; TILE INDEX * 32 = INDEX * 256 / 8
        LSR
        STA     SRCH
        LDA     #$00
        ROR
        LSR     SRCH
        ROR
        LSR     SRCH
        ROR
;        CLC                ; CARRY IS CLEAR FROM ABOVE
        ADC     DSTL        ; ADD TO TILESETPTR
        STA     SRCL
        LDA     SRCH
        ADC     DSTH
        STA     SRCH
        LDY     #31         ; START FILLING MAIN MEM HALF OF TILE
        STA     $C054       ; PAGE1M
end
asm     _dcgrTileScrC
-       LDA     (SRC),Y     ; SCAN 7
        STA     $2701,X
        DEY
        LDA     (SRC),Y     ; SCAN 6
        STA     $2601,X
        DEY
        LDA     (SRC),Y     ; SCAN 5
        STA     $2501,X
        DEY
        LDA     (SRC),Y     ; SCAN 4
        STA     $2401,X
        DEY
        LDA     (SRC),Y     ; SCAN 3
        STA     $2301,X
        DEY
        LDA     (SRC),Y     ; SCAN 2
        STA     $2201,X
        DEY
        LDA     (SRC),Y     ; SCAN 1
        STA     $2101,X
        DEY
        LDA     (SRC),Y     ; SCAN 0
        STA     $2001,X
        DEY
        BMI     NXTTS       ; END OF TILE
        DEX
        TXA
        LSR
        BCC     -           ; FILL HI THEN LO BYTES
        STA     $C055       ; PAGE1X
        INX
        INX
        BNE     -           ; FILL AUX HALF OF TILE
NXTTS   DEX
        BPL     LPTS
        LDX     ESP
RETTS   RTS
end
//
// Slow implementation of Tiles -> Mem
//
def dhgrTileMem(tileptr, memptr, memspan)#0
    byte h, v
    word rowptr

    //
    // AUX half of memptr
    //
    for h = 0 to 1
        rowptr = memptr + h
        for v = 0 to 7
            ^rowptr = tileptr->[v]
            rowptr  = rowptr + memspan
        next
        tileptr = tileptr + 8
    next
    //
    // MEM half of memptr
    //
    memptr = memptr + memspan / 2
    for h = 0 to 1
        rowptr = memptr + h
        for v = 0 to 7
            ^rowptr = tileptr->[v]
            rowptr  = rowptr + memspan
        next
        tileptr = tileptr + 8
    next
end
def dhgrTilesMem(x7, y8, strptr, strlen, tileset, memptr, memspan)#0

    if y8; memptr = memptr + y8 * 8 * memspan; fin
    memptr = memptr + x7 * 2
    while strlen
        dhgrTileMem(tileset + ^strptr * 32, memptr, memspan)
        strptr++
        strlen--
    loop
end
//
// Convert Block7 to Tile format
//
export def dhgrMemBl7Tile(x7, y, memptr, memspan, tileptr)#0
    byte h, v
    word rowptr

    if y; memptr = memptr + y * memspan; fin
    //
    // AUX half of Bl7 scanline
    //
    memptr = memptr + x7 * 2
    for h = 0 to 1
        rowptr = memptr + h
        for v = 0 to 7
            ^(tileptr + v) = ^rowptr
            rowptr = rowptr + memspan
        next
        tileptr = tileptr + 8
    next
    //
    // MEM half of Bl7 scan
    //
    memptr = memptr + memspan / 2
    for h = 0 to 1
        rowptr = memptr + h
        for v = 0 to 7
            ^(tileptr + v) = ^rowptr
            rowptr = rowptr + memspan
        next
        tileptr = tileptr + 8
    next
end
//
// Hack to extend parameters for memory functions
//
def extPlotMem#0
    (@dcgrPlotMem)(surfPtr, surfSpan)#0
end
def extHLinMem#0
    (@dcgrHLinMem)(surfPtr, surfSpan)#0
end
def extVLinMem#0
    (@dcgrVLinMem)(surfPtr, surfSpan)#0
end
def extBitMapMem#0
    (@dcgrBitmapMem)(surfWidth, surfHeight, surfPtr, surfSpan)#0
end
def extPixMapMem#0
    (@dcgrPixmapMem)(surfWidth, surfHeight, surfPtr, surfSpan)#0
end
def extRleMapMem#0
    (@dcgrRlemapMem)(surfWidth, surfHeight, surfPtr, surfSpan)#0
end
def extScrBl7Mem#0
    (@dhgrScrBl7Mem)(surfPtr, surfSpan)#0
end
def extMemBl7Mem#0
    (@dhgrMemBl7Mem)(surfWidth7, surfHeight, surfPtr)#0
end
def extTilesMem#0
    (@dhgrTilesMem)(surfPtr, surfSpan)#0
end
def extClearBl7Mem#0
    (@dhgrClearBl7Mem)(surfPtr, surfSpan)#0
end
def dhgrOpScr(op)#0
    byte opcode

    //
    // Self modifying code!
    //
    opcode = $11 // ORA (ZP),Y
    when op
        is OP_XOR
            opcode = opcode + $20 // $51 = EOR (ZP),Y
        is OP_AND
            opcode = opcode + $20 // $31 = AND (ZP),Y
        is OP_OR
            _jmpOpPlotScr:1     = @_dcgrOpPlotScrB
            _dcgrHLinScrB:1     = @_dcgrOpPlotScrB
            _dcgrVLinScrB:1     = @_dcgrOpPlotScrB
            _dcgrBitmapScrB:1   = @_dcgrOpPlotScrB
            _dcgrPixmapScrC:1   = @_dcgrOpPlotScrB
            _dcgrPixmapScrE:1   = @_dcgrOpPlotScrB
            _dcgrRlemapScrC:1   = @_dcgrOpPlotScrB
            _dcgrRlemapScrE:1   = @_dcgrOpPlotScrB
            _dcgrOpPlotScrD.3   = opcode
            _dcgrOpPlotScrE.3   = opcode
            _dcgrOpPlotScrG.3   = opcode
            _dcgrOpPlotScrH.3   = opcode
            _jmpOpMemBl7Scr:1   = @_dcgrOpMemBl7ScrA
            _dcgrOpMemBl7ScrC.0 = opcode
            _dcgrOpMemBl7ScrD.0 = opcode
            break
        otherwise // OP_SRC
            _jmpOpPlotScr:1     = @_dcgrPlotScrB
            _dcgrHLinScrB:1     = @_dcgrPlotScrB
            _dcgrVLinScrB:1     = @_dcgrPlotScrB
            _dcgrBitmapScrB:1   = @_dcgrPlotScrB
            _dcgrPixmapScrC:1   = @_dcgrPlotScrB
            _dcgrPixmapScrE:1   = @_dcgrPlotScrB
            _dcgrRlemapScrC:1   = @_dcgrPlotScrB
            _dcgrRlemapScrE:1   = @_dcgrPlotScrB
            _jmpOpMemBl7Scr:1   = @_dcgrMemBl7ScrA

    wend
end
def dhgrOpMem(op)#0
    byte opcode

    //
    // Self modifying code!
    //
    opcode = $11 // ORA (ZP),Y
    when op
        is OP_XOR
            opcode = opcode + $20 // $51 = EOR (ZP),Y
        is OP_AND
            opcode = opcode + $20 // $31 = AND (ZP),Y
        is OP_OR
            _jmpOpPlotMem:1     = @_dcgrOpPlotMemB
            _dcgrHLinMemB:1     = @_dcgrOpPlotMemB
            _dcgrVLinMemB:1     = @_dcgrOpPlotMemB
            _dcgrBitmapMemA:1   = @_dcgrOpPlotMemB
            _dcgrPixmapMemC:1   = @_dcgrOpPlotMemB
            _dcgrPixmapMemE:1   = @_dcgrOpPlotMemB
            _dcgrRlemapMemC:1   = @_dcgrOpPlotMemB
            _dcgrRlemapMemE:1   = @_dcgrOpPlotMemB
            _dcgrOpPlotMemD.3   = opcode
            _dcgrOpPlotMemE.3   = opcode
            _dcgrOpPlotMemG.3   = opcode
            _dcgrOpPlotMemH.3   = opcode
            _jmpOpMemBl7Mem:1   = @_dcgrOpMemBl7MemB
            _dcgrOpMemBl7MemC.0 = opcode
            _dcgrOpMemBl7MemC.7 = opcode
            _dcgrOpMemBl7MemD.0 = opcode
            _dcgrOpMemBl7MemD.7 = opcode
            break
        otherwise // OP_SRC
            _jmpOpPlotMem:1     = @_dcgrPlotMemB
            _dcgrHLinMemB:1     = @_dcgrPlotMemB
            _dcgrVLinMemB:1     = @_dcgrPlotMemB
            _dcgrBitmapMemA:1   = @_dcgrPlotMemB
            _dcgrPixmapMemC:1   = @_dcgrPlotMemB
            _dcgrPixmapMemE:1   = @_dcgrPlotMemB
            _dcgrRlemapMemC:1   = @_dcgrPlotMemB
            _dcgrRlemapMemE:1   = @_dcgrPlotMemB
            _jmpOpMemBl7Mem:1   = @_dcgrMemBl7MemB
    wend
end
export def dhgrOp(op)#0
    if dhgrSurface // Memory
        if op <> opMem
            opMem = op
            dhgrOpMem(opMem)
        fin
    else // Screen
        if op <> opScr
            opScr = op
            dhgrOpScr(opScr)
        fin
    fin
end
export def dhgrSurfScr(op)#0
    surfWidth  = 140
    surfWidth7 = 20
    surfHeight = 192
    surfPtr    = $2000
    surfSpan   = 10
    if dhgrSurface == DST_MEMORY
        dhgrSurface    = DST_SCREEN
        dcgrPixel:1    = @dcgrPlotScr
        dcgrHLin:1     = @dcgrHLinScr
        dcgrVLin:1     = @dcgrVLinScr
        dcgrBitMap:1   = @dcgrBitMapScr
        dcgrPixMap:1   = @dcgrPixMapScr
        dcgrRleMap:1   = @dcgrRleMapScr
        dhgrMemBl7:1   = @dhgrMemBl7Scr
        dhgrClearBl7:1 = @dhgrClearBl7Scr
        dhgrTiles:1    = @dhgrTilesScr
    fin
    if op <> opScr
        opScr = op
        dhgrOpScr(opScr)
    fin
end
export def dhgrSurfMem(op, memh, memptr, memspan)#0
    surfWidth7 = memspan >> 2
    surfWidth  = surfWidth7 * 7
    surfHeight = memh
    surfPtr    = memptr
    surfSpan   = memspan
    if dhgrSurface == DST_SCREEN
        dhgrSurface    = DST_MEMORY
        dcgrPixel:1    = @extPlotMem
        dcgrHLin:1     = @extHLinMem
        dcgrVLin:1     = @extVLinMem
        dcgrBitMap:1   = @extBitMapMem
        dcgrPixMap:1   = @extPixMapMem
        dcgrRleMap:1   = @extRleMapMem
        dhgrScrBl7:1   = @extScrBl7Mem
        dhgrMemBl7:1   = @extMemBl7Mem
        dhgrClearBl7:1 = @extClearBl7Mem
        dhgrTiles:1    = @extTilesMem
    fin
    if op <> opMem
        opMem = op
        dhgrOpMem(opMem)
    fin
end
//
// Set/Unset DHGR pixels
//
export def dhgrSet(dhx, y)#0
    dcgrColor(dhgrPix[dhx & $03])
    dhgrOp(OP_OR)
    dcgrPixel(dhx >> 2, y)
end
export def dhgrUnset(dhx, y)#0
    dcgrColor(dhgrMask[dhx & $03])
    dhgrOp(OP_AND)
    dcgrPixel(dhx >> 2, y)
end
//
// Read pixel and return color
//
export def dcgrGetPixel(x, y)#1
    byte x7, m7, i
    word[2] pix7
    word amask, mmask

    x7 = divmod7[x] >> 3
    if dhgrSurface // Memory
        dhgrMemBl7Mem(x7, y, surfWidth, surfHeight, surfPtr, surfSpan, 1, 1, @pix7)
    else // Screen
        dhgrScrBl7Mem(x7, y, 1, 1, @pix7, 4)
    fin
    m7 = divmod7[x] & $07
    amask = auxclrmsk[m7]
    if amask & $80; amask = (amask & $7F) << 8; fin
    pix7[0] = amask & pix7[0]
    mmask = memclrmsk[m7]
    if mmask & $80; mmask = (mmask & $7F) << 8; fin
    pix7[1] = mmask & pix7[1]
    for i = 0 to 15
        if pix7[0] == (auxclrsl[i] | (auxclrsh[i] << 8)) & amask
        if pix7[1] == (memclrsl[i] | (memclrsh[i] << 8)) & mmask
            return i // Color match
        fin; fin
    next
    return 15
end
export def dhgrMode(mode)#1
    if mode >= 0
        //
        // Make sure we are a 128K //e or //c
        //
        if MACHID & $F0 <> $B0
            puts("\n128K required for double hires graphics.\n")
            ^$C010
            while ^$C000 < 128; loop
            return 0
        fin
        ^page1m
        ^showfull
        ^showhires
        ^showgraphics
        ^IOUdis     = 0
        ^show80col  = 0
        ^dhresena
        ^store80ena = 0
        dhgrOpMem(OP_SRC)
        dhgrOpScr(OP_SRC)
        dhgrSurface = DST_MEMORY
        dhgrSurfScr(OP_SRC)
        dcgrColor(0)
        dhgrClearBl7(0, 0, 20, 192)
    else
        ^page1m
        ^showtext
        ^IOUdis     = 0
        ^show40col  = 0
        ^dhresdis
        ^store80dis = 0
        call($FB2F, 0, 0, 0, 0) // INIT
        call($FC58, 0, 0, 0, 0) // home()
    fin
    return mode
end
//
// Assembly symbol fixups
//
_dcgrColorA:1        = @auxclrsl
_dcgrColorA:4        = @auxclrl
_dcgrColorA:7        = @auxclrsh
_dcgrColorA:10       = @auxclrh
_dcgrColorA:13       = @memclrsl
_dcgrColorA:16       = @memclrl
_dcgrColorA:19       = @memclrsh
_dcgrColorA:22       = @memclrh
//
// Screen function fixups
//
_dcgrPlotScrA:1      = @hgrscanl
_dcgrPlotScrA:6      = @hgrscanh
_dcgrPlotScrB:1      = @divmod7
_dcgrPlotScrC:1      = @auxclrmsk
_dcgrPlotScrD:1      = @auxclrl
_dcgrPlotScrD:6      = @auxclrmsk
_dcgrPlotScrE:1      = @auxclrh
_dcgrPlotScrE:6      = @auxclrmsk
_dcgrPlotScrF:1      = @memclrmsk
_dcgrPlotScrG:1      = @memclrl
_dcgrPlotScrG:6      = @memclrmsk
_dcgrPlotScrH:1      = @memclrh
_dcgrPlotScrH:6      = @memclrmsk
_dcgrOpPlotScrB:1    = @divmod7
_dcgrOpPlotScrC:1    = @auxclrmsk
_dcgrOpPlotScrD:1    = @auxclrl
_dcgrOpPlotScrE:1    = @auxclrh
_dcgrOpPlotScrF:1    = @memclrmsk
_dcgrOpPlotScrG:1    = @memclrl
_dcgrOpPlotScrH:1    = @memclrh
_dcgrHLinScrA:1      = @hgrscanl
_dcgrHLinScrA:6      = @hgrscanh
_dcgrHLinScrB:1      = @_dcgrPlotScrB
_dcgrVLinScrA:1      = @hgrscanl
_dcgrVLinScrA:6      = @hgrscanh
_dcgrVLinScrB:1      = @_dcgrPlotScrB
_dcgrBitmapScrA:1    = @hgrscanl
_dcgrBitmapScrA:6    = @hgrscanh
_dcgrBitmapScrB:1    = @_dcgrPlotScrB
_dcgrPixmapScrA:1    = @hgrscanl
_dcgrPixmapScrA:6    = @hgrscanh
_dcgrPixmapScrB:1    = @_dcgrColorA
_dcgrPixmapScrC:1    = @_dcgrPlotScrB
_dcgrPixmapScrD:1    = @_dcgrColorA
_dcgrPixmapScrE:1    = @_dcgrPlotScrB
_dcgrRlemapScrA:1    = @hgrscanl
_dcgrRlemapScrA:6    = @hgrscanh
_dcgrRlemapScrB:1    = @_dcgrColorA
_dcgrRlemapScrC:1    = @_dcgrPlotScrB
_dcgrRlemapScrD:1    = @_dcgrColorA
_dcgrRlemapScrE:1    = @_dcgrPlotScrB
_clipXClearBl7Scr:1  = @_clipX
_clipYClearBl7Scr:1  = @_clipY
_dcgrClearBl7ScrA:1  = @hgrscanl
_dcgrClearBl7ScrA:8  = @hgrscanh
_dcgrClearBl7ScrB:1  = @auxclrh
_dcgrClearBl7ScrB:7  = @auxclrl
_dcgrClearBl7ScrC:1  = @memclrh
_dcgrClearBl7ScrC:7  = @memclrl
//
// Memory function fixups
//
_dcgrPlotMemB:4      = @divmod7
_dcgrPlotMemC:1      = @auxclrmsk
_dcgrPlotMemD:1      = @auxclrl
_dcgrPlotMemD:6      = @auxclrmsk
_dcgrPlotMemE:1      = @auxclrh
_dcgrPlotMemE:6      = @auxclrmsk
_dcgrPlotMemF:1      = @memclrmsk
_dcgrPlotMemG:1      = @memclrl
_dcgrPlotMemG:6      = @memclrmsk
_dcgrPlotMemH:1      = @memclrh
_dcgrPlotMemH:6      = @memclrmsk
_dcgrOpPlotMemB:4    = @divmod7
_dcgrOpPlotMemC:1    = @auxclrmsk
_dcgrOpPlotMemD:1    = @auxclrl
_dcgrOpPlotMemE:1    = @auxclrh
_dcgrOpPlotMemF:1    = @memclrmsk
_dcgrOpPlotMemG:1    = @memclrl
_dcgrOpPlotMemH:1    = @memclrh
_dcgrHLinMemB:1      = @_dcgrPlotMemB
_dcgrVLinMemB:1      = @_dcgrPlotMemB
_dcgrBitmapMemA:1    = @_dcgrPlotMemB
_dcgrPixmapMemB:1    = @_dcgrColorA
_dcgrPixmapMemC:1    = @_dcgrPlotMemB
_dcgrPixmapMemD:1    = @_dcgrColorA
_dcgrPixmapMemE:1    = @_dcgrPlotMemB
_dcgrRlemapMemB:1    = @_dcgrColorA
_dcgrRlemapMemC:1    = @_dcgrPlotMemB
_dcgrRlemapMemD:1    = @_dcgrColorA
_dcgrRlemapMemE:1    = @_dcgrPlotMemB
_dcgrClearBl7MemB:1  = @auxclrh
_dcgrClearBl7MemB:6  = @memclrh
_dcgrClearBl7MemB:12 = @auxclrl
_dcgrClearBl7MemB:17 = @memclrl
//
// Memory <-> Screen Block Transfer fixups
//
_dcgrScrBl7MemA:1    = @hgrscanl
_dcgrScrBl7MemA:8    = @hgrscanh
_clipXMemBl7Src:1    = @_clipX
_clipYMemBl7Scr:1    = @_clipY
_dcgrMemBl7ScrB:1    = @hgrscanl
_dcgrMemBl7ScrB:8    = @hgrscanh
_dcgrOpMemBl7ScrB:1  = @hgrscanl
_dcgrOpMemBl7ScrB:8  = @hgrscanh
//
// Memory <-> Memory Block Transfer fixups
//
_clipXMemBl7Mem:1    = @_clipX
_clipYMemBl7Mem:1    = @_clipY
//
// Tile self-modifying code
//
_dcgrTileScrA:1   = @tilebttml
_dcgrTileScrA:4   = @_dcgrTileScrC.3
_dcgrTileScrA:7   = @_dcgrTileScrC.9
_dcgrTileScrA:10  = @_dcgrTileScrC.15
_dcgrTileScrA:13  = @_dcgrTileScrC.21
_dcgrTileScrA:16  = @_dcgrTileScrC.27
_dcgrTileScrA:19  = @_dcgrTileScrC.33
_dcgrTileScrA:22  = @_dcgrTileScrC.39
_dcgrTileScrA:25  = @_dcgrTileScrC.45
_dcgrTileScrB:1   = @tilebttmh
_dcgrTileScrB:4   = @_dcgrTileScrC.4
_dcgrTileScrB:10  = @_dcgrTileScrC.10
_dcgrTileScrB:15  = @_dcgrTileScrC.16
_dcgrTileScrB:20  = @_dcgrTileScrC.22
_dcgrTileScrB:25  = @_dcgrTileScrC.28
_dcgrTileScrB:30  = @_dcgrTileScrC.34
_dcgrTileScrB:35  = @_dcgrTileScrC.40
_dcgrTileScrB:40  = @_dcgrTileScrC.46
done
