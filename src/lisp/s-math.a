; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; lisp/s-math.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; lisp/s-math.pla: 0001: 
; lisp/s-math.pla: 0002: include "inc/int32.plh"
; inc/int32.plh: 0001: import int32
	; DCI STRING: INT32
	!BYTE	$C9,$CE,$D4,$B3,$32
					; INT32 -> X028
; inc/int32.plh: 0002:     const t_i32 = 4
					; t_i32 = 4
; inc/int32.plh: 0003:     
; inc/int32.plh: 0004:     predef zero32#0
					; ZERO32 -> X029
; inc/int32.plh: 0005:     predef zext16to32#0
					; ZEXT16TO32 -> X030
; inc/int32.plh: 0006:     predef neg32#0
					; NEG32 -> X031
; inc/int32.plh: 0007:     predef load32(i32ptr)#0
					; LOAD32 -> X032
; inc/int32.plh: 0008:     predef loadi16(imm16)#0
					; LOADI16 -> X033
; inc/int32.plh: 0009:     predef store32(i32ptr)#0
					; STORE32 -> X034
; inc/int32.plh: 0010:     predef add32(i32ptr)#0
					; ADD32 -> X035
; inc/int32.plh: 0011:     predef addi16(imm16)#0
					; ADDI16 -> X036
; inc/int32.plh: 0012:     predef sub32(i32ptr)#0
					; SUB32 -> X037
; inc/int32.plh: 0013:     predef subi16(imm16)#0
					; SUBI16 -> X038
; inc/int32.plh: 0014:     predef shl32(imm8)#0
					; SHL32 -> X039
; inc/int32.plh: 0015:     predef shr32(imm8)#0
					; SHR32 -> X040
; inc/int32.plh: 0016:     predef mul32(i32ptr)#0
					; MUL32 -> X041
; inc/int32.plh: 0017:     predef muli16(imm16)#0
					; MULI16 -> X042
; inc/int32.plh: 0018:     predef div32(i32ptr)#2
					; DIV32 -> X043
; inc/int32.plh: 0019:     predef divi16(imm16)#2
					; DIVI16 -> X044
; inc/int32.plh: 0020:     predef iseq32(i32ptr)#1
					; ISEQ32 -> X045
; inc/int32.plh: 0021:     predef iseqi16(imm16)#1
					; ISEQI16 -> X046
; inc/int32.plh: 0022:     predef isge32(i32ptr)#1
					; ISGE32 -> X047
; inc/int32.plh: 0023:     predef isgei16(imm16)#1
					; ISGEI16 -> X048
; inc/int32.plh: 0024:     predef isle32(i32ptr)#1
					; ISLE32 -> X049
; inc/int32.plh: 0025:     predef islei16(imm16)#1
					; ISLEI16 -> X050
; inc/int32.plh: 0026:     predef isgt32(i32ptr)#1
					; ISGT32 -> X051
; inc/int32.plh: 0027:     predef isgti16(imm16)#1
					; ISGTI16 -> X052
; inc/int32.plh: 0028:     predef islt32(i32ptr)#1
					; ISLT32 -> X053
; inc/int32.plh: 0029:     predef islti16(imm16)#1
					; ISLTI16 -> X054
; inc/int32.plh: 0030:     predef i32tos(i32ptr, strptr)#1
					; I32TOS -> X055
; inc/int32.plh: 0031:     predef puti32(i32ptr)#0
					; PUTI32 -> X056
; inc/int32.plh: 0032: end
; lisp/s-math.pla: 0002: 
; lisp/s-math.pla: 0003: include "inc/sane.plh"
; inc/sane.plh: 0001: import sane
	; DCI STRING: SANE
	!BYTE	$D3,$C1,$CE,$45
					; SANE -> X057
; inc/sane.plh: 0002: //-----------------------------------------------------------
; inc/sane.plh: 0003: // Operation code masks.
; inc/sane.plh: 0004: //-----------------------------------------------------------
; inc/sane.plh: 0005: const FOADD     = $0000     // add
					; FOADD = 0
; inc/sane.plh: 0006: const FOSUB     = $0002     // subtract
					; FOSUB = 2
; inc/sane.plh: 0007: const FOMUL     = $0004     // multiply
					; FOMUL = 4
; inc/sane.plh: 0008: const FODIV     = $0006     // divide
					; FODIV = 6
; inc/sane.plh: 0009: const FOCMP     = $0008     // compare, no exception from unordered
					; FOCMP = 8
; inc/sane.plh: 0010: const FOCPX     = $000A     // compare, signal invalid if unordered
					; FOCPX = 10
; inc/sane.plh: 0011: const FOREM     = $000C     // remainder
					; FOREM = 12
; inc/sane.plh: 0012: const FOZ2X     = $000E     // convert to extended
					; FOZ2X = 14
; inc/sane.plh: 0013: const FOX2Z     = $0010     // convert from extended
					; FOX2Z = 16
; inc/sane.plh: 0014: const FOSQRT    = $0012     // square root
					; FOSQRT = 18
; inc/sane.plh: 0015: const FORTI     = $0014     // round to integral value
					; FORTI = 20
; inc/sane.plh: 0016: const FOTTI     = $0016     // truncate to integral value
					; FOTTI = 22
; inc/sane.plh: 0017: const FOSCALB   = $0018     // binary scale
					; FOSCALB = 24
; inc/sane.plh: 0018: const FOLOGB    = $001A     // binary log
					; FOLOGB = 26
; inc/sane.plh: 0019: const FOCLASS   = $001C     // classify
					; FOCLASS = 28
; inc/sane.plh: 0020: const FONEXT    = $001E     // next-after
					; FONEXT = 30
; inc/sane.plh: 0021: //
; inc/sane.plh: 0022: const FOSETENV  = $0001     // set environment
					; FOSETENV = 1
; inc/sane.plh: 0023: const FOGETENV  = $0003     // get environment
					; FOGETENV = 3
; inc/sane.plh: 0024: const FOSETHV   = $0005     // set halt vector
					; FOSETHV = 5
; inc/sane.plh: 0025: const FOGETHV   = $0007     // get halt vector
					; FOGETHV = 7
; inc/sane.plh: 0026: const FOD2B     = $0009     // convert decimal to binary
					; FOD2B = 9
; inc/sane.plh: 0027: const FOB2D     = $000B     // convert binary to decimal
					; FOB2D = 11
; inc/sane.plh: 0028: const FONEG     = $000D     // negate
					; FONEG = 13
; inc/sane.plh: 0029: const FOABS     = $000F     // absolute value
					; FOABS = 15
; inc/sane.plh: 0030: const FOCPYSGN  = $0011     // copy sign
					; FOCPYSGN = 17
; inc/sane.plh: 0031: // UNDEFINED    = $0013
; inc/sane.plh: 0032: const FOSETXCP  = $0015     // set exception
					; FOSETXCP = 21
; inc/sane.plh: 0033: const FOPROCENTRY = $0017   // procedure-entry
					; FOPROCENTRY = 23
; inc/sane.plh: 0034: const FOPROCEXIT = $0019    // procedure-exit
					; FOPROCEXIT = 25
; inc/sane.plh: 0035: const FOTESTXCP = $001B     // test exception
					; FOTESTXCP = 27
; inc/sane.plh: 0036: // UNDEFINED    = $001D
; inc/sane.plh: 0037: // UNDEFINED    = $001F
; inc/sane.plh: 0038: //-----------------------------------------------------------
; inc/sane.plh: 0039: // Operand format masks.
; inc/sane.plh: 0040: //-----------------------------------------------------------
; inc/sane.plh: 0041: const FFEXT     = $0000     // extended -- 80-bit float
					; FFEXT = 0
; inc/sane.plh: 0042: const FFDBL     = $0100     // double   -- 64-bit float
					; FFDBL = 256
; inc/sane.plh: 0043: const FFSGL     = $0200     // single   -- 32-bit float
					; FFSGL = 512
; inc/sane.plh: 0044: // UNDEFINED    = $0300
; inc/sane.plh: 0045: const FFINT     = $0400     // integer  -- 16-bit integer
					; FFINT = 1024
; inc/sane.plh: 0046: const FFCOMP    = $0500     // comp     -- 64-bit integer
					; FFCOMP = 1280
; inc/sane.plh: 0047: // UNDEFINED    = $0600
; inc/sane.plh: 0048: // UNDEFINED    = $0700
; inc/sane.plh: 0049: //-----------------------------------------------------------
; inc/sane.plh: 0050: // Class.
; inc/sane.plh: 0051: //-----------------------------------------------------------
; inc/sane.plh: 0052: const FCSNAN    = $FC       // -4: signaling NAN
					; FCSNAN = 252
; inc/sane.plh: 0053: const FCQNAN    = $FD       // -3: quiet NAN
					; FCQNAN = 253
; inc/sane.plh: 0054: const FCINF     = $FE       // -2: infinite
					; FCINF = 254
; inc/sane.plh: 0055: const FCZERO    = $FF       // -1: zero
					; FCZERO = 255
; inc/sane.plh: 0056: const FCNORM    = $00       //  0: normal
					; FCNORM = 0
; inc/sane.plh: 0057: const FCDENORM  = $01       //  1: denormal
					; FCDENORM = 1
; inc/sane.plh: 0058: //-----------------------------------------------------------
; inc/sane.plh: 0059: // Exceptions.
; inc/sane.plh: 0060: //-----------------------------------------------------------
; inc/sane.plh: 0061: const FBINVALID = $01
					; FBINVALID = 1
; inc/sane.plh: 0062: const FBUFLOW   = $02
					; FBUFLOW = 2
; inc/sane.plh: 0063: const FBOFLOW   = $04
					; FBOFLOW = 4
; inc/sane.plh: 0064: const FBDIVZER  = $08
					; FBDIVZER = 8
; inc/sane.plh: 0065: const FBINEXACT = $10
					; FBINEXACT = 16
; inc/sane.plh: 0066: //-----------------------------------------------------------
; inc/sane.plh: 0067: // Elementary function operation code masks.
; inc/sane.plh: 0068: //-----------------------------------------------------------
; inc/sane.plh: 0069: const FOLNX     = $0000     // base-e log
					; FOLNX = 0
; inc/sane.plh: 0070: const FOLOG2X   = $0002     // base-2 log
					; FOLOG2X = 2
; inc/sane.plh: 0071: const FOLN1X    = $0004     // ln (1 + x)
					; FOLN1X = 4
; inc/sane.plh: 0072: const FOLOG21X  = $0006     // log2 (1 + x)
					; FOLOG21X = 6
; inc/sane.plh: 0073: const FOEXPX    = $0008     // base-e exponential
					; FOEXPX = 8
; inc/sane.plh: 0074: const FOEXP2X   = $000A     // base-2 exponential
					; FOEXP2X = 10
; inc/sane.plh: 0075: const FOEXP1X   = $000C     // exp (x) - 1
					; FOEXP1X = 12
; inc/sane.plh: 0076: const FOEXP21X  = $000E     // exp2 (x) - 1
					; FOEXP21X = 14
; inc/sane.plh: 0077: const FOXPWRI   = $0010     // integer exponentiation
					; FOXPWRI = 16
; inc/sane.plh: 0078: const FOXPWRY   = $0012     // general exponentiation
					; FOXPWRY = 18
; inc/sane.plh: 0079: const FOCOMPND  = $0014     // compound
					; FOCOMPND = 20
; inc/sane.plh: 0080: const FOANNUIT  = $0016     // annuity
					; FOANNUIT = 22
; inc/sane.plh: 0081: const FOATANX   = $0018     // arctangent
					; FOATANX = 24
; inc/sane.plh: 0082: const FOSINX    = $001A     // sine
					; FOSINX = 26
; inc/sane.plh: 0083: const FOCOSX    = $001C     // cosine
					; FOCOSX = 28
; inc/sane.plh: 0084: const FOTANX    = $001E     // tangent
					; FOTANX = 30
; inc/sane.plh: 0085: const FORANDX   = $0020     // random
					; FORANDX = 32
; inc/sane.plh: 0086: //-----------------------------------------------------------
; inc/sane.plh: 0087: // NaN error codes.
; inc/sane.plh: 0088: //-----------------------------------------------------------
; inc/sane.plh: 0089: const NANSQRT   = 1         // Invalid square root such as sqrt(-1).
					; NANSQRT = 1
; inc/sane.plh: 0090: const NANADD    = 2         // Invalid addition such as +INF - +INF.
					; NANADD = 2
; inc/sane.plh: 0091: const NANDIV    = 4         // Invalid division such as 0/0.
					; NANDIV = 4
; inc/sane.plh: 0092: const NANMUL    = 8         // Invalid multiply such as 0 * INF.
					; NANMUL = 8
; inc/sane.plh: 0093: const NANREM    = 9         // Invalid remainder or mod such as x REM 0.
					; NANREM = 9
; inc/sane.plh: 0094: const NANASCBIN = 17        // Attempt to convert invalid ASCII string.
					; NANASCBIN = 17
; inc/sane.plh: 0095: const NANCOMP   = 20        // Result of converting comp NaN to floating.
					; NANCOMP = 20
; inc/sane.plh: 0096: const NANZERO   = 21        // Attempt to create a NaN with a zero code.
					; NANZERO = 21
; inc/sane.plh: 0097: const NANTRIG   = 33        // Invalid argument to trig routine.
					; NANTRIG = 33
; inc/sane.plh: 0098: const NANINVTRIG = 34       // Invalid argument to inverse trig routine.
					; NANINVTRIG = 34
; inc/sane.plh: 0099: const NANLOG    = 36        // Invalid argument to log routine.
					; NANLOG = 36
; inc/sane.plh: 0100: const NANPOWER  = 37        // Invalid argument to x^i or x^y routine.
					; NANPOWER = 37
; inc/sane.plh: 0101: const NANFINAN  = 38        // Invalid argument to financial function.
					; NANFINAN = 38
; inc/sane.plh: 0102: const NANINIT   = 255       // Uninitialized storage.
					; NANINIT = 255
; inc/sane.plh: 0103: //-----------------------------------------------------------
; inc/sane.plh: 0104: // Comparison results.
; inc/sane.plh: 0105: //-----------------------------------------------------------
; inc/sane.plh: 0106: const FCMPGT    = $4040     // Greater Than
					; FCMPGT = 16448
; inc/sane.plh: 0107: const FCMPLT    = $8080     // Less Than
					; FCMPLT = 32896
; inc/sane.plh: 0108: const FCMPEQ    = $0002     // EQual
					; FCMPEQ = 2
; inc/sane.plh: 0109: const FCMPUN    = $0101     // UNordered
					; FCMPUN = 257
; inc/sane.plh: 0110: //-----------------------------------------------------------
; inc/sane.plh: 0111: //
; inc/sane.plh: 0112: // Data types
; inc/sane.plh: 0113: //
; inc/sane.plh: 0114: struc t_single
; inc/sane.plh: 0115:     byte[3] s_mantissa
					; s_mantissa = 0
; inc/sane.plh: 0116:     byte    s_exponent
					; s_exponent = 3
; inc/sane.plh: 0117: end
					; t_single = 4
; inc/sane.plh: 0118: struc t_double
; inc/sane.plh: 0119:     byte[6] d_mantissa
					; d_mantissa = 0
; inc/sane.plh: 0120:     word    d_exponent
					; d_exponent = 6
; inc/sane.plh: 0121: end
					; t_double = 8
; inc/sane.plh: 0122: struc t_extended
; inc/sane.plh: 0123:     byte[8] x_mantissa
					; x_mantissa = 0
; inc/sane.plh: 0124:     word    x_exponent
					; x_exponent = 8
; inc/sane.plh: 0125: end
					; t_extended = 10
; inc/sane.plh: 0126: struc t_bigint
; inc/sane.plh: 0127:     byte[8] l_int
					; l_int = 0
; inc/sane.plh: 0128: end
					; t_bigint = 8
; inc/sane.plh: 0129: //
; inc/sane.plh: 0130: // SANE PLASMA interface
; inc/sane.plh: 0131: //
; inc/sane.plh: 0132: struc t_sane
; inc/sane.plh: 0133:     word initFP
					; initFP = 0
; inc/sane.plh: 0134:     word haltFP
					; haltFP = 2
; inc/sane.plh: 0135:     word op0FP
					; op0FP = 4
; inc/sane.plh: 0136:     word op1FP
					; op1FP = 6
; inc/sane.plh: 0137:     word op2FP
					; op2FP = 8
; inc/sane.plh: 0138:     word op3FP
					; op3FP = 10
; inc/sane.plh: 0139:     word op1ELEM
					; op1ELEM = 12
; inc/sane.plh: 0140:     word op2ELEM
					; op2ELEM = 14
; inc/sane.plh: 0141:     word op3ELEM
					; op3ELEM = 16
; inc/sane.plh: 0142:     word saveZP
					; saveZP = 18
; inc/sane.plh: 0143:     word restoreZP
					; restoreZP = 20
; inc/sane.plh: 0144: end
					; t_sane = 22
; inc/sane.plh: 0145: end
; lisp/s-math.pla: 0003: 
; lisp/s-math.pla: 0004: include "inc/longjmp.plh"
; inc/longjmp.plh: 0001: import longjmp
	; DCI STRING: LONGJMP
	!BYTE	$CC,$CF,$CE,$C7,$CA,$CD,$50
					; LONGJMP -> X058
; inc/longjmp.plh: 0002:     const t_except = $0160
					; t_except = 352
; inc/longjmp.plh: 0003:     predef except(env), throw(env, retval)
					; EXCEPT -> X059
					; THROW -> X060
; inc/longjmp.plh: 0004: end
; lisp/s-math.pla: 0004: 
; lisp/s-math.pla: 0005: 
; lisp/s-math.pla: 0006: import sexpr
	; DCI STRING: SEXPR
	!BYTE	$D3,$C5,$D8,$D0,$52
					; SEXPR -> X061
; lisp/s-math.pla: 0007:   const TYPE_MASK  = $70
					; TYPE_MASK = 112
; lisp/s-math.pla: 0008:   const NIL        = $00
					; NIL = 0
; lisp/s-math.pla: 0009:   const BOOL_FALSE = $00
					; BOOL_FALSE = 0
; lisp/s-math.pla: 0010:   const BOOL_TRUE  = $01
					; BOOL_TRUE = 1
; lisp/s-math.pla: 0011:   const CONS_TYPE  = $10
					; CONS_TYPE = 16
; lisp/s-math.pla: 0012:   const SYM_TYPE   = $20
					; SYM_TYPE = 32
; lisp/s-math.pla: 0013:   const SYM_LEN    = $0F
					; SYM_LEN = 15
; lisp/s-math.pla: 0014:   const NUM_TYPE   = $30
					; NUM_TYPE = 48
; lisp/s-math.pla: 0015:   const NUM_INT    = $31
					; NUM_INT = 49
; lisp/s-math.pla: 0016:   const NUM_FLOAT  = $32
					; NUM_FLOAT = 50
; lisp/s-math.pla: 0017:   const ARRAY_TYPE = $40
					; ARRAY_TYPE = 64
; lisp/s-math.pla: 0018:   const MARK_BIT   = $80
					; MARK_BIT = 128
; lisp/s-math.pla: 0019:   const MARK_MASK  = $7F
					; MARK_MASK = 127
; lisp/s-math.pla: 0020:   const NULL_HACK  = 1  // Hack so we can set APVALs to NULL
					; NULL_HACK = 1
; lisp/s-math.pla: 0021: 
; lisp/s-math.pla: 0022:   struc t_elem
; lisp/s-math.pla: 0023:     word link
					; link = 0
; lisp/s-math.pla: 0024:     byte type
					; type = 2
; lisp/s-math.pla: 0025:   end
					; t_elem = 3
; lisp/s-math.pla: 0026:   struc t_cons
; lisp/s-math.pla: 0027:     res[t_elem]
; lisp/s-math.pla: 0028:     word car
					; car = 3
; lisp/s-math.pla: 0029:     word cdr
					; cdr = 5
; lisp/s-math.pla: 0030:   end
					; t_cons = 7
; lisp/s-math.pla: 0031:   struc t_sym
; lisp/s-math.pla: 0032:     res[t_elem]
; lisp/s-math.pla: 0033:     word natv
					; natv = 3
; lisp/s-math.pla: 0034:     word lambda
					; lambda = 5
; lisp/s-math.pla: 0035:     word array
					; array = 7
; lisp/s-math.pla: 0036:     word apval
					; apval = 9
; lisp/s-math.pla: 0037:     char name[0]
					; name = 11
; lisp/s-math.pla: 0038:   end
					; t_sym = 11
; lisp/s-math.pla: 0039:   struc t_numint
; lisp/s-math.pla: 0040:     res[t_elem]
; lisp/s-math.pla: 0041:     word intval[2]
					; intval = 3
; lisp/s-math.pla: 0042:   end
					; t_numint = 7
; lisp/s-math.pla: 0043:   struc t_numfloat
; lisp/s-math.pla: 0044:     res[t_elem]
; lisp/s-math.pla: 0045:     res floatval[10]
					; floatval = 3
; lisp/s-math.pla: 0046:   end
					; t_numfloat = 13
; lisp/s-math.pla: 0047: 
; lisp/s-math.pla: 0048:   const ERR_INTERNAL     = -1
					; ERR_INTERNAL = -1
; lisp/s-math.pla: 0049:   const ERR_OUT_OF_MEM   = -2
					; ERR_OUT_OF_MEM = -2
; lisp/s-math.pla: 0050:   const ERR_SWEEP_OVRFLW = -3
					; ERR_SWEEP_OVRFLW = -3
; lisp/s-math.pla: 0051:   const ERR_SWEEP_UNDFLW = -4
					; ERR_SWEEP_UNDFLW = -4
; lisp/s-math.pla: 0052:   const ERR_BAD_DOT      = -5
					; ERR_BAD_DOT = -5
; lisp/s-math.pla: 0053:   const ERR_NOT_SYM      = -6
					; ERR_NOT_SYM = -6
; lisp/s-math.pla: 0054:   const ERR_NOT_ASSOC    = -7
					; ERR_NOT_ASSOC = -7
; lisp/s-math.pla: 0055:   const ERR_NOT_FUN      = -8
					; ERR_NOT_FUN = -8
; lisp/s-math.pla: 0056:   const ERR_NOT_NUM      = -9
					; ERR_NOT_NUM = -9
; lisp/s-math.pla: 0057:   const ERR_NOT_INT      = -10
					; ERR_NOT_INT = -10
; lisp/s-math.pla: 0058:   const ERR_NOT_FLOAT    = -11
					; ERR_NOT_FLOAT = -11
; lisp/s-math.pla: 0059:   const ERR_NOT_STR      = -12
					; ERR_NOT_STR = -12
; lisp/s-math.pla: 0060:   const ERR_BAD_INDEX    = -13
					; ERR_BAD_INDEX = -13
; lisp/s-math.pla: 0061:   const ERR_BAD_GO       = -14
					; ERR_BAD_GO = -14
; lisp/s-math.pla: 0062: 
; lisp/s-math.pla: 0063:   var exception
					; EXCEPTION -> X062
; lisp/s-math.pla: 0064:   var err_expr
					; ERR_EXPR -> X063
; lisp/s-math.pla: 0065: 
; lisp/s-math.pla: 0066:   predef new_sym(symstr)#1
					; NEW_SYM -> X064
; lisp/s-math.pla: 0067:   predef new_int(intlo, inthi)#1
					; NEW_INT -> X065
; lisp/s-math.pla: 0068:   predef new_float(extptr)#1
					; NEW_FLOAT -> X066
; lisp/s-math.pla: 0069:   predef print_expr(expr)#0
					; PRINT_EXPR -> X067
; lisp/s-math.pla: 0070:   predef eval_expr(expr)#1
					; EVAL_EXPR -> X068
; lisp/s-math.pla: 0071:   predef bool_pred(bool)#1
					; BOOL_PRED -> X069
; lisp/s-math.pla: 0072: end
; lisp/s-math.pla: 0073: 
; lisp/s-math.pla: 0074: res[t_numint] nan = 0, 0, NUM_INT, 0, 0, 0, 128 // NaN
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_D070 					; nan = 0, 0, NUM_INT, 0, 0, 0, 128 // NaN
	!BYTE	$00
	!BYTE	$00
	!BYTE	$31
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$80
; lisp/s-math.pla: 0075: 
; lisp/s-math.pla: 0076: //
; lisp/s-math.pla: 0077: // Useful constants
; lisp/s-math.pla: 0078: //
; lisp/s-math.pla: 0079: 
; lisp/s-math.pla: 0080: res[t_extended] ext_pi = $35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40
_D071 					; ext_pi = $35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40
	!BYTE	$35
	!BYTE	$C2
	!BYTE	$68
	!BYTE	$21
	!BYTE	$A2
	!BYTE	$DA
	!BYTE	$0F
	!BYTE	$C9
	!BYTE	$00
	!BYTE	$40
; lisp/s-math.pla: 0081: res[t_extended] ext_e  = $9B,$4A,$BB,$A2,$5B,$54,$F8,$AD,$00,$40
_D072 					; ext_e  = $9B,$4A,$BB,$A2,$5B,$54,$F8,$AD,$00,$40
	!BYTE	$9B
	!BYTE	$4A
	!BYTE	$BB
	!BYTE	$A2
	!BYTE	$5B
	!BYTE	$54
	!BYTE	$F8
	!BYTE	$AD
	!BYTE	$00
	!BYTE	$40
; lisp/s-math.pla: 0082: 
; lisp/s-math.pla: 0083: res[t_extended] tempext
_D073 	!FILL	10			; tempext
; lisp/s-math.pla: 0084: 
; lisp/s-math.pla: 0085: def int32_ext(intptr)
_SUBSEG 				; BYTECODE STARTS
					; intptr -> [0]
_C000 					; int32_ext()
; lisp/s-math.pla: 0086:   word[4] int64
					; int64 -> [2]
; lisp/s-math.pla: 0087: 
; lisp/s-math.pla: 0088:   int64[0] = intptr=>[0]
	!BYTE	$58,$0A,$01		; ENTER	10,1
; lisp/s-math.pla: 0089:   int64[1] = intptr=>[1]
; lisp/s-math.pla: 0090:   if int64[1] < 0
; lisp/s-math.pla: 0091:     int64[2] = -1
; lisp/s-math.pla: 0092:     int64[3] = -1
; lisp/s-math.pla: 0093:   else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B001
	!WORD	_B001-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B001 
; lisp/s-math.pla: 0094:     int64[2] = 0
; lisp/s-math.pla: 0095:     int64[3] = 0
; lisp/s-math.pla: 0096:   fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
_B002 
; lisp/s-math.pla: 0097:   sane:saveZP()
; lisp/s-math.pla: 0098:   sane:restoreZP(sane:op2FP(FFCOMP|FOZ2X, @tempext, @int64))
; lisp/s-math.pla: 0099:   return @tempext
	!BYTE	$6A			; LAW	_X057+18
_F000 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$05		; CW	1294
	!BYTE	$26			; LA	_D073+0
_F001 	!WORD	_D073+0		
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X057+8
_F002 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F003 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D073+0
_F004 	!WORD	_D073+0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0100: end
; lisp/s-math.pla: 0101: 
; lisp/s-math.pla: 0102: def num_ext(numptr)
					; numptr -> [0]
_C001 					; num_ext()
; lisp/s-math.pla: 0103: 
; lisp/s-math.pla: 0104:   if numptr->type == NUM_FLOAT
	!BYTE	$58,$02,$01		; ENTER	2,1
; lisp/s-math.pla: 0105:     return numptr + floatval
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B003
	!WORD	_B003-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-math.pla: 0106:   fin
_B003 
_B004 
; lisp/s-math.pla: 0107:   return int32_ext(numptr + intval)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_C000
_F005 	!WORD	_C000		
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-math.pla: 0108: end
; lisp/s-math.pla: 0109: 
; lisp/s-math.pla: 0110: def eval_num(expr)
					; expr -> [0]
_C002 					; eval_num()
; lisp/s-math.pla: 0111:   var result
					; result -> [2]
; lisp/s-math.pla: 0112: 
; lisp/s-math.pla: 0113:   result = eval_expr(expr=>car)
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-math.pla: 0114:   if !result or result->type & TYPE_MASK <> NUM_TYPE
; lisp/s-math.pla: 0115:     err_expr = expr
; lisp/s-math.pla: 0116:     throw(exception, ERR_NOT_NUM)
; lisp/s-math.pla: 0117:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X068
_F006 	!WORD	0		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B005
	!WORD	_B005-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$30			; CB	48
	!BYTE	$42			; ISNE
_B005 
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_X063+0
_F007 	!WORD	0+0		
	!BYTE	$6A			; LAW	_X062+0
_F008 	!WORD	0+0		
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$54			; CALL	_X060
_F009 	!WORD	0		
	!BYTE	$30			; DROP 
_B006 
_B007 
; lisp/s-math.pla: 0118:   return result
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0119: end
; lisp/s-math.pla: 0120: 
; lisp/s-math.pla: 0121: def eval_ext(expr)
					; expr -> [0]
_C003 					; eval_ext()
; lisp/s-math.pla: 0122:   var result
					; result -> [2]
; lisp/s-math.pla: 0123: 
; lisp/s-math.pla: 0124:   result = eval_num(expr)
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-math.pla: 0125:   if result->type == NUM_INT
; lisp/s-math.pla: 0126:     return int32_ext(result + intval)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C002
_F010 	!WORD	_C002		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B008
	!WORD	_B008-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_C000
_F011 	!WORD	_C000		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0127:   fin
_B008 
_B009 
; lisp/s-math.pla: 0128:   return result + floatval
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0129: end
; lisp/s-math.pla: 0130: 
; lisp/s-math.pla: 0131: export def eval_int(expr)#1 // Always return an int
					; expr -> [0]
_C004 					; eval_int()
; lisp/s-math.pla: 0132:   var result
					; result -> [2]
; lisp/s-math.pla: 0133:   word[4] int64
					; int64 -> [4]
; lisp/s-math.pla: 0134: 
; lisp/s-math.pla: 0135:   result = eval_num(expr)
	!BYTE	$58,$0C,$01		; ENTER	12,1
; lisp/s-math.pla: 0136:   if result->type == NUM_FLOAT
; lisp/s-math.pla: 0137:     sane:saveZP()
; lisp/s-math.pla: 0138:     sane:restoreZP(sane:op2FP(FFCOMP|FOX2Z, @int64, result + floatval))
; lisp/s-math.pla: 0139:     return new_int(int64[0], int64[1])
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C002
_F012 	!WORD	_C002		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B010
	!WORD	_B010-*
	!BYTE	$6A			; LAW	_X057+18
_F013 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$05		; CW	1296
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$6A			; LAW	_X057+8
_F014 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F015 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X065
_F016 	!WORD	0		
	!BYTE	$5A,$0C			; LEAVE	12
; lisp/s-math.pla: 0140:   fin
_B010 
_B011 
; lisp/s-math.pla: 0141:   return result
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$0C			; LEAVE	12
; lisp/s-math.pla: 0142: end
; lisp/s-math.pla: 0143: 
; lisp/s-math.pla: 0144: export def eval_int16(expr)#1 // Always return an int
					; expr -> [0]
_C005 					; eval_int16()
; lisp/s-math.pla: 0145:   var result
					; result -> [2]
; lisp/s-math.pla: 0146:   word[4] int64
					; int64 -> [4]
; lisp/s-math.pla: 0147: 
; lisp/s-math.pla: 0148:   result = eval_num(expr)
	!BYTE	$58,$0C,$01		; ENTER	12,1
; lisp/s-math.pla: 0149:   if result->type == NUM_FLOAT
; lisp/s-math.pla: 0150:     sane:saveZP()
; lisp/s-math.pla: 0151:     sane:restoreZP(sane:op2FP(FFCOMP|FOX2Z, @int64, result + floatval))
; lisp/s-math.pla: 0152:     return int64
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C002
_F017 	!WORD	_C002		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B012
	!WORD	_B012-*
	!BYTE	$6A			; LAW	_X057+18
_F018 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$05		; CW	1296
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$6A			; LAW	_X057+8
_F019 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F020 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$0C			; LEAVE	12
; lisp/s-math.pla: 0153:   fin
_B012 
_B013 
; lisp/s-math.pla: 0154:   return result=>intval
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$5A,$0C			; LEAVE	12
; lisp/s-math.pla: 0155: end
; lisp/s-math.pla: 0156: 
; lisp/s-math.pla: 0157: def natv_integer(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C006 					; natv_integer()
; lisp/s-math.pla: 0158:   return eval_int(expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F021 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0159: end
; lisp/s-math.pla: 0160: 
; lisp/s-math.pla: 0161: def natv_sum(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C007 					; natv_sum()
; lisp/s-math.pla: 0162:   var num, extptr
					; num -> [4]
					; extptr -> [6]
; lisp/s-math.pla: 0163:   word[2]         intsum
					; intsum -> [8]
; lisp/s-math.pla: 0164:   res[t_extended] extsum
					; extsum -> [12]
; lisp/s-math.pla: 0165: 
; lisp/s-math.pla: 0166:   intsum[0] = 0
	!BYTE	$58,$16,$02		; ENTER	22,2
; lisp/s-math.pla: 0167:   intsum[1] = 0
; lisp/s-math.pla: 0168:   num       = eval_num(expr)
; lisp/s-math.pla: 0169:   expr      = expr=>cdr
; lisp/s-math.pla: 0170:   if num->type == NUM_INT
; lisp/s-math.pla: 0171:     //
; lisp/s-math.pla: 0172:     // Sum as integers unless a float is encountered
; lisp/s-math.pla: 0173:     //
; lisp/s-math.pla: 0174:     intsum[0] = num=>intval[0]
; lisp/s-math.pla: 0175:     intsum[1] = num=>intval[1]
; lisp/s-math.pla: 0176:     while expr
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F022 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B014
	!WORD	_B014-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B018
	!WORD	_B018-*
_B016 
; lisp/s-math.pla: 0177:       num  = eval_num(expr)
; lisp/s-math.pla: 0178:       expr = expr=>cdr
; lisp/s-math.pla: 0179:       if num->type == NUM_FLOAT
; lisp/s-math.pla: 0180:         break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F023 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B019
	!WORD	_B019-*
	!BYTE	$50			; BRNCH	_B017
	!WORD	_B017-*
; lisp/s-math.pla: 0181:       fin
_B019 
_B020 
; lisp/s-math.pla: 0182:       load32(@intsum)
; lisp/s-math.pla: 0183:       add32(num + intval)
; lisp/s-math.pla: 0184:       store32(@intsum)
; lisp/s-math.pla: 0185:     loop
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_X032
_F024 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X035
_F025 	!WORD	0		
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_X034
_F026 	!WORD	0		
_B018 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B016
	!WORD	_B016-*
_B017 
; lisp/s-math.pla: 0186:   fin
_B014 
_B015 
; lisp/s-math.pla: 0187:   if num->type == NUM_FLOAT
; lisp/s-math.pla: 0188:     //
; lisp/s-math.pla: 0189:     // Sum as floating point numbers
; lisp/s-math.pla: 0190:     //
; lisp/s-math.pla: 0191:     int32_ext(@intsum)
; lisp/s-math.pla: 0192:     memcpy(@extsum, num + floatval, t_extended)
; lisp/s-math.pla: 0193:     sane:saveZP()
; lisp/s-math.pla: 0194:     sane:restoreZP(sane:op2FP(FOADD, @extsum, @tempext))
; lisp/s-math.pla: 0195:     while expr
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B021
	!WORD	_B021-*
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C000
_F027 	!WORD	_C000		
	!BYTE	$30			; DROP 
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F028 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F029 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$26			; LA	_D073+0
_F030 	!WORD	_D073+0		
	!BYTE	$6A			; LAW	_X057+8
_F031 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F032 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B025
	!WORD	_B025-*
_B023 
; lisp/s-math.pla: 0196:       extptr = eval_ext(expr)
; lisp/s-math.pla: 0197:       sane:saveZP()
; lisp/s-math.pla: 0198:       sane:restoreZP(sane:op2FP(FOADD, @extsum, extptr))
; lisp/s-math.pla: 0199:       expr = expr=>cdr
; lisp/s-math.pla: 0200:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F033 	!WORD	_C003		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_X057+18
_F034 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_X057+8
_F035 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F036 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B025 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B023
	!WORD	_B023-*
_B024 
; lisp/s-math.pla: 0201:     return new_float(@extsum)
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$54			; CALL	_X066
_F037 	!WORD	0		
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-math.pla: 0202:   fin
_B021 
_B022 
; lisp/s-math.pla: 0203:   return new_int(intsum[0], intsum[1])
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_X065
_F038 	!WORD	0		
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-math.pla: 0204: end
; lisp/s-math.pla: 0205: 
; lisp/s-math.pla: 0206: def natv_sub(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C008 					; natv_sub()
; lisp/s-math.pla: 0207:   res[t_numfloat] num1, num2
					; num1 -> [4]
					; num2 -> [17]
; lisp/s-math.pla: 0208:   word[2] dif
					; dif -> [30]
; lisp/s-math.pla: 0209:   res[t_extended] ext1, ext2
					; ext1 -> [34]
					; ext2 -> [44]
; lisp/s-math.pla: 0210: 
; lisp/s-math.pla: 0211:   memcpy(@num1, eval_num(expr),      t_numfloat)
	!BYTE	$58,$36,$02		; ENTER	54,2
; lisp/s-math.pla: 0212:   memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
; lisp/s-math.pla: 0213:   if num1.type == NUM_INT and num2.type == NUM_INT
; lisp/s-math.pla: 0214:     load32(@num1 + intval)
; lisp/s-math.pla: 0215:     sub32(@num2 + intval)
; lisp/s-math.pla: 0216:     store32(@dif)
; lisp/s-math.pla: 0217:     return new_int(dif[0], dif[1])
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F039 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F040 	!WORD	0		
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F041 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F042 	!WORD	0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B026
	!WORD	_B026-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
_B026 
	!BYTE	$4C			; BRFLS	_B027
	!WORD	_B027-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_X032
_F043 	!WORD	0		
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$54			; CALL	_X037
_F044 	!WORD	0		
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$54			; CALL	_X034
_F045 	!WORD	0		
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_X065
_F046 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0218:   fin
_B027 
_B028 
; lisp/s-math.pla: 0219:   memcpy(@ext1, num_ext(@num1), t_extended)
; lisp/s-math.pla: 0220:   memcpy(@ext2, num_ext(@num2), t_extended)
; lisp/s-math.pla: 0221:   sane:saveZP()
; lisp/s-math.pla: 0222:   sane:restoreZP(sane:op2FP(FOSUB, @ext1, @ext2))
; lisp/s-math.pla: 0223:   return new_float(@ext1)
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C001
_F047 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F048 	!WORD	0		
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$54			; CALL	_C001
_F049 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F050 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F051 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$6A			; LAW	_X057+8
_F052 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F053 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$54			; CALL	_X066
_F054 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0224: end
; lisp/s-math.pla: 0225: 
; lisp/s-math.pla: 0226: def natv_mul(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C009 					; natv_mul()
; lisp/s-math.pla: 0227:   var num, extptr
					; num -> [4]
					; extptr -> [6]
; lisp/s-math.pla: 0228:   word[2]         intmul
					; intmul -> [8]
; lisp/s-math.pla: 0229:   res[t_extended] extmul
					; extmul -> [12]
; lisp/s-math.pla: 0230: 
; lisp/s-math.pla: 0231:   intmul[0] = 1
	!BYTE	$58,$16,$02		; ENTER	22,2
; lisp/s-math.pla: 0232:   intmul[1] = 0
; lisp/s-math.pla: 0233:   num       = eval_num(expr)
; lisp/s-math.pla: 0234:   expr      = expr=>cdr
; lisp/s-math.pla: 0235:   if num->type == NUM_INT
; lisp/s-math.pla: 0236:     //
; lisp/s-math.pla: 0237:     // Multiply as integers unless a float is encountered
; lisp/s-math.pla: 0238:     //
; lisp/s-math.pla: 0239:     intmul[0] = num=>intval[0]
; lisp/s-math.pla: 0240:     intmul[1] = num=>intval[1]
; lisp/s-math.pla: 0241:     while expr
	!BYTE	$02			; CN	1
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F055 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B029
	!WORD	_B029-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B033
	!WORD	_B033-*
_B031 
; lisp/s-math.pla: 0242:       num  = eval_num(expr)
; lisp/s-math.pla: 0243:       expr = expr=>cdr
; lisp/s-math.pla: 0244:       if num->type == NUM_FLOAT
; lisp/s-math.pla: 0245:         break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F056 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B034
	!WORD	_B034-*
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
; lisp/s-math.pla: 0246:       fin
_B034 
_B035 
; lisp/s-math.pla: 0247:       load32(@intmul)
; lisp/s-math.pla: 0248:       mul32(num + intval)
; lisp/s-math.pla: 0249:       store32(@intmul)
; lisp/s-math.pla: 0250:     loop
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_X032
_F057 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X041
_F058 	!WORD	0		
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_X034
_F059 	!WORD	0		
_B033 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B031
	!WORD	_B031-*
_B032 
; lisp/s-math.pla: 0251:   fin
_B029 
_B030 
; lisp/s-math.pla: 0252:   if num->type == NUM_FLOAT
; lisp/s-math.pla: 0253:     //
; lisp/s-math.pla: 0254:     // Multiply as floating point numbers
; lisp/s-math.pla: 0255:     //
; lisp/s-math.pla: 0256:     int32_ext(@intmul)
; lisp/s-math.pla: 0257:     memcpy(@extmul, num + floatval, t_extended)
; lisp/s-math.pla: 0258:     sane:saveZP()
; lisp/s-math.pla: 0259:     sane:restoreZP(sane:op2FP(FOMUL, @extmul, @tempext))
; lisp/s-math.pla: 0260:     while expr
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B036
	!WORD	_B036-*
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C000
_F060 	!WORD	_C000		
	!BYTE	$30			; DROP 
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F061 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F062 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$26			; LA	_D073+0
_F063 	!WORD	_D073+0		
	!BYTE	$6A			; LAW	_X057+8
_F064 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F065 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B040
	!WORD	_B040-*
_B038 
; lisp/s-math.pla: 0261:       extptr = eval_ext(expr)
; lisp/s-math.pla: 0262:       sane:saveZP()
; lisp/s-math.pla: 0263:       sane:restoreZP(sane:op2FP(FOMUL, @extmul, extptr))
; lisp/s-math.pla: 0264:       expr = expr=>cdr
; lisp/s-math.pla: 0265:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F066 	!WORD	_C003		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_X057+18
_F067 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_X057+8
_F068 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F069 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B040 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B038
	!WORD	_B038-*
_B039 
; lisp/s-math.pla: 0266:     return new_float(@extmul)
	!BYTE	$28,$0C			; LLA	[12]
	!BYTE	$54			; CALL	_X066
_F070 	!WORD	0		
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-math.pla: 0267:   fin
_B036 
_B037 
; lisp/s-math.pla: 0268:   return new_int(intmul[0], intmul[1])
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_X065
_F071 	!WORD	0		
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-math.pla: 0269: end
; lisp/s-math.pla: 0270: 
; lisp/s-math.pla: 0271: def natv_div(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C010 					; natv_div()
; lisp/s-math.pla: 0272:   res[t_numfloat] num1, num2
					; num1 -> [4]
					; num2 -> [17]
; lisp/s-math.pla: 0273:   word[2] div
					; div -> [30]
; lisp/s-math.pla: 0274:   res[t_extended] ext1, ext2
					; ext1 -> [34]
					; ext2 -> [44]
; lisp/s-math.pla: 0275: 
; lisp/s-math.pla: 0276:   memcpy(@num1, eval_num(expr),      t_numfloat)
	!BYTE	$58,$36,$02		; ENTER	54,2
; lisp/s-math.pla: 0277:   memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
; lisp/s-math.pla: 0278:   if num1.type == NUM_INT and num2.type == NUM_INT
; lisp/s-math.pla: 0279:     load32(@num1 + intval)
; lisp/s-math.pla: 0280:     div32(@num2 + intval)
; lisp/s-math.pla: 0281:     store32(@div)
; lisp/s-math.pla: 0282:     return new_int(div[0], div[1])
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F072 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F073 	!WORD	0		
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F074 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F075 	!WORD	0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B041
	!WORD	_B041-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
_B041 
	!BYTE	$4C			; BRFLS	_B042
	!WORD	_B042-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_X032
_F076 	!WORD	0		
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$54			; CALL	_X043
_F077 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$30			; DROP 
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$54			; CALL	_X034
_F078 	!WORD	0		
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_X065
_F079 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0283:   fin
_B042 
_B043 
; lisp/s-math.pla: 0284:   memcpy(@ext1, num_ext(@num1), t_extended)
; lisp/s-math.pla: 0285:   memcpy(@ext2, num_ext(@num2), t_extended)
; lisp/s-math.pla: 0286:   sane:saveZP()
; lisp/s-math.pla: 0287:   sane:restoreZP(sane:op2FP(FODIV, @ext1, @ext2))
; lisp/s-math.pla: 0288:   return new_float(@ext1)
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C001
_F080 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F081 	!WORD	0		
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$54			; CALL	_C001
_F082 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F083 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F084 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$0C			; CN	6
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$6A			; LAW	_X057+8
_F085 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F086 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$54			; CALL	_X066
_F087 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0289: end
; lisp/s-math.pla: 0290: 
; lisp/s-math.pla: 0291: def natv_rem(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C011 					; natv_rem()
; lisp/s-math.pla: 0292:   res[t_numfloat] num1, num2
					; num1 -> [4]
					; num2 -> [17]
; lisp/s-math.pla: 0293:   word[2] rem
					; rem -> [30]
; lisp/s-math.pla: 0294:   res[t_extended] ext1, ext2
					; ext1 -> [34]
					; ext2 -> [44]
; lisp/s-math.pla: 0295: 
; lisp/s-math.pla: 0296:   memcpy(@num1, eval_num(expr),      t_numfloat)
	!BYTE	$58,$36,$02		; ENTER	54,2
; lisp/s-math.pla: 0297:   memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
; lisp/s-math.pla: 0298:   if num1.type == NUM_INT and num2.type == NUM_INT
; lisp/s-math.pla: 0299:     load32(@num1 + intval)
; lisp/s-math.pla: 0300:     rem[1], rem[0] = div32(@num2 + intval)
; lisp/s-math.pla: 0301:     return new_int(rem[0], rem[1])
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F088 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F089 	!WORD	0		
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F090 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F091 	!WORD	0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B044
	!WORD	_B044-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
_B044 
	!BYTE	$4C			; BRFLS	_B045
	!WORD	_B045-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_X032
_F092 	!WORD	0		
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$54			; CALL	_X043
_F093 	!WORD	0		
	!BYTE	$76,$1E			; SLW	[30]
	!BYTE	$76,$20			; SLW	[32]
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_X065
_F094 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0302:   fin
_B045 
_B046 
; lisp/s-math.pla: 0303:   memcpy(@ext1, num_ext(@num1), t_extended)
; lisp/s-math.pla: 0304:   memcpy(@ext2, num_ext(@num2), t_extended)
; lisp/s-math.pla: 0305:   sane:saveZP()
; lisp/s-math.pla: 0306:   sane:restoreZP(sane:op2FP(FOREM, @ext1, @ext2))
; lisp/s-math.pla: 0307:   return new_float(@ext1)
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C001
_F095 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F096 	!WORD	0		
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$54			; CALL	_C001
_F097 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F098 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F099 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$18			; CN	12
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$28,$2C			; LLA	[44]
	!BYTE	$6A			; LAW	_X057+8
_F100 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F101 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$54			; CALL	_X066
_F102 	!WORD	0		
	!BYTE	$5A,$36			; LEAVE	54
; lisp/s-math.pla: 0308: end
; lisp/s-math.pla: 0309: 
; lisp/s-math.pla: 0310: def natv_neg(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C012 					; natv_neg()
; lisp/s-math.pla: 0311:   var num
					; num -> [4]
; lisp/s-math.pla: 0312:   word[2] neg
					; neg -> [6]
; lisp/s-math.pla: 0313: 
; lisp/s-math.pla: 0314:   num = eval_num(expr)
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-math.pla: 0315:   if num->type == NUM_INT
; lisp/s-math.pla: 0316:     load32(num + intval)
; lisp/s-math.pla: 0317:     neg32
; lisp/s-math.pla: 0318:     store32(@neg)
; lisp/s-math.pla: 0319:     return new_int(neg[0], neg[1])
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F103 	!WORD	_C002		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B047
	!WORD	_B047-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X032
_F104 	!WORD	0		
	!BYTE	$54			; CALL	_X031
_F105 	!WORD	0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X034
_F106 	!WORD	0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_X065
_F107 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0320:   fin
_B047 
_B048 
; lisp/s-math.pla: 0321:   num->floatval[9] = num->floatval[9] ^ $80 // Fun with float bits
; lisp/s-math.pla: 0322:   return new_float(num + floatval)
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$60			; LB
	!BYTE	$2A,$80			; CB	128
	!BYTE	$98			; XOR
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X066
_F108 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0323: end
; lisp/s-math.pla: 0324: 
; lisp/s-math.pla: 0325: def natv_abs(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C013 					; natv_abs()
; lisp/s-math.pla: 0326:   var num
					; num -> [4]
; lisp/s-math.pla: 0327:   word[2] abs
					; abs -> [6]
; lisp/s-math.pla: 0328: 
; lisp/s-math.pla: 0329:   num = eval_num(expr)
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-math.pla: 0330:   if num->type == NUM_INT
; lisp/s-math.pla: 0331:     if num=>intval[1] < 0
; lisp/s-math.pla: 0332:       load32(num + intval)
; lisp/s-math.pla: 0333:       neg32
; lisp/s-math.pla: 0334:       store32(@abs)
; lisp/s-math.pla: 0335:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F109 	!WORD	_C002		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B049
	!WORD	_B049-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B051
	!WORD	_B051-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X032
_F110 	!WORD	0		
	!BYTE	$54			; CALL	_X031
_F111 	!WORD	0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X034
_F112 	!WORD	0		
	!BYTE	$50			; BRNCH	_B052
	!WORD	_B052-*
_B051 
; lisp/s-math.pla: 0336:       abs[0] = num=>intval[0]
; lisp/s-math.pla: 0337:       abs[1] = num=>intval[1]
; lisp/s-math.pla: 0338:     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B052 
; lisp/s-math.pla: 0339:     return new_int(abs[0], abs[1])
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_X065
_F113 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0340:   fin
_B049 
_B050 
; lisp/s-math.pla: 0341:   num->floatval[9] = num->floatval[9] & $7F // Fun with float bits
; lisp/s-math.pla: 0342:   return new_float(num + floatval)
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X066
_F114 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0343: end
; lisp/s-math.pla: 0344: 
; lisp/s-math.pla: 0345: def natv_gt(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C014 					; natv_gt()
; lisp/s-math.pla: 0346:   res[t_numfloat] num1, num2
					; num1 -> [4]
					; num2 -> [17]
; lisp/s-math.pla: 0347:   res[t_extended] ext1, ext2
					; ext1 -> [30]
					; ext2 -> [40]
; lisp/s-math.pla: 0348: 
; lisp/s-math.pla: 0349:   memcpy(@num1, eval_num(expr),      t_numfloat)
	!BYTE	$58,$32,$02		; ENTER	50,2
; lisp/s-math.pla: 0350:   memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
; lisp/s-math.pla: 0351:   if num1.type == NUM_INT and num2.type == NUM_INT
; lisp/s-math.pla: 0352:     load32(@num1 + intval)
; lisp/s-math.pla: 0353:     return bool_pred(isgt32(@num2 + intval))
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F115 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F116 	!WORD	0		
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F117 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F118 	!WORD	0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B053
	!WORD	_B053-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
_B053 
	!BYTE	$4C			; BRFLS	_B054
	!WORD	_B054-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_X032
_F119 	!WORD	0		
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$54			; CALL	_X051
_F120 	!WORD	0		
	!BYTE	$54			; CALL	_X069
_F121 	!WORD	0		
	!BYTE	$5A,$32			; LEAVE	50
; lisp/s-math.pla: 0354:   fin
_B054 
_B055 
; lisp/s-math.pla: 0355:   memcpy(@ext1, num_ext(@num1), t_extended)
; lisp/s-math.pla: 0356:   memcpy(@ext2, num_ext(@num2), t_extended)
; lisp/s-math.pla: 0357:   sane:saveZP()
; lisp/s-math.pla: 0358:   sane:restoreZP(sane:op2FP(FOSUB, @ext2, @ext1))
; lisp/s-math.pla: 0359:   return bool_pred(ext2[9] & $80) // Check sign bit
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C001
_F122 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F123 	!WORD	0		
	!BYTE	$28,$28			; LLA	[40]
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$54			; CALL	_C001
_F124 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F125 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F126 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$28,$28			; LLA	[40]
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$6A			; LAW	_X057+8
_F127 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F128 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$31			; LLB	[49]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$54			; CALL	_X069
_F129 	!WORD	0		
	!BYTE	$5A,$32			; LEAVE	50
; lisp/s-math.pla: 0360: end
; lisp/s-math.pla: 0361: 
; lisp/s-math.pla: 0362: def natv_lt(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C015 					; natv_lt()
; lisp/s-math.pla: 0363:   res[t_numfloat] num1, num2
					; num1 -> [4]
					; num2 -> [17]
; lisp/s-math.pla: 0364:   res[t_extended] ext1, ext2
					; ext1 -> [30]
					; ext2 -> [40]
; lisp/s-math.pla: 0365: 
; lisp/s-math.pla: 0366:   memcpy(@num1, eval_num(expr),      t_numfloat)
	!BYTE	$58,$32,$02		; ENTER	50,2
; lisp/s-math.pla: 0367:   memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
; lisp/s-math.pla: 0368:   if num1.type == NUM_INT and num2.type == NUM_INT
; lisp/s-math.pla: 0369:     load32(@num1 + intval)
; lisp/s-math.pla: 0370:     return bool_pred(islt32(@num2 + intval))
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F130 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F131 	!WORD	0		
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C002
_F132 	!WORD	_C002		
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_X018
_F133 	!WORD	0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B056
	!WORD	_B056-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$31			; CB	49
	!BYTE	$40			; ISEQ
_B056 
	!BYTE	$4C			; BRFLS	_B057
	!WORD	_B057-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_X032
_F134 	!WORD	0		
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$54			; CALL	_X053
_F135 	!WORD	0		
	!BYTE	$54			; CALL	_X069
_F136 	!WORD	0		
	!BYTE	$5A,$32			; LEAVE	50
; lisp/s-math.pla: 0371:   fin
_B057 
_B058 
; lisp/s-math.pla: 0372:   memcpy(@ext1, num_ext(@num1), t_extended)
; lisp/s-math.pla: 0373:   memcpy(@ext2, num_ext(@num2), t_extended)
; lisp/s-math.pla: 0374:   sane:saveZP()
; lisp/s-math.pla: 0375:   sane:restoreZP(sane:op2FP(FOSUB, @ext1, @ext2))
; lisp/s-math.pla: 0376:   return bool_pred(ext1[9] & $80) // Check sign bit
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C001
_F137 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F138 	!WORD	0		
	!BYTE	$28,$28			; LLA	[40]
	!BYTE	$28,$11			; LLA	[17]
	!BYTE	$54			; CALL	_C001
_F139 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F140 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F141 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$28,$28			; LLA	[40]
	!BYTE	$6A			; LAW	_X057+8
_F142 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F143 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$27			; LLB	[39]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$54			; CALL	_X069
_F144 	!WORD	0		
	!BYTE	$5A,$32			; LEAVE	50
; lisp/s-math.pla: 0377: end
; lisp/s-math.pla: 0378: 
; lisp/s-math.pla: 0379: def natv_min(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C016 					; natv_min()
; lisp/s-math.pla: 0380:   var num
					; num -> [4]
; lisp/s-math.pla: 0381:   word[2] intmin
					; intmin -> [6]
; lisp/s-math.pla: 0382:   res[t_extended] extmin, ext1, ext2
					; extmin -> [10]
					; ext1 -> [20]
					; ext2 -> [30]
; lisp/s-math.pla: 0383: 
; lisp/s-math.pla: 0384:   num  = eval_num(expr)
	!BYTE	$58,$28,$02		; ENTER	40,2
; lisp/s-math.pla: 0385:   expr = expr=>cdr
; lisp/s-math.pla: 0386:   if num->type == NUM_INT
; lisp/s-math.pla: 0387:     //
; lisp/s-math.pla: 0388:     // Find min as integers unless a float is encountered
; lisp/s-math.pla: 0389:     //
; lisp/s-math.pla: 0390:     intmin[0] = num=>intval[0]
; lisp/s-math.pla: 0391:     intmin[1] = num=>intval[1]
; lisp/s-math.pla: 0392:     while expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F145 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B059
	!WORD	_B059-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B063
	!WORD	_B063-*
_B061 
; lisp/s-math.pla: 0393:       num = eval_num(expr)
; lisp/s-math.pla: 0394:       if num->type == NUM_FLOAT
; lisp/s-math.pla: 0395:         memcpy(@extmin, int32_ext(@intmin), t_extended)
; lisp/s-math.pla: 0396:         break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F146 	!WORD	_C002		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B064
	!WORD	_B064-*
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C000
_F147 	!WORD	_C000		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F148 	!WORD	0		
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
; lisp/s-math.pla: 0397:       fin
_B064 
_B065 
; lisp/s-math.pla: 0398:       load32(@intmin)
; lisp/s-math.pla: 0399:       if isgt32(num + intval)
; lisp/s-math.pla: 0400:         intmin[0] = num=>intval[0]
; lisp/s-math.pla: 0401:         intmin[1] = num=>intval[1]
; lisp/s-math.pla: 0402:       fin
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X032
_F149 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X051
_F150 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B066
	!WORD	_B066-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B066 
_B067 
; lisp/s-math.pla: 0403:       expr = expr=>cdr
; lisp/s-math.pla: 0404:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B063 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B061
	!WORD	_B061-*
_B062 
; lisp/s-math.pla: 0405:     if !expr; return new_int(intmin[0], intmin[1]); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B068
	!WORD	_B068-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_X065
_F151 	!WORD	0		
	!BYTE	$5A,$28			; LEAVE	40
_B068 
_B069 
; lisp/s-math.pla: 0406:   else
	!BYTE	$50			; BRNCH	_B060
	!WORD	_B060-*
_B059 
; lisp/s-math.pla: 0407:     memcpy(@extmin, num + floatval, t_extended)
; lisp/s-math.pla: 0408:     if expr; num = eval_num(expr); fin
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F152 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B070
	!WORD	_B070-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F153 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
_B070 
_B071 
; lisp/s-math.pla: 0409:   fin
_B060 
; lisp/s-math.pla: 0410:   while expr
	!BYTE	$50			; BRNCH	_B074
	!WORD	_B074-*
_B072 
; lisp/s-math.pla: 0411:     memcpy(@ext1, num_ext(num), t_extended)
; lisp/s-math.pla: 0412:     memcpy(@ext2, @ext1,        t_extended)
; lisp/s-math.pla: 0413:     sane:saveZP()
; lisp/s-math.pla: 0414:     sane:restoreZP(sane:op2FP(FOSUB, @ext2, @extmin))
; lisp/s-math.pla: 0415:     if ext2[9] & $80 // Check sign bit
; lisp/s-math.pla: 0416:       memcpy(@extmin, @ext1, t_extended)
; lisp/s-math.pla: 0417:     fin
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C001
_F154 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F155 	!WORD	0		
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F156 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F157 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$6A			; LAW	_X057+8
_F158 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F159 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$27			; LLB	[39]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F160 	!WORD	0		
_B075 
_B076 
; lisp/s-math.pla: 0418:     expr = expr=>cdr
; lisp/s-math.pla: 0419:     if expr; num = eval_num(expr); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B077
	!WORD	_B077-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F161 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
_B077 
_B078 
; lisp/s-math.pla: 0420:   loop
_B074 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B072
	!WORD	_B072-*
_B073 
; lisp/s-math.pla: 0421:   return new_float(@extmin)
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$54			; CALL	_X066
_F162 	!WORD	0		
	!BYTE	$5A,$28			; LEAVE	40
; lisp/s-math.pla: 0422: end
; lisp/s-math.pla: 0423: 
; lisp/s-math.pla: 0424: def natv_max(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C017 					; natv_max()
; lisp/s-math.pla: 0425:   var num
					; num -> [4]
; lisp/s-math.pla: 0426:   word[2] intmax
					; intmax -> [6]
; lisp/s-math.pla: 0427:   res[t_extended] extmax, ext1, ext2
					; extmax -> [10]
					; ext1 -> [20]
					; ext2 -> [30]
; lisp/s-math.pla: 0428: 
; lisp/s-math.pla: 0429:   num  = eval_num(expr)
	!BYTE	$58,$28,$02		; ENTER	40,2
; lisp/s-math.pla: 0430:   expr = expr=>cdr
; lisp/s-math.pla: 0431:   if num->type == NUM_INT
; lisp/s-math.pla: 0432:     //
; lisp/s-math.pla: 0433:     // Find max as integers unless a float is encountered
; lisp/s-math.pla: 0434:     //
; lisp/s-math.pla: 0435:     intmax[0] = num=>intval[0]
; lisp/s-math.pla: 0436:     intmax[1] = num=>intval[1]
; lisp/s-math.pla: 0437:     while expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F163 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B079
	!WORD	_B079-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B083
	!WORD	_B083-*
_B081 
; lisp/s-math.pla: 0438:       num = eval_num(expr)
; lisp/s-math.pla: 0439:       if num->type == NUM_FLOAT
; lisp/s-math.pla: 0440:         memcpy(@extmax, int32_ext(@intmax), t_extended)
; lisp/s-math.pla: 0441:         break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F164 	!WORD	_C002		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B084
	!WORD	_B084-*
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C000
_F165 	!WORD	_C000		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F166 	!WORD	0		
	!BYTE	$50			; BRNCH	_B082
	!WORD	_B082-*
; lisp/s-math.pla: 0442:       fin
_B084 
_B085 
; lisp/s-math.pla: 0443:       load32(@intmax)
; lisp/s-math.pla: 0444:       if islt32(num + intval)
; lisp/s-math.pla: 0445:         intmax[0] = num=>intval[0]
; lisp/s-math.pla: 0446:         intmax[1] = num=>intval[1]
; lisp/s-math.pla: 0447:       fin
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X032
_F167 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X053
_F168 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B086 
_B087 
; lisp/s-math.pla: 0448:       expr = expr=>cdr
; lisp/s-math.pla: 0449:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B083 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B081
	!WORD	_B081-*
_B082 
; lisp/s-math.pla: 0450:     if !expr; return new_int(intmax[0], intmax[1]); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B088
	!WORD	_B088-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_X065
_F169 	!WORD	0		
	!BYTE	$5A,$28			; LEAVE	40
_B088 
_B089 
; lisp/s-math.pla: 0451:   else
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B079 
; lisp/s-math.pla: 0452:     memcpy(@extmax, num + floatval, t_extended)
; lisp/s-math.pla: 0453:     if expr; num = eval_num(expr); fin
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F170 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B090
	!WORD	_B090-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F171 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
_B090 
_B091 
; lisp/s-math.pla: 0454:   fin
_B080 
; lisp/s-math.pla: 0455:   while expr
	!BYTE	$50			; BRNCH	_B094
	!WORD	_B094-*
_B092 
; lisp/s-math.pla: 0456:     memcpy(@ext1, @extmax,      t_extended)
; lisp/s-math.pla: 0457:     memcpy(@ext2, num_ext(num), t_extended)
; lisp/s-math.pla: 0458:     sane:saveZP()
; lisp/s-math.pla: 0459:     sane:restoreZP(sane:op2FP(FOSUB, @ext1, @ext2))
; lisp/s-math.pla: 0460:     if ext1[9] & $80 // Check sign bit
; lisp/s-math.pla: 0461:       memcpy(@extmax, @ext2, t_extended)
; lisp/s-math.pla: 0462:     fin
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F172 	!WORD	0		
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C001
_F173 	!WORD	_C001		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F174 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F175 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$6A			; LAW	_X057+8
_F176 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F177 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$1D			; LLB	[29]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B095
	!WORD	_B095-*
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$28,$1E			; LLA	[30]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F178 	!WORD	0		
_B095 
_B096 
; lisp/s-math.pla: 0463:     expr = expr=>cdr
; lisp/s-math.pla: 0464:     if expr; num = eval_num(expr); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B097
	!WORD	_B097-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F179 	!WORD	_C002		
	!BYTE	$76,$04			; SLW	[4]
_B097 
_B098 
; lisp/s-math.pla: 0465:   loop
_B094 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B092
	!WORD	_B092-*
_B093 
; lisp/s-math.pla: 0466:   return new_float(@extmax)
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$54			; CALL	_X066
_F180 	!WORD	0		
	!BYTE	$5A,$28			; LEAVE	40
; lisp/s-math.pla: 0467: end
; lisp/s-math.pla: 0468: 
; lisp/s-math.pla: 0469: def sane_op1(op1, expr)
					; op1 -> [0]
					; expr -> [2]
_C018 					; sane_op1()
; lisp/s-math.pla: 0470:   res[t_extended] ext
					; ext -> [4]
; lisp/s-math.pla: 0471: 
; lisp/s-math.pla: 0472:   memcpy(@ext, eval_ext(expr), t_extended)
	!BYTE	$58,$0E,$02		; ENTER	14,2
; lisp/s-math.pla: 0473:   sane:saveZP()
; lisp/s-math.pla: 0474:   sane:restoreZP(sane:op1FP(op1, @ext))
; lisp/s-math.pla: 0475:   return new_float(@ext)
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F181 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F182 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F183 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$6A			; LAW	_X057+6
_F184 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F185 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_X066
_F186 	!WORD	0		
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-math.pla: 0476: end
; lisp/s-math.pla: 0477: 
; lisp/s-math.pla: 0478: def natv_logb(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C019 					; natv_logb()
; lisp/s-math.pla: 0479:   return sane_op1(FOLOGB, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C018
_F187 	!WORD	_C018		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0480: end
; lisp/s-math.pla: 0481: 
; lisp/s-math.pla: 0482: def natv_scalebI(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C020 					; natv_scalebI()
; lisp/s-math.pla: 0483:   var int
					; int -> [4]
; lisp/s-math.pla: 0484:   res[t_extended] ext
					; ext -> [6]
; lisp/s-math.pla: 0485: 
; lisp/s-math.pla: 0486:   memcpy(@ext, eval_ext(expr), t_extended)
	!BYTE	$58,$10,$02		; ENTER	16,2
; lisp/s-math.pla: 0487:   int = eval_int16(expr=>cdr)
; lisp/s-math.pla: 0488:   sane:saveZP()
; lisp/s-math.pla: 0489:   sane:restoreZP(sane:op2FP(FOSCALB, @ext, int))
; lisp/s-math.pla: 0490:   return new_float(@ext)
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F188 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F189 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C005
_F190 	!WORD	_C005		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_X057+18
_F191 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$18			; CB	24
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_X057+8
_F192 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F193 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X066
_F194 	!WORD	0		
	!BYTE	$5A,$10			; LEAVE	16
; lisp/s-math.pla: 0491: end
; lisp/s-math.pla: 0492: 
; lisp/s-math.pla: 0493: def natv_trunc(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C021 					; natv_trunc()
; lisp/s-math.pla: 0494:   return sane_op1(FOTTI, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$16			; CB	22
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C018
_F195 	!WORD	_C018		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0495: end
; lisp/s-math.pla: 0496: 
; lisp/s-math.pla: 0497: def natv_round(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C022 					; natv_round()
; lisp/s-math.pla: 0498:   return sane_op1(FORTI, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$14			; CB	20
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C018
_F196 	!WORD	_C018		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0499: end
; lisp/s-math.pla: 0500: 
; lisp/s-math.pla: 0501: def natv_sqrt(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C023 					; natv_sqrt()
; lisp/s-math.pla: 0502:   return sane_op1(FOSQRT, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$12			; CB	18
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C018
_F197 	!WORD	_C018		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0503: end
; lisp/s-math.pla: 0504: 
; lisp/s-math.pla: 0505: //
; lisp/s-math.pla: 0506: // ELEMS functions
; lisp/s-math.pla: 0507: //
; lisp/s-math.pla: 0508: 
; lisp/s-math.pla: 0509: def elem_op1(op1, expr)
					; op1 -> [0]
					; expr -> [2]
_C024 					; elem_op1()
; lisp/s-math.pla: 0510:   res[t_extended] ext
					; ext -> [4]
; lisp/s-math.pla: 0511: 
; lisp/s-math.pla: 0512:   memcpy(@ext, eval_ext(expr), t_extended)
	!BYTE	$58,$0E,$02		; ENTER	14,2
; lisp/s-math.pla: 0513:   sane:saveZP()
; lisp/s-math.pla: 0514:   sane:restoreZP(sane:op1ELEM(op1, @ext))
; lisp/s-math.pla: 0515:   return new_float(@ext)
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F198 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F199 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F200 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$6A			; LAW	_X057+12
_F201 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F202 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_X066
_F203 	!WORD	0		
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-math.pla: 0516: end
; lisp/s-math.pla: 0517: 
; lisp/s-math.pla: 0518: def elem_op2(op2, expr)
					; op2 -> [0]
					; expr -> [2]
_C025 					; elem_op2()
; lisp/s-math.pla: 0519:   res[t_extended] ext1, ext2
					; ext1 -> [4]
					; ext2 -> [14]
; lisp/s-math.pla: 0520: 
; lisp/s-math.pla: 0521:   memcpy(@ext1, eval_ext(expr),      t_extended)
	!BYTE	$58,$18,$02		; ENTER	24,2
; lisp/s-math.pla: 0522:   memcpy(@ext2, eval_ext(expr=>cdr), t_extended)
; lisp/s-math.pla: 0523:   sane:saveZP()
; lisp/s-math.pla: 0524:   sane:restoreZP(sane:op2ELEM(op2, @ext1, @ext2))
; lisp/s-math.pla: 0525:   return new_float(@ext1)
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F204 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F205 	!WORD	0		
	!BYTE	$28,$0E			; LLA	[14]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C003
_F206 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F207 	!WORD	0		
	!BYTE	$6A			; LAW	_X057+18
_F208 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$28,$0E			; LLA	[14]
	!BYTE	$6A			; LAW	_X057+14
_F209 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F210 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_X066
_F211 	!WORD	0		
	!BYTE	$5A,$18			; LEAVE	24
; lisp/s-math.pla: 0526: end
; lisp/s-math.pla: 0527: 
; lisp/s-math.pla: 0528: def natv_cos(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C026 					; natv_cos()
; lisp/s-math.pla: 0529:   return elem_op1(FOCOSX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F212 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0530: end
; lisp/s-math.pla: 0531: 
; lisp/s-math.pla: 0532: def natv_sin(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C027 					; natv_sin()
; lisp/s-math.pla: 0533:   return elem_op1(FOSINX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F213 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0534: end
; lisp/s-math.pla: 0535: 
; lisp/s-math.pla: 0536: def natv_tan(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C028 					; natv_tan()
; lisp/s-math.pla: 0537:   return elem_op1(FOTANX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$1E			; CB	30
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F214 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0538: end
; lisp/s-math.pla: 0539: 
; lisp/s-math.pla: 0540: def natv_atan(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C029 					; natv_atan()
; lisp/s-math.pla: 0541:   return elem_op1(FOATANX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$18			; CB	24
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F215 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0542: end
; lisp/s-math.pla: 0543: 
; lisp/s-math.pla: 0544: def natv_log2(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C030 					; natv_log2()
; lisp/s-math.pla: 0545:   return elem_op1(FOLOG2X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$04			; CN	2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F216 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0546: end
; lisp/s-math.pla: 0547: 
; lisp/s-math.pla: 0548: def natv_log21(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C031 					; natv_log21()
; lisp/s-math.pla: 0549:   return elem_op1(FOLOG21X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$0C			; CN	6
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F217 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0550: end
; lisp/s-math.pla: 0551: 
; lisp/s-math.pla: 0552: def natv_ln(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C032 					; natv_ln()
; lisp/s-math.pla: 0553:   return elem_op1(FOLNX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F218 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0554: end
; lisp/s-math.pla: 0555: 
; lisp/s-math.pla: 0556: def natv_ln1(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C033 					; natv_ln1()
; lisp/s-math.pla: 0557:   return elem_op1(FOLN1X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$08			; CN	4
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F219 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0558: end
; lisp/s-math.pla: 0559: 
; lisp/s-math.pla: 0560: def natv_pow2(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C034 					; natv_pow2()
; lisp/s-math.pla: 0561:   return elem_op1(FOEXP2X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$14			; CN	10
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F220 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0562: end
; lisp/s-math.pla: 0563: 
; lisp/s-math.pla: 0564: def natv_pow21(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C035 					; natv_pow21()
; lisp/s-math.pla: 0565:   return elem_op1(FOEXP21X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$1C			; CN	14
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F221 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0566: end
; lisp/s-math.pla: 0567: 
; lisp/s-math.pla: 0568: def natv_powE(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C036 					; natv_powE()
; lisp/s-math.pla: 0569:   return elem_op1(FOEXPX, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$10			; CN	8
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F222 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0570: end
; lisp/s-math.pla: 0571: 
; lisp/s-math.pla: 0572: def natv_powE1(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C037 					; natv_powE1()
; lisp/s-math.pla: 0573:   return elem_op1(FOEXP1X, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$18			; CN	12
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C024
_F223 	!WORD	_C024		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0574: end
; lisp/s-math.pla: 0575: 
; lisp/s-math.pla: 0576: def natv_powI(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C038 					; natv_powI()
; lisp/s-math.pla: 0577:   var int
					; int -> [4]
; lisp/s-math.pla: 0578:   res[t_extended] ext
					; ext -> [6]
; lisp/s-math.pla: 0579: 
; lisp/s-math.pla: 0580:   memcpy(@ext, eval_ext(expr), t_extended)
	!BYTE	$58,$10,$02		; ENTER	16,2
; lisp/s-math.pla: 0581:   int = eval_int16(expr=>cdr)
; lisp/s-math.pla: 0582:   sane:saveZP()
; lisp/s-math.pla: 0583:   sane:restoreZP(sane:op2ELEM(FOXPWRI, @ext, int))
; lisp/s-math.pla: 0584:   return new_float(@ext)
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C003
_F224 	!WORD	_C003		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F225 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C005
_F226 	!WORD	_C005		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_X057+18
_F227 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_X057+14
_F228 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F229 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X066
_F230 	!WORD	0		
	!BYTE	$5A,$10			; LEAVE	16
; lisp/s-math.pla: 0585: end
; lisp/s-math.pla: 0586: 
; lisp/s-math.pla: 0587: def natv_pow(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C039 					; natv_pow()
; lisp/s-math.pla: 0588:   return elem_op2(FOXPWRI, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$10			; CB	16
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C025
_F231 	!WORD	_C025		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0589: end
; lisp/s-math.pla: 0590: 
; lisp/s-math.pla: 0591: def natv_comp(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C040 					; natv_comp()
; lisp/s-math.pla: 0592:   return elem_op2(FOCOMPND, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$14			; CB	20
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C025
_F232 	!WORD	_C025		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0593: end
; lisp/s-math.pla: 0594: 
; lisp/s-math.pla: 0595: def natv_annuity(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C041 					; natv_annuity()
; lisp/s-math.pla: 0596:   return elem_op2(FOANNUIT, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$2A,$16			; CB	22
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C025
_F233 	!WORD	_C025		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0597: end
; lisp/s-math.pla: 0598: 
; lisp/s-math.pla: 0599: //
; lisp/s-math.pla: 0600: // Bit-wise operations
; lisp/s-math.pla: 0601: //
; lisp/s-math.pla: 0602: 
; lisp/s-math.pla: 0603: def natv_bitnot(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C042 					; natv_bitnot()
; lisp/s-math.pla: 0604:   symptr = eval_int(expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-math.pla: 0605:   return new_int(~symptr=>intval[0], ~symptr=>intval[1])
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F234 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$92			; COMP
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$92			; COMP
	!BYTE	$54			; CALL	_X065
_F235 	!WORD	0		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-math.pla: 0606: end
; lisp/s-math.pla: 0607: 
; lisp/s-math.pla: 0608: def natv_bitand(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C043 					; natv_bitand()
; lisp/s-math.pla: 0609:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0610: 
; lisp/s-math.pla: 0611:   symptr    = eval_int(expr)
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-math.pla: 0612:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0613:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0614:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0615:   return new_int(bitval[0] & symptr=>intval[0], bitval[1] & symptr=>intval[1])
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F236 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F237 	!WORD	_C004		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$94			; AND 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$94			; AND 
	!BYTE	$54			; CALL	_X065
_F238 	!WORD	0		
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-math.pla: 0616: end
; lisp/s-math.pla: 0617: 
; lisp/s-math.pla: 0618: def natv_bitor(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C044 					; natv_bitor()
; lisp/s-math.pla: 0619:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0620: 
; lisp/s-math.pla: 0621:   symptr    = eval_int(expr)
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-math.pla: 0622:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0623:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0624:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0625:   return new_int(bitval[0] | symptr=>intval[0], bitval[1] | symptr=>intval[1])
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F239 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F240 	!WORD	_C004		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$96			; OR 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$96			; OR 
	!BYTE	$54			; CALL	_X065
_F241 	!WORD	0		
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-math.pla: 0626: end
; lisp/s-math.pla: 0627: 
; lisp/s-math.pla: 0628: def natv_bitxor(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C045 					; natv_bitxor()
; lisp/s-math.pla: 0629:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0630: 
; lisp/s-math.pla: 0631:   symptr    = eval_int(expr)
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-math.pla: 0632:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0633:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0634:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0635:   return new_int(bitval[0] ^ symptr=>intval[0], bitval[1] ^ symptr=>intval[1])
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F242 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F243 	!WORD	_C004		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$98			; XOR
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$98			; XOR
	!BYTE	$54			; CALL	_X065
_F244 	!WORD	0		
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-math.pla: 0636: end
; lisp/s-math.pla: 0637: 
; lisp/s-math.pla: 0638: def natv_arithshift(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C046 					; natv_arithshift()
; lisp/s-math.pla: 0639:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0640:   var shift
					; shift -> [8]
; lisp/s-math.pla: 0641: 
; lisp/s-math.pla: 0642:   symptr    = eval_int(expr)
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-math.pla: 0643:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0644:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0645:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0646:   shift     = symptr=>intval[0]
; lisp/s-math.pla: 0647:   if shift < 0
; lisp/s-math.pla: 0648:     //
; lisp/s-math.pla: 0649:     // Shift right
; lisp/s-math.pla: 0650:     //
; lisp/s-math.pla: 0651:     if shift < -31
; lisp/s-math.pla: 0652:       bitval[1] = bitval[1] < 0 ?? $FFFF :: 0
; lisp/s-math.pla: 0653:       bitval[0] = bitval[1]
; lisp/s-math.pla: 0654:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F245 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F246 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B099
	!WORD	_B099-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$5E,$E1			; CFFB	-31
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B101
	!WORD	_B101-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B103
	!WORD	_B103-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$50			; BRNCH	_B104
	!WORD	_B104-*
_B103 
	!BYTE	$00			; CN	0
_B104 
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B102
	!WORD	_B102-*
_B101 
; lisp/s-math.pla: 0655:       while shift < 0
	!BYTE	$50			; BRNCH	_B107
	!WORD	_B107-*
_B105 
; lisp/s-math.pla: 0656:         bitval[0] = bitval[0] >> 1
; lisp/s-math.pla: 0657:         if bitval[1] & 1
; lisp/s-math.pla: 0658:           bitval[0] = bitval[0] | $8000
; lisp/s-math.pla: 0659:         else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B108
	!WORD	_B108-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$96			; OR 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B109
	!WORD	_B109-*
_B108 
; lisp/s-math.pla: 0660:           bitval[0] = bitval[0] & $7FFF
; lisp/s-math.pla: 0661:         fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$76,$04			; SLW	[4]
_B109 
; lisp/s-math.pla: 0662:         bitval[1] = bitval[1] >> 1
; lisp/s-math.pla: 0663:         shift++
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; lisp/s-math.pla: 0664:       loop
	!BYTE	$76,$08			; SLW	[8]
_B107 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B105
	!WORD	_B105-*
_B106 
; lisp/s-math.pla: 0665:     fin
_B102 
; lisp/s-math.pla: 0666:   else
	!BYTE	$50			; BRNCH	_B100
	!WORD	_B100-*
_B099 
; lisp/s-math.pla: 0667:     //
; lisp/s-math.pla: 0668:     // Shift left
; lisp/s-math.pla: 0669:     //
; lisp/s-math.pla: 0670:     if shift > 31
; lisp/s-math.pla: 0671:       bitval[0] = 0
; lisp/s-math.pla: 0672:       bitval[1] = 0
; lisp/s-math.pla: 0673:     else
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$2A,$1F			; CB	31
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B110
	!WORD	_B110-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B111
	!WORD	_B111-*
_B110 
; lisp/s-math.pla: 0674:       while shift > 0
	!BYTE	$50			; BRNCH	_B114
	!WORD	_B114-*
_B112 
; lisp/s-math.pla: 0675:         bitval[1] = bitval[1] << 1
; lisp/s-math.pla: 0676:         if bitval[0] & $8000
; lisp/s-math.pla: 0677:           bitval[1] = bitval[1] | 1
; lisp/s-math.pla: 0678:         fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B115
	!WORD	_B115-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$76,$06			; SLW	[6]
_B115 
_B116 
; lisp/s-math.pla: 0679:         bitval[0] = bitval[0] << 1
; lisp/s-math.pla: 0680:         shift--
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; lisp/s-math.pla: 0681:       loop
	!BYTE	$76,$08			; SLW	[8]
_B114 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B112
	!WORD	_B112-*
_B113 
; lisp/s-math.pla: 0682:     fin
_B111 
; lisp/s-math.pla: 0683:   fin
_B100 
; lisp/s-math.pla: 0684:   return new_int(bitval[0], bitval[1])
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X065
_F247 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0685: end
; lisp/s-math.pla: 0686: 
; lisp/s-math.pla: 0687: def natv_logicshift(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C047 					; natv_logicshift()
; lisp/s-math.pla: 0688:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0689:   var shift
					; shift -> [8]
; lisp/s-math.pla: 0690: 
; lisp/s-math.pla: 0691:   symptr    = eval_int(expr)
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-math.pla: 0692:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0693:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0694:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0695:   shift     = symptr=>intval[0]
; lisp/s-math.pla: 0696:   if shift < 0
; lisp/s-math.pla: 0697:     //
; lisp/s-math.pla: 0698:     // Shift right
; lisp/s-math.pla: 0699:     //
; lisp/s-math.pla: 0700:     if shift < -31
; lisp/s-math.pla: 0701:       bitval[1] = 0
; lisp/s-math.pla: 0702:       bitval[0] = 0
; lisp/s-math.pla: 0703:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F248 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F249 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$5E,$E1			; CFFB	-31
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B119
	!WORD	_B119-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
_B119 
; lisp/s-math.pla: 0704:       while shift < 0
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
_B121 
; lisp/s-math.pla: 0705:         bitval[0] = bitval[0] >> 1
; lisp/s-math.pla: 0706:         if bitval[1] & 1
; lisp/s-math.pla: 0707:           bitval[0] = bitval[0] | $8000
; lisp/s-math.pla: 0708:         else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B124
	!WORD	_B124-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$96			; OR 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B125
	!WORD	_B125-*
_B124 
; lisp/s-math.pla: 0709:           bitval[0] = bitval[0] & $7FFF
; lisp/s-math.pla: 0710:         fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$76,$04			; SLW	[4]
_B125 
; lisp/s-math.pla: 0711:         bitval[1] = (bitval[1] >> 1) & $7FFF
; lisp/s-math.pla: 0712:         shift++
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; lisp/s-math.pla: 0713:       loop
	!BYTE	$76,$08			; SLW	[8]
_B123 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B121
	!WORD	_B121-*
_B122 
; lisp/s-math.pla: 0714:     fin
_B120 
; lisp/s-math.pla: 0715:   else
	!BYTE	$50			; BRNCH	_B118
	!WORD	_B118-*
_B117 
; lisp/s-math.pla: 0716:     //
; lisp/s-math.pla: 0717:     // Shift left
; lisp/s-math.pla: 0718:     //
; lisp/s-math.pla: 0719:     if shift > 31
; lisp/s-math.pla: 0720:       bitval[0] = 0
; lisp/s-math.pla: 0721:       bitval[1] = 0
; lisp/s-math.pla: 0722:     else
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$2A,$1F			; CB	31
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B126
	!WORD	_B126-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B127
	!WORD	_B127-*
_B126 
; lisp/s-math.pla: 0723:       while shift > 0
	!BYTE	$50			; BRNCH	_B130
	!WORD	_B130-*
_B128 
; lisp/s-math.pla: 0724:         bitval[1] = bitval[1] << 1
; lisp/s-math.pla: 0725:         if bitval[0] & $8000
; lisp/s-math.pla: 0726:           bitval[1] = bitval[1] | 1
; lisp/s-math.pla: 0727:         fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B131
	!WORD	_B131-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$76,$06			; SLW	[6]
_B131 
_B132 
; lisp/s-math.pla: 0728:         bitval[0] = bitval[0] << 1
; lisp/s-math.pla: 0729:         shift--
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; lisp/s-math.pla: 0730:       loop
	!BYTE	$76,$08			; SLW	[8]
_B130 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B128
	!WORD	_B128-*
_B129 
; lisp/s-math.pla: 0731:     fin
_B127 
; lisp/s-math.pla: 0732:   fin
_B118 
; lisp/s-math.pla: 0733:   return new_int(bitval[0], bitval[1])
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X065
_F250 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-math.pla: 0734: end
; lisp/s-math.pla: 0735: 
; lisp/s-math.pla: 0736: def natv_rotate(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C048 					; natv_rotate()
; lisp/s-math.pla: 0737:   var[2] bitval
					; bitval -> [4]
; lisp/s-math.pla: 0738:   var rotate, wrap
					; rotate -> [8]
					; wrap -> [10]
; lisp/s-math.pla: 0739: 
; lisp/s-math.pla: 0740:   symptr    = eval_int(expr)
	!BYTE	$58,$0C,$02		; ENTER	12,2
; lisp/s-math.pla: 0741:   bitval[0] = symptr=>intval[0]
; lisp/s-math.pla: 0742:   bitval[1] = symptr=>intval[1]
; lisp/s-math.pla: 0743:   symptr    = eval_int(expr=>cdr)
; lisp/s-math.pla: 0744:   rotate    = symptr=>intval[0]
; lisp/s-math.pla: 0745:   if rotate < 0
; lisp/s-math.pla: 0746:     rotate = rotate | $FFFFFFE0
; lisp/s-math.pla: 0747:     while rotate < 0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C004
_F251 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C004
_F252 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B133
	!WORD	_B133-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$5E,$E0			; CFFB	-32
	!BYTE	$96			; OR 
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B137
	!WORD	_B137-*
_B135 
; lisp/s-math.pla: 0748:       wrap      = bitval[0] & 1 ?? $8000 :: 0
; lisp/s-math.pla: 0749:       bitval[0] = bitval[0] >> 1
; lisp/s-math.pla: 0750:       if bitval[1] & 1
; lisp/s-math.pla: 0751:         bitval[0] = bitval[0] | $8000
; lisp/s-math.pla: 0752:       else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B138
	!WORD	_B138-*
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$50			; BRNCH	_B139
	!WORD	_B139-*
_B138 
	!BYTE	$00			; CN	0
_B139 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B140
	!WORD	_B140-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$96			; OR 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
_B140 
; lisp/s-math.pla: 0753:         bitval[0] = bitval[0] & $7FFF
; lisp/s-math.pla: 0754:       fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$76,$04			; SLW	[4]
_B141 
; lisp/s-math.pla: 0755:       bitval[1] = wrap | (bitval[1] >> 1)
; lisp/s-math.pla: 0756:       rotate++
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$96			; OR 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; lisp/s-math.pla: 0757:     loop
	!BYTE	$76,$08			; SLW	[8]
_B137 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B135
	!WORD	_B135-*
_B136 
; lisp/s-math.pla: 0758:   else
	!BYTE	$50			; BRNCH	_B134
	!WORD	_B134-*
_B133 
; lisp/s-math.pla: 0759:     rotate = rotate & $0000001F
; lisp/s-math.pla: 0760:     while rotate > 0
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$3C,$1F			; ANDI	31
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B144
	!WORD	_B144-*
_B142 
; lisp/s-math.pla: 0761:       wrap      = bitval[1] & $8000 ?? 1 :: 0
; lisp/s-math.pla: 0762:       bitval[1] = bitval[1] << 1
; lisp/s-math.pla: 0763:       if bitval[0] & $8000
; lisp/s-math.pla: 0764:         bitval[1] = bitval[1] | 1
; lisp/s-math.pla: 0765:       fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B145
	!WORD	_B145-*
	!BYTE	$02			; CN	1
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
_B145 
	!BYTE	$00			; CN	0
_B146 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B147
	!WORD	_B147-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$76,$06			; SLW	[6]
_B147 
_B148 
; lisp/s-math.pla: 0766:       bitval[0] = wrap | (bitval[0] << 1)
; lisp/s-math.pla: 0767:       rotate--
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$96			; OR 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; lisp/s-math.pla: 0768:     loop
	!BYTE	$76,$08			; SLW	[8]
_B144 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B142
	!WORD	_B142-*
_B143 
; lisp/s-math.pla: 0769:   fin
_B134 
; lisp/s-math.pla: 0770:   return new_int(bitval[0], bitval[1])
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X065
_F253 	!WORD	0		
	!BYTE	$5A,$0C			; LEAVE	12
; lisp/s-math.pla: 0771: end
; lisp/s-math.pla: 0772: 
; lisp/s-math.pla: 0773: export def load_elem#0
_C049 					; load_elem()
; lisp/s-math.pla: 0774:   new_sym("COS")=>natv     = @natv_cos
	!BYTE	$26			; LA	_C026+0
_F254 	!WORD	_C026+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$43,$4F,$53
	!BYTE	$54			; CALL	_X064
_F255 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0775:   new_sym("SIN")=>natv     = @natv_sin
	!BYTE	$26			; LA	_C027+0
_F256 	!WORD	_C027+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$53,$49,$4E
	!BYTE	$54			; CALL	_X064
_F257 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0776:   new_sym("TAN")=>natv     = @natv_tan
	!BYTE	$26			; LA	_C028+0
_F258 	!WORD	_C028+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$54,$41,$4E
	!BYTE	$54			; CALL	_X064
_F259 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0777:   new_sym("ATAN")=>natv    = @natv_atan
	!BYTE	$26			; LA	_C029+0
_F260 	!WORD	_C029+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$41,$54,$41,$4E
	!BYTE	$54			; CALL	_X064
_F261 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0778:   new_sym("LOG2")=>natv    = @natv_log2
	!BYTE	$26			; LA	_C030+0
_F262 	!WORD	_C030+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4C,$4F,$47,$32
	!BYTE	$54			; CALL	_X064
_F263 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0779:   new_sym("LOG2_1")=>natv  = @natv_log21
	!BYTE	$26			; LA	_C031+0
_F264 	!WORD	_C031+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$4C,$4F,$47,$32,$5F,$31
	!BYTE	$54			; CALL	_X064
_F265 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0780:   new_sym("LN")=>natv      = @natv_ln
	!BYTE	$26			; LA	_C032+0
_F266 	!WORD	_C032+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$4C,$4E
	!BYTE	$54			; CALL	_X064
_F267 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0781:   new_sym("LN_1")=>natv    = @natv_ln1
	!BYTE	$26			; LA	_C033+0
_F268 	!WORD	_C033+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4C,$4E,$5F,$31
	!BYTE	$54			; CALL	_X064
_F269 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0782:   new_sym("POW2")=>natv    = @natv_pow2
	!BYTE	$26			; LA	_C034+0
_F270 	!WORD	_C034+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$50,$4F,$57,$32
	!BYTE	$54			; CALL	_X064
_F271 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0783:   new_sym("POW2_1")=>natv  = @natv_pow21
	!BYTE	$26			; LA	_C035+0
_F272 	!WORD	_C035+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$50,$4F,$57,$32,$5F,$31
	!BYTE	$54			; CALL	_X064
_F273 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0784:   new_sym("POWE")=>natv    = @natv_powE
	!BYTE	$26			; LA	_C036+0
_F274 	!WORD	_C036+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$50,$4F,$57,$45
	!BYTE	$54			; CALL	_X064
_F275 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0785:   new_sym("POWE_1")=>natv  = @natv_powE1
	!BYTE	$26			; LA	_C037+0
_F276 	!WORD	_C037+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$50,$4F,$57,$45,$5F,$31
	!BYTE	$54			; CALL	_X064
_F277 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0786:   new_sym("POW_I")=>natv   = @natv_powI
	!BYTE	$26			; LA	_C038+0
_F278 	!WORD	_C038+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$50,$4F,$57,$5F,$49
	!BYTE	$54			; CALL	_X064
_F279 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0787:   new_sym("POWY")=>natv    = @natv_pow
	!BYTE	$26			; LA	_C039+0
_F280 	!WORD	_C039+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$50,$4F,$57,$59
	!BYTE	$54			; CALL	_X064
_F281 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0788:   new_sym("COMP")=>natv    = @natv_comp
	!BYTE	$26			; LA	_C040+0
_F282 	!WORD	_C040+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$4F,$4D,$50
	!BYTE	$54			; CALL	_X064
_F283 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0789:   new_sym("ANNUITY")=>natv = @natv_annuity
	!BYTE	$26			; LA	_C041+0
_F284 	!WORD	_C041+0		
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$41,$4E,$4E,$55,$49,$54,$59
	!BYTE	$54			; CALL	_X064
_F285 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0790:   sane:saveZP() // Force load of ELEM library
; lisp/s-math.pla: 0791:   sane:restoreZP(sane:op1ELEM(FOSINX, @ext_pi))
; lisp/s-math.pla: 0792: end
	!BYTE	$6A			; LAW	_X057+18
_F286 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$26			; LA	_D071+0
_F287 	!WORD	_D071+0		
	!BYTE	$6A			; LAW	_X057+12
_F288 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X057+20
_F289 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5C			; RET
; lisp/s-math.pla: 0793: 
; lisp/s-math.pla: 0794: //
; lisp/s-math.pla: 0795: // Install numerical constants and functions
; lisp/s-math.pla: 0796: //
; lisp/s-math.pla: 0797: 
; lisp/s-math.pla: 0798: sane:initFP()
_INIT 
; lisp/s-math.pla: 0799: new_sym("*PI*")=>apval      = new_float(@ext_pi) ^ NULL_HACK
	!BYTE	$6A			; LAW	_X057+0
_F290 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D071+0
_F291 	!WORD	_D071+0		
	!BYTE	$54			; CALL	_X066
_F292 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$2A,$50,$49,$2A
	!BYTE	$54			; CALL	_X064
_F293 	!WORD	0		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
; lisp/s-math.pla: 0800: new_sym("*E*")=>apval       = new_float(@ext_e)  ^ NULL_HACK
	!BYTE	$26			; LA	_D072+0
_F294 	!WORD	_D072+0		
	!BYTE	$54			; CALL	_X066
_F295 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$2A,$45,$2A
	!BYTE	$54			; CALL	_X064
_F296 	!WORD	0		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
; lisp/s-math.pla: 0801: new_sym("INTEGER")=>natv    = @natv_integer
	!BYTE	$26			; LA	_C006+0
_F297 	!WORD	_C006+0		
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$49,$4E,$54,$45,$47,$45,$52
	!BYTE	$54			; CALL	_X064
_F298 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0802: new_sym("SUM")=>natv        = @natv_sum
	!BYTE	$26			; LA	_C007+0
_F299 	!WORD	_C007+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$53,$55,$4D
	!BYTE	$54			; CALL	_X064
_F300 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0803: new_sym("+")=>natv          = @natv_sum
	!BYTE	$26			; LA	_C007+0
_F301 	!WORD	_C007+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$2B
	!BYTE	$54			; CALL	_X064
_F302 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0804: new_sym("-")=>natv          = @natv_sub
	!BYTE	$26			; LA	_C008+0
_F303 	!WORD	_C008+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$2D
	!BYTE	$54			; CALL	_X064
_F304 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0805: new_sym("*")=>natv          = @natv_mul
	!BYTE	$26			; LA	_C009+0
_F305 	!WORD	_C009+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$2A
	!BYTE	$54			; CALL	_X064
_F306 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0806: new_sym("/")=>natv          = @natv_div
	!BYTE	$26			; LA	_C010+0
_F307 	!WORD	_C010+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$2F
	!BYTE	$54			; CALL	_X064
_F308 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0807: new_sym("REM")=>natv        = @natv_rem
	!BYTE	$26			; LA	_C011+0
_F309 	!WORD	_C011+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$52,$45,$4D
	!BYTE	$54			; CALL	_X064
_F310 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0808: new_sym("NEG")=>natv        = @natv_neg
	!BYTE	$26			; LA	_C012+0
_F311 	!WORD	_C012+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4E,$45,$47
	!BYTE	$54			; CALL	_X064
_F312 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0809: new_sym("ABS")=>natv        = @natv_abs
	!BYTE	$26			; LA	_C013+0
_F313 	!WORD	_C013+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$41,$42,$53
	!BYTE	$54			; CALL	_X064
_F314 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0810: new_sym(">")=>natv          = @natv_gt
	!BYTE	$26			; LA	_C014+0
_F315 	!WORD	_C014+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$3E
	!BYTE	$54			; CALL	_X064
_F316 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0811: new_sym("<")=>natv          = @natv_lt
	!BYTE	$26			; LA	_C015+0
_F317 	!WORD	_C015+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$3C
	!BYTE	$54			; CALL	_X064
_F318 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0812: new_sym("MIN")=>natv        = @natv_min
	!BYTE	$26			; LA	_C016+0
_F319 	!WORD	_C016+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4D,$49,$4E
	!BYTE	$54			; CALL	_X064
_F320 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0813: new_sym("MAX")=>natv        = @natv_max
	!BYTE	$26			; LA	_C017+0
_F321 	!WORD	_C017+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4D,$41,$58
	!BYTE	$54			; CALL	_X064
_F322 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0814: new_sym("LOGB")=>natv       = @natv_logb
	!BYTE	$26			; LA	_C019+0
_F323 	!WORD	_C019+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4C,$4F,$47,$42
	!BYTE	$54			; CALL	_X064
_F324 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0815: new_sym("SCALEB")=>natv     = @natv_scalebI
	!BYTE	$26			; LA	_C020+0
_F325 	!WORD	_C020+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$53,$43,$41,$4C,$45,$42
	!BYTE	$54			; CALL	_X064
_F326 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0816: new_sym("TRUNCATE")=>natv   = @natv_trunc
	!BYTE	$26			; LA	_C021+0
_F327 	!WORD	_C021+0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$54,$52,$55,$4E,$43,$41,$54,$45
	!BYTE	$54			; CALL	_X064
_F328 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0817: new_sym("ROUND")=>natv      = @natv_round
	!BYTE	$26			; LA	_C022+0
_F329 	!WORD	_C022+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$52,$4F,$55,$4E,$44
	!BYTE	$54			; CALL	_X064
_F330 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0818: new_sym("SQRT")=>natv       = @natv_sqrt
	!BYTE	$26			; LA	_C023+0
_F331 	!WORD	_C023+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$53,$51,$52,$54
	!BYTE	$54			; CALL	_X064
_F332 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0819: new_sym("BITNOT")=>natv     = @natv_bitnot
	!BYTE	$26			; LA	_C042+0
_F333 	!WORD	_C042+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$42,$49,$54,$4E,$4F,$54
	!BYTE	$54			; CALL	_X064
_F334 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0820: new_sym("BITAND")=>natv     = @natv_bitand
	!BYTE	$26			; LA	_C043+0
_F335 	!WORD	_C043+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$42,$49,$54,$41,$4E,$44
	!BYTE	$54			; CALL	_X064
_F336 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0821: new_sym("BITOR")=>natv      = @natv_bitor
	!BYTE	$26			; LA	_C044+0
_F337 	!WORD	_C044+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$42,$49,$54,$4F,$52
	!BYTE	$54			; CALL	_X064
_F338 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0822: new_sym("BITXOR")=>natv     = @natv_bitxor
	!BYTE	$26			; LA	_C045+0
_F339 	!WORD	_C045+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$42,$49,$54,$58,$4F,$52
	!BYTE	$54			; CALL	_X064
_F340 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0823: new_sym("ARITHSHIFT")=>natv = @natv_arithshift
	!BYTE	$26			; LA	_C046+0
_F341 	!WORD	_C046+0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$41,$52,$49,$54,$48,$53,$48,$49
	!BYTE	$46,$54
	!BYTE	$54			; CALL	_X064
_F342 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0824: new_sym("LOGICSHIFT")=>natv = @natv_logicshift
	!BYTE	$26			; LA	_C047+0
_F343 	!WORD	_C047+0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$4C,$4F,$47,$49,$43,$53,$48,$49
	!BYTE	$46,$54
	!BYTE	$54			; CALL	_X064
_F344 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0825: new_sym("ROTATE")=>natv     = @natv_rotate
	!BYTE	$26			; LA	_C048+0
_F345 	!WORD	_C048+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$52,$4F,$54,$41,$54,$45
	!BYTE	$54			; CALL	_X064
_F346 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0826: new_sym("~")=>natv          = @natv_bitnot
	!BYTE	$26			; LA	_C042+0
_F347 	!WORD	_C042+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$7E
	!BYTE	$54			; CALL	_X064
_F348 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0827: new_sym("&")=>natv          = @natv_bitand
	!BYTE	$26			; LA	_C043+0
_F349 	!WORD	_C043+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$26
	!BYTE	$54			; CALL	_X064
_F350 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0828: new_sym("|")=>natv          = @natv_bitor
	!BYTE	$26			; LA	_C044+0
_F351 	!WORD	_C044+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$7C
	!BYTE	$54			; CALL	_X064
_F352 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0829: new_sym("^")=>natv          = @natv_bitxor
	!BYTE	$26			; LA	_C045+0
_F353 	!WORD	_C045+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$5E
	!BYTE	$54			; CALL	_X064
_F354 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0830: new_sym("<<-")=>natv        = @natv_arithshift
	!BYTE	$26			; LA	_C046+0
_F355 	!WORD	_C046+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$3C,$3C,$2D
	!BYTE	$54			; CALL	_X064
_F356 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0831: new_sym("<<")=>natv         = @natv_logicshift
	!BYTE	$26			; LA	_C047+0
_F357 	!WORD	_C047+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$3C,$3C
	!BYTE	$54			; CALL	_X064
_F358 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0832: new_sym("<<<")=>natv        = @natv_rotate
	!BYTE	$26			; LA	_C048+0
_F359 	!WORD	_C048+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$3C,$3C,$3C
	!BYTE	$54			; CALL	_X064
_F360 	!WORD	0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-math.pla: 0833: return modkeep | modinitkeep
	!BYTE	$2C,$00,$60		; CW	24576
	!BYTE	$5C			; RET
; lisp/s-math.pla: 0834: done
_SYSFLAGS	=	0
_DEFCNT	=	51
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	68			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	63			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	60			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	37			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	41			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	43			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	43			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	51			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	69			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	69			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	53			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	69			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	69			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	51			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	53			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	65			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	57			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: NEG32
	!BYTE	$CE,$C5,$C7,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: LOAD32
	!BYTE	$CC,$CF,$C1,$C4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	; DCI STRING: STORE32
	!BYTE	$D3,$D4,$CF,$D2,$C5,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	34			; ESD INDEX
	; DCI STRING: ADD32
	!BYTE	$C1,$C4,$C4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	35			; ESD INDEX
	; DCI STRING: SUB32
	!BYTE	$D3,$D5,$C2,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	37			; ESD INDEX
	; DCI STRING: MUL32
	!BYTE	$CD,$D5,$CC,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	41			; ESD INDEX
	; DCI STRING: DIV32
	!BYTE	$C4,$C9,$D6,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	43			; ESD INDEX
	; DCI STRING: ISGT32
	!BYTE	$C9,$D3,$C7,$D4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	51			; ESD INDEX
	; DCI STRING: ISLT32
	!BYTE	$C9,$D3,$CC,$D4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	53			; ESD INDEX
	; DCI STRING: SANE
	!BYTE	$D3,$C1,$CE,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	57			; ESD INDEX
	; DCI STRING: THROW
	!BYTE	$D4,$C8,$D2,$CF,$57
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	60			; ESD INDEX
	; DCI STRING: EXCEPTION
	!BYTE	$C5,$D8,$C3,$C5,$D0,$D4,$C9,$CF,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	62			; ESD INDEX
	; DCI STRING: ERR_EXPR
	!BYTE	$C5,$D2,$D2,$DF,$C5,$D8,$D0,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	63			; ESD INDEX
	; DCI STRING: NEW_SYM
	!BYTE	$CE,$C5,$D7,$DF,$D3,$D9,$4D
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	64			; ESD INDEX
	; DCI STRING: NEW_INT
	!BYTE	$CE,$C5,$D7,$DF,$C9,$CE,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	65			; ESD INDEX
	; DCI STRING: NEW_FLOAT
	!BYTE	$CE,$C5,$D7,$DF,$C6,$CC,$CF,$C1,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	66			; ESD INDEX
	; DCI STRING: EVAL_EXPR
	!BYTE	$C5,$D6,$C1,$CC,$DF,$C5,$D8,$D0,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	68			; ESD INDEX
	; DCI STRING: BOOL_PRED
	!BYTE	$C2,$CF,$CF,$CC,$DF,$D0,$D2,$C5,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	69			; ESD INDEX
	; DCI STRING: EVAL_INT
	!BYTE	$C5,$D6,$C1,$CC,$DF,$C9,$CE,$54
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C004		
	; DCI STRING: EVAL_INT16
	!BYTE	$C5,$D6,$C1,$CC,$DF,$C9,$CE,$D4,$B1,$36
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C005		
	; DCI STRING: LOAD_ELEM
	!BYTE	$CC,$CF,$C1,$C4,$DF,$C5,$CC,$C5,$4D
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C049		
	!BYTE	$00			; END OF ESD
