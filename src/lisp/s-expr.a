; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; lisp/s-expr.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; lisp/s-expr.pla: 0001: 
; lisp/s-expr.pla: 0002: include "inc/int32.plh"
; inc/int32.plh: 0001: import int32
	; DCI STRING: INT32
	!BYTE	$C9,$CE,$D4,$B3,$32
					; INT32 -> X028
; inc/int32.plh: 0002:     const t_i32 = 4
					; t_i32 = 4
; inc/int32.plh: 0003:     
; inc/int32.plh: 0004:     predef zero32#0
					; ZERO32 -> X029
; inc/int32.plh: 0005:     predef zext16to32#0
					; ZEXT16TO32 -> X030
; inc/int32.plh: 0006:     predef neg32#0
					; NEG32 -> X031
; inc/int32.plh: 0007:     predef load32(i32ptr)#0
					; LOAD32 -> X032
; inc/int32.plh: 0008:     predef loadi16(imm16)#0
					; LOADI16 -> X033
; inc/int32.plh: 0009:     predef store32(i32ptr)#0
					; STORE32 -> X034
; inc/int32.plh: 0010:     predef add32(i32ptr)#0
					; ADD32 -> X035
; inc/int32.plh: 0011:     predef addi16(imm16)#0
					; ADDI16 -> X036
; inc/int32.plh: 0012:     predef sub32(i32ptr)#0
					; SUB32 -> X037
; inc/int32.plh: 0013:     predef subi16(imm16)#0
					; SUBI16 -> X038
; inc/int32.plh: 0014:     predef shl32(imm8)#0
					; SHL32 -> X039
; inc/int32.plh: 0015:     predef shr32(imm8)#0
					; SHR32 -> X040
; inc/int32.plh: 0016:     predef mul32(i32ptr)#0
					; MUL32 -> X041
; inc/int32.plh: 0017:     predef muli16(imm16)#0
					; MULI16 -> X042
; inc/int32.plh: 0018:     predef div32(i32ptr)#2
					; DIV32 -> X043
; inc/int32.plh: 0019:     predef divi16(imm16)#2
					; DIVI16 -> X044
; inc/int32.plh: 0020:     predef iseq32(i32ptr)#1
					; ISEQ32 -> X045
; inc/int32.plh: 0021:     predef iseqi16(imm16)#1
					; ISEQI16 -> X046
; inc/int32.plh: 0022:     predef isge32(i32ptr)#1
					; ISGE32 -> X047
; inc/int32.plh: 0023:     predef isgei16(imm16)#1
					; ISGEI16 -> X048
; inc/int32.plh: 0024:     predef isle32(i32ptr)#1
					; ISLE32 -> X049
; inc/int32.plh: 0025:     predef islei16(imm16)#1
					; ISLEI16 -> X050
; inc/int32.plh: 0026:     predef isgt32(i32ptr)#1
					; ISGT32 -> X051
; inc/int32.plh: 0027:     predef isgti16(imm16)#1
					; ISGTI16 -> X052
; inc/int32.plh: 0028:     predef islt32(i32ptr)#1
					; ISLT32 -> X053
; inc/int32.plh: 0029:     predef islti16(imm16)#1
					; ISLTI16 -> X054
; inc/int32.plh: 0030:     predef i32tos(i32ptr, strptr)#1
					; I32TOS -> X055
; inc/int32.plh: 0031:     predef puti32(i32ptr)#0
					; PUTI32 -> X056
; inc/int32.plh: 0032: end
; lisp/s-expr.pla: 0002: 
; lisp/s-expr.pla: 0003: include "inc/fpstr.plh"
; inc/fpstr.plh: 0001: import fpstr
	; DCI STRING: FPSTR
	!BYTE	$C6,$D0,$D3,$D4,$52
					; FPSTR -> X057
; inc/fpstr.plh: 0002: //
; inc/fpstr.plh: 0003: // String formatting bits
; inc/fpstr.plh: 0004: //
; inc/fpstr.plh: 0005: const FPSTR_FIXED = 1 // Fixed count of fractional digits
					; FPSTR_FIXED = 1
; inc/fpstr.plh: 0006: const FPSTR_FLOAT = 0 // Floating count of fractional digits
					; FPSTR_FLOAT = 0
; inc/fpstr.plh: 0007: const FPSTR_STRIP = 2 // Strip trailing fractional zeros
					; FPSTR_STRIP = 2
; inc/fpstr.plh: 0008: const FPSTR_EXP   = 4 // Force exponential format
					; FPSTR_EXP = 4
; inc/fpstr.plh: 0009: const FPSTR_FLEX  = 8 // Flexible switch to EXP format if over/underflow
					; FPSTR_FLEX = 8
; inc/fpstr.plh: 0010: //
; inc/fpstr.plh: 0011: // Parse string into decrecord, return SANE conversion output
; inc/fpstr.plh: 0012: //
; inc/fpstr.plh: 0013: predef str2ext(str, ext)#1
					; STR2EXT -> X058
; inc/fpstr.plh: 0014: //
; inc/fpstr.plh: 0015: // Convert extended FP to string using , return string
; inc/fpstr.plh: 0016: //
; inc/fpstr.plh: 0017: predef ext2str(ext, str, intdigits, fracdigits, format)#1
					; EXT2STR -> X059
; inc/fpstr.plh: 0018: end
; lisp/s-expr.pla: 0003: 
; lisp/s-expr.pla: 0004: include "inc/longjmp.plh"
; inc/longjmp.plh: 0001: import longjmp
	; DCI STRING: LONGJMP
	!BYTE	$CC,$CF,$CE,$C7,$CA,$CD,$50
					; LONGJMP -> X060
; inc/longjmp.plh: 0002:     const t_except = $0160
					; t_except = 352
; inc/longjmp.plh: 0003:     predef except(env), throw(env, retval)
					; EXCEPT -> X061
					; THROW -> X062
; inc/longjmp.plh: 0004: end
; lisp/s-expr.pla: 0004: 
; lisp/s-expr.pla: 0005: 
; lisp/s-expr.pla: 0006: const TYPE_MASK   = $70
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; TYPE_MASK = 112
; lisp/s-expr.pla: 0007: const NIL         = $00
					; NIL = 0
; lisp/s-expr.pla: 0008: const CONS_TYPE   = $10
					; CONS_TYPE = 16
; lisp/s-expr.pla: 0009: const SYM_TYPE    = $20
					; SYM_TYPE = 32
; lisp/s-expr.pla: 0010: const SYM_LEN     = $0F
					; SYM_LEN = 15
; lisp/s-expr.pla: 0011: const NUM_TYPE    = $30
					; NUM_TYPE = 48
; lisp/s-expr.pla: 0012: const NUM_INT     = $31
					; NUM_INT = 49
; lisp/s-expr.pla: 0013: const NUM_FLOAT   = $32
					; NUM_FLOAT = 50
; lisp/s-expr.pla: 0014: const ARRAY_TYPE  = $40
					; ARRAY_TYPE = 64
; lisp/s-expr.pla: 0015: const STRING_TYPE = $50
					; STRING_TYPE = 80
; lisp/s-expr.pla: 0016: const MARK_BIT    = $80
					; MARK_BIT = 128
; lisp/s-expr.pla: 0017: const MARK_MASK   = $7F
					; MARK_MASK = 127
; lisp/s-expr.pla: 0018: const NULL_HACK   = 1  // Hack so we can set APVALs to NULL
					; NULL_HACK = 1
; lisp/s-expr.pla: 0019: 
; lisp/s-expr.pla: 0020: struc t_elem
; lisp/s-expr.pla: 0021:   word link
					; link = 0
; lisp/s-expr.pla: 0022:   byte type
					; type = 2
; lisp/s-expr.pla: 0023: end
					; t_elem = 3
; lisp/s-expr.pla: 0024: struc t_cons
; lisp/s-expr.pla: 0025:   res[t_elem]
; lisp/s-expr.pla: 0026:   word car
					; car = 3
; lisp/s-expr.pla: 0027:   word cdr
					; cdr = 5
; lisp/s-expr.pla: 0028: end
					; t_cons = 7
; lisp/s-expr.pla: 0029: struc t_sym
; lisp/s-expr.pla: 0030:   res[t_elem]
; lisp/s-expr.pla: 0031:   word natv
					; natv = 3
; lisp/s-expr.pla: 0032:   word lambda
					; lambda = 5
; lisp/s-expr.pla: 0033:   word array
					; array = 7
; lisp/s-expr.pla: 0034:   word apval
					; apval = 9
; lisp/s-expr.pla: 0035:   char name[0]
					; name = 11
; lisp/s-expr.pla: 0036: end
					; t_sym = 11
; lisp/s-expr.pla: 0037: struc t_numint
; lisp/s-expr.pla: 0038:   res[t_elem]
; lisp/s-expr.pla: 0039:   word intval[2]
					; intval = 3
; lisp/s-expr.pla: 0040: end
					; t_numint = 7
; lisp/s-expr.pla: 0041: struc t_numfloat
; lisp/s-expr.pla: 0042:   res[t_elem]
; lisp/s-expr.pla: 0043:   res floatval[10]
					; floatval = 3
; lisp/s-expr.pla: 0044: end
					; t_numfloat = 13
; lisp/s-expr.pla: 0045: struc t_array
; lisp/s-expr.pla: 0046:   res[t_elem]
; lisp/s-expr.pla: 0047:   word dimension[4]
					; dimension = 3
; lisp/s-expr.pla: 0048:   word offset[4]
					; offset = 11
; lisp/s-expr.pla: 0049:   word arraysize
					; arraysize = 19
; lisp/s-expr.pla: 0050:   word arraymem
					; arraymem = 21
; lisp/s-expr.pla: 0051: end
					; t_array = 23
; lisp/s-expr.pla: 0052: struc t_string
; lisp/s-expr.pla: 0053:   res[t_elem]
; lisp/s-expr.pla: 0054:   byte stringstr[1]
					; stringstr = 3
; lisp/s-expr.pla: 0055: end
					; t_string = 4
; lisp/s-expr.pla: 0056: 
; lisp/s-expr.pla: 0057: //
; lisp/s-expr.pla: 0058: // Errors
; lisp/s-expr.pla: 0059: //
; lisp/s-expr.pla: 0060: 
; lisp/s-expr.pla: 0061: const ERR_INTERNAL     = -1
					; ERR_INTERNAL = -1
; lisp/s-expr.pla: 0062: const ERR_OUT_OF_MEM   = -2
					; ERR_OUT_OF_MEM = -2
; lisp/s-expr.pla: 0063: const ERR_SWEEP_OVRFLW = -3
					; ERR_SWEEP_OVRFLW = -3
; lisp/s-expr.pla: 0064: const ERR_SWEEP_UNDFLW = -4
					; ERR_SWEEP_UNDFLW = -4
; lisp/s-expr.pla: 0065: const ERR_BAD_DOT      = -5
					; ERR_BAD_DOT = -5
; lisp/s-expr.pla: 0066: const ERR_NOT_SYM      = -6
					; ERR_NOT_SYM = -6
; lisp/s-expr.pla: 0067: const ERR_NOT_ASSOC    = -7
					; ERR_NOT_ASSOC = -7
; lisp/s-expr.pla: 0068: const ERR_NOT_FUN      = -8
					; ERR_NOT_FUN = -8
; lisp/s-expr.pla: 0069: const ERR_NOT_NUM      = -9
					; ERR_NOT_NUM = -9
; lisp/s-expr.pla: 0070: const ERR_NOT_INT      = -10
					; ERR_NOT_INT = -10
; lisp/s-expr.pla: 0071: const ERR_NOT_FLOAT    = -11
					; ERR_NOT_FLOAT = -11
; lisp/s-expr.pla: 0072: const ERR_NOT_STR      = -12
					; ERR_NOT_STR = -12
; lisp/s-expr.pla: 0073: const ERR_BAD_INDEX    = -13
					; ERR_BAD_INDEX = -13
; lisp/s-expr.pla: 0074: const ERR_BAD_GO       = -14
					; ERR_BAD_GO = -14
; lisp/s-expr.pla: 0075: 
; lisp/s-expr.pla: 0076: //
; lisp/s-expr.pla: 0077: // Temp string size
; lisp/s-expr.pla: 0078: //
; lisp/s-expr.pla: 0079: 
; lisp/s-expr.pla: 0080: const TMPSTR_SIZE      = 128
					; TMPSTR_SIZE = 128
; lisp/s-expr.pla: 0081: 
; lisp/s-expr.pla: 0082: //
; lisp/s-expr.pla: 0083: // Variables
; lisp/s-expr.pla: 0084: //
; lisp/s-expr.pla: 0085: 
; lisp/s-expr.pla: 0086: byte prhex             = FALSE // Hex output flag for integers
_D063 					; prhex             = FALSE // Hex output flag for integers
	!BYTE	$00
; lisp/s-expr.pla: 0087: const fmt_fp           = FPSTR_FIXED|FPSTR_STRIP|FPSTR_FLEX
					; fmt_fp = 11
; lisp/s-expr.pla: 0088: export var fmt_fpint   = 6
_D064 					; fmt_fpint   = 6
	!WORD	$0006
; lisp/s-expr.pla: 0089: export var fmt_fpfrac  = 4
_D065 					; fmt_fpfrac  = 4
	!WORD	$0004
; lisp/s-expr.pla: 0090: export byte trace      = FALSE
_D066 					; trace      = FALSE
	!BYTE	$00
; lisp/s-expr.pla: 0091: export var exception   = NULL
_D067 					; exception   = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0092: export var err_expr    = NULL
_D068 					; err_expr    = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0093: export var hook_eval   = NULL // Installable hook for eval_expr()
_D069 					; hook_eval   = NULL // Installable hook for eval_expr()
	!WORD	$0000
; lisp/s-expr.pla: 0094: var assoc_list  = NULL // SYM->value association list
_D070 					; assoc_list  = NULL // SYM->value association list
	!WORD	$0000
; lisp/s-expr.pla: 0095: var cons_list          = NULL
_D071 					; cons_list          = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0096: var cons_free          = NULL
_D072 					; cons_free          = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0097: var int_list           = NULL
_D073 					; int_list           = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0098: var int_free           = NULL
_D074 					; int_free           = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0099: var float_list         = NULL
_D075 					; float_list         = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0100: var float_free         = NULL
_D076 					; float_free         = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0101: var string_list        = NULL
_D077 					; string_list        = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0102: var string_free        = NULL
_D078 					; string_free        = NULL
	!WORD	$0000
; lisp/s-expr.pla: 0103: 
; lisp/s-expr.pla: 0104: //
; lisp/s-expr.pla: 0105: // Symbol hash table
; lisp/s-expr.pla: 0106: //
; lisp/s-expr.pla: 0107: 
; lisp/s-expr.pla: 0108: const HASH_SIZE = 64 // Must be power of two!
					; HASH_SIZE = 64
; lisp/s-expr.pla: 0109: const HASH_MASK = HASH_SIZE-1
					; HASH_MASK = 63
; lisp/s-expr.pla: 0110: word hashtbl[HASH_SIZE]
_D079 	!FILL	128			; hashtbl[HASH_SIZE]
; lisp/s-expr.pla: 0111: 
; lisp/s-expr.pla: 0112: var sym_nil, sym_true, sym_quote, sym_lambda, sym_funarg, sym_set
_D080 	!FILL	2			; sym_nil, sym_true, sym_quote, sym_lambda, sym_funarg, sym_set
_D081 	!FILL	2			; sym_true, sym_quote, sym_lambda, sym_funarg, sym_set
_D082 	!FILL	2			; sym_quote, sym_lambda, sym_funarg, sym_set
_D083 	!FILL	2			; sym_lambda, sym_funarg, sym_set
_D084 	!FILL	2			; sym_funarg, sym_set
_D085 	!FILL	2			; sym_set
; lisp/s-expr.pla: 0113: var sym_macro, sym_cond, sym_if, sym_label, sym_for
_D086 	!FILL	2			; sym_macro, sym_cond, sym_if, sym_label, sym_for
_D087 	!FILL	2			; sym_cond, sym_if, sym_label, sym_for
_D088 	!FILL	2			; sym_if, sym_label, sym_for
_D089 	!FILL	2			; sym_label, sym_for
_D090 	!FILL	2			; sym_for
; lisp/s-expr.pla: 0114: var prog, prog_expr, prog_return // Current PROG expressions
_D091 	!FILL	2			; prog, prog_expr, prog_return // Current PROG expressions
_D092 	!FILL	2			; prog_expr, prog_return // Current PROG expressions
_D093 	!FILL	2			; prog_return // Current PROG expressions
; lisp/s-expr.pla: 0115: 
; lisp/s-expr.pla: 0116: predef print_expr(expr)#0
; lisp/s-expr.pla: 0117: predef eval_expr(expr)#1
; lisp/s-expr.pla: 0118: 
; lisp/s-expr.pla: 0119: //
; lisp/s-expr.pla: 0120: // Garbage collector
; lisp/s-expr.pla: 0121: // - note, anytime eval_expr is called there is the possibility of
; lisp/s-expr.pla: 0122: //   garbage collecting. If there are any in-flight elements (cons,
; lisp/s-expr.pla: 0123: //   int, float) they may be collected and returned to the free list.
; lisp/s-expr.pla: 0124: //   Use the sweep_stack to temporarily keep a reference to these elements.
; lisp/s-expr.pla: 0125: //
; lisp/s-expr.pla: 0126: 
; lisp/s-expr.pla: 0127: const SWEEPSTACK_MAX  = 16
					; SWEEPSTACK_MAX = 16
; lisp/s-expr.pla: 0128: byte  sweep_stack_top = 0
_D096 					; sweep_stack_top = 0
	!BYTE	$00
; lisp/s-expr.pla: 0129: var   sweep_stack[SWEEPSTACK_MAX] // In-flight expressions
_D097 	!FILL	32			; sweep_stack[SWEEPSTACK_MAX] // In-flight expressions
; lisp/s-expr.pla: 0130: 
; lisp/s-expr.pla: 0131: const GC_SHIFT_AVAIL = 6
					; GC_SHIFT_AVAIL = 6
; lisp/s-expr.pla: 0132: word gc_trigger, gc_pull // GC tigger points
_D098 	!FILL	2			; gc_trigger, gc_pull // GC tigger points
_D099 	!FILL	2			; gc_pull // GC tigger points
; lisp/s-expr.pla: 0133: 
; lisp/s-expr.pla: 0134: //def hashstr(str)#1
; lisp/s-expr.pla: 0135: //  return (^str ^ ((^(str+1) << 1) ^ ^(str + ^str/2) << 2)) & HASH_MASK
; lisp/s-expr.pla: 0136: //end
; lisp/s-expr.pla: 0137: asm hashstr(str)#1
_A000 					; hashstr()
; lisp/s-expr.pla: 0138:         !SOURCE "vmsrc/plvmzp.inc"
        !SOURCE "vmsrc/plvmzp.inc"
; lisp/s-expr.pla: 0139:         LDA     ESTKL,X
        LDA     ESTKL,X
; lisp/s-expr.pla: 0140:         STA     SRCL
        STA     SRCL
; lisp/s-expr.pla: 0141:         LDA     ESTKH,X
        LDA     ESTKH,X
; lisp/s-expr.pla: 0142:         STA     SRCH
        STA     SRCH
; lisp/s-expr.pla: 0143:         LDY     #$00
        LDY     #$00
; lisp/s-expr.pla: 0144:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0145:         STA     ESTKL,X
        STA     ESTKL,X
; lisp/s-expr.pla: 0146:         STY     ESTKH,X
        STY     ESTKH,X
; lisp/s-expr.pla: 0147:         LSR
        LSR
; lisp/s-expr.pla: 0148:         TAY
        TAY
; lisp/s-expr.pla: 0149:         INY
        INY
; lisp/s-expr.pla: 0150:         LDA     (SRC), Y
        LDA     (SRC), Y
; lisp/s-expr.pla: 0151:         ASL
        ASL
; lisp/s-expr.pla: 0152:         ASL
        ASL
; lisp/s-expr.pla: 0153:         EOR     ESTKL,X
        EOR     ESTKL,X
; lisp/s-expr.pla: 0154:         STA     ESTKL,X
        STA     ESTKL,X
; lisp/s-expr.pla: 0155:         LDY     #$01
        LDY     #$01
; lisp/s-expr.pla: 0156:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0157:         ASL
        ASL
; lisp/s-expr.pla: 0158:         EOR     ESTKL,X
        EOR     ESTKL,X
; lisp/s-expr.pla: 0159:         AND     #63           ; HASH_MASK
        AND     #63           ; HASH_MASK
; lisp/s-expr.pla: 0160:         STA     ESTKL,X
        STA     ESTKL,X
; lisp/s-expr.pla: 0161:         RTS
        RTS
; lisp/s-expr.pla: 0162: end
; lisp/s-expr.pla: 0163: 
; lisp/s-expr.pla: 0164: //def mark_list(list)#0
; lisp/s-expr.pla: 0165: //  while list
; lisp/s-expr.pla: 0166: //    list->type = list->type | MARK_BIT
; lisp/s-expr.pla: 0167: //    list = list=>link
; lisp/s-expr.pla: 0168: //  loop
; lisp/s-expr.pla: 0169: //end
; lisp/s-expr.pla: 0170: asm mark_list(list)#0
_A001 					; mark_list()
; lisp/s-expr.pla: 0171:         LDA     ESTKL,X
        LDA     ESTKL,X
; lisp/s-expr.pla: 0172:         STA     SRCL
        STA     SRCL
; lisp/s-expr.pla: 0173:         LDA     ESTKH,X
        LDA     ESTKH,X
; lisp/s-expr.pla: 0174:         STA     SRCH
        STA     SRCH
; lisp/s-expr.pla: 0175:         BEQ     +             ; CHECK FOR NULL (MSB, ANYWAY)
        BEQ     +             ; CHECK FOR NULL (MSB, ANYWAY)
; lisp/s-expr.pla: 0176: -       LDY     #$02
-       LDY     #$02
; lisp/s-expr.pla: 0177:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0178:         ORA     #$80          ; MARK_BIT
        ORA     #$80          ; MARK_BIT
; lisp/s-expr.pla: 0179:         STA     (SRC),Y
        STA     (SRC),Y
; lisp/s-expr.pla: 0180:         DEY
        DEY
; lisp/s-expr.pla: 0181:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0182:         BEQ     +
        BEQ     +
; lisp/s-expr.pla: 0183:         PHA
        PHA
; lisp/s-expr.pla: 0184:         DEY
        DEY
; lisp/s-expr.pla: 0185:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0186:         STA     SRCL
        STA     SRCL
; lisp/s-expr.pla: 0187:         PLA
        PLA
; lisp/s-expr.pla: 0188:         STA     SRCH
        STA     SRCH
; lisp/s-expr.pla: 0189:         BNE     -
        BNE     -
; lisp/s-expr.pla: 0190: +       INX
+       INX
; lisp/s-expr.pla: 0191:         RTS
        RTS
; lisp/s-expr.pla: 0192: end
; lisp/s-expr.pla: 0193: 
; lisp/s-expr.pla: 0194: //def match_sym(symstr, sym_list)
; lisp/s-expr.pla: 0195: //  var symptr
; lisp/s-expr.pla: 0196: //  byte len, typelen, i
; lisp/s-expr.pla: 0197: //
; lisp/s-expr.pla: 0198: //  len     = ^symstr
; lisp/s-expr.pla: 0199: //  typelen = SYM_TYPE | len
; lisp/s-expr.pla: 0200: //  len--; symstr++
; lisp/s-expr.pla: 0201: //  symptr = sym_list
; lisp/s-expr.pla: 0202: //  while symptr
; lisp/s-expr.pla: 0203: //    if symptr->type == typelen
; lisp/s-expr.pla: 0204: //      for i = 0 to len
; lisp/s-expr.pla: 0205: //        if symptr->name[i] <> symstr->[i]; break; fin
; lisp/s-expr.pla: 0206: //      next
; lisp/s-expr.pla: 0207: //      if i > len
; lisp/s-expr.pla: 0208: //        return symptr
; lisp/s-expr.pla: 0209: //      fin
; lisp/s-expr.pla: 0210: //    fin
; lisp/s-expr.pla: 0211: //    symptr = symptr=>link
; lisp/s-expr.pla: 0212: //  loop
; lisp/s-expr.pla: 0213: //  return NULL
; lisp/s-expr.pla: 0214: //end
; lisp/s-expr.pla: 0215: asm match_sym(symstr, sym_list)
_A002 					; match_sym()
; lisp/s-expr.pla: 0216:         INX
        INX
; lisp/s-expr.pla: 0217:         LDA     ESTKL-1,X     ; sym_list
        LDA     ESTKL-1,X     ; sym_list
; lisp/s-expr.pla: 0218:         STA     SRCL
        STA     SRCL
; lisp/s-expr.pla: 0219:         LDA     ESTKH-1,X
        LDA     ESTKH-1,X
; lisp/s-expr.pla: 0220:         STA     SRCH
        STA     SRCH
; lisp/s-expr.pla: 0221:         BEQ     MSYMRET       ; NULL
        BEQ     MSYMRET       ; NULL
; lisp/s-expr.pla: 0222:         LDA     ESTKL,X       ; symstr
        LDA     ESTKL,X       ; symstr
; lisp/s-expr.pla: 0223:         SEC
        SEC
; lisp/s-expr.pla: 0224:         SBC     #10
        SBC     #10
; lisp/s-expr.pla: 0225:         STA     DSTL
        STA     DSTL
; lisp/s-expr.pla: 0226:         LDA     ESTKH,X
        LDA     ESTKH,X
; lisp/s-expr.pla: 0227:         SBC     #0
        SBC     #0
; lisp/s-expr.pla: 0228:         STA     DSTH
        STA     DSTH
; lisp/s-expr.pla: 0229:         LDY     #10
        LDY     #10
; lisp/s-expr.pla: 0230:         LDA     (DST),Y
        LDA     (DST),Y
; lisp/s-expr.pla: 0231:         ORA     #$20          ; SYM_TYPE
        ORA     #$20          ; SYM_TYPE
; lisp/s-expr.pla: 0232:         STA     TMPL          ; len
        STA     TMPL          ; len
; lisp/s-expr.pla: 0233:         AND     #$0F
        AND     #$0F
; lisp/s-expr.pla: 0234:         CLC
        CLC
; lisp/s-expr.pla: 0235:         ADC     #10
        ADC     #10
; lisp/s-expr.pla: 0236:         STA     TMPH
        STA     TMPH
; lisp/s-expr.pla: 0237: --      LDA     TMPL
--      LDA     TMPL
; lisp/s-expr.pla: 0238:         LDY     #$02
        LDY     #$02
; lisp/s-expr.pla: 0239:         CMP     (SRC),Y
        CMP     (SRC),Y
; lisp/s-expr.pla: 0240:         BNE     +             ; NO MATCH, NEXT
        BNE     +             ; NO MATCH, NEXT
; lisp/s-expr.pla: 0241:         LDY     TMPH
        LDY     TMPH
; lisp/s-expr.pla: 0242: -       LDA     (SRC),Y
-       LDA     (SRC),Y
; lisp/s-expr.pla: 0243:         CMP     (DST),Y
        CMP     (DST),Y
; lisp/s-expr.pla: 0244:         BNE     +             ; NO MATCH, NEXT
        BNE     +             ; NO MATCH, NEXT
; lisp/s-expr.pla: 0245:         DEY
        DEY
; lisp/s-expr.pla: 0246:         CPY     #10
        CPY     #10
; lisp/s-expr.pla: 0247:         BNE     -
        BNE     -
; lisp/s-expr.pla: 0248: MSYMRET LDA     SRCL          ; RETURN MATCH
MSYMRET LDA     SRCL          ; RETURN MATCH
; lisp/s-expr.pla: 0249:         STA     ESTKL,X
        STA     ESTKL,X
; lisp/s-expr.pla: 0250:         LDA     SRCH
        LDA     SRCH
; lisp/s-expr.pla: 0251:         STA     ESTKH,X
        STA     ESTKH,X
; lisp/s-expr.pla: 0252:         RTS
        RTS
; lisp/s-expr.pla: 0253: +       LDY     #$01          ; NEXT
+       LDY     #$01          ; NEXT
; lisp/s-expr.pla: 0254:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0255:         PHA
        PHA
; lisp/s-expr.pla: 0256:         DEY
        DEY
; lisp/s-expr.pla: 0257:         LDA     (SRC),Y
        LDA     (SRC),Y
; lisp/s-expr.pla: 0258:         STA     SRCL
        STA     SRCL
; lisp/s-expr.pla: 0259:         PLA
        PLA
; lisp/s-expr.pla: 0260:         STA     SRCH
        STA     SRCH
; lisp/s-expr.pla: 0261:         BNE     --
        BNE     --
; lisp/s-expr.pla: 0262:         BEQ     MSYMRET
        BEQ     MSYMRET
; lisp/s-expr.pla: 0263: end
; lisp/s-expr.pla: 0264: 
; lisp/s-expr.pla: 0265: def mark_elems#0
_SUBSEG 				; BYTECODE STARTS
_C000 					; mark_elems()
; lisp/s-expr.pla: 0266:   mark_list(cons_list)
; lisp/s-expr.pla: 0267:   mark_list(int_list)
; lisp/s-expr.pla: 0268:   mark_list(float_list)
; lisp/s-expr.pla: 0269:   mark_list(string_list)
; lisp/s-expr.pla: 0270: end
	!BYTE	$6A			; LAW	_D071+0
_F000 	!WORD	_D071+0		
	!BYTE	$54			; CALL	_A001
_F001 	!WORD	_A001		
	!BYTE	$6A			; LAW	_D073+0
_F002 	!WORD	_D073+0		
	!BYTE	$54			; CALL	_A001
_F003 	!WORD	_A001		
	!BYTE	$6A			; LAW	_D075+0
_F004 	!WORD	_D075+0		
	!BYTE	$54			; CALL	_A001
_F005 	!WORD	_A001		
	!BYTE	$6A			; LAW	_D077+0
_F006 	!WORD	_D077+0		
	!BYTE	$54			; CALL	_A001
_F007 	!WORD	_A001		
	!BYTE	$5C			; RET
; lisp/s-expr.pla: 0271: 
; lisp/s-expr.pla: 0272: def sweep_expr(expr)#0
					; expr -> [0]
_C001 					; sweep_expr()
; lisp/s-expr.pla: 0273:   while expr
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$50			; BRNCH	_B003
	!WORD	_B003-*
_B001 
; lisp/s-expr.pla: 0274:     if not expr->type & MARK_BIT; return; fin // Stop if MARK_BIT clear
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$80			; NOT
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
	!BYTE	$5A,$02			; LEAVE	2
_B004 
_B005 
; lisp/s-expr.pla: 0275:     expr->type = expr->type & MARK_MASK
; lisp/s-expr.pla: 0276:     if expr->type == CONS_TYPE
; lisp/s-expr.pla: 0277:       sweep_expr(expr=>car)
; lisp/s-expr.pla: 0278:       expr = expr=>cdr
; lisp/s-expr.pla: 0279:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B006
	!WORD	_B006-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F008 	!WORD	_C001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B007
	!WORD	_B007-*
_B006 
; lisp/s-expr.pla: 0280:       expr = NULL
; lisp/s-expr.pla: 0281:     fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B007 
; lisp/s-expr.pla: 0282:   loop
_B003 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
_B002 
; lisp/s-expr.pla: 0283: end
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0284: 
; lisp/s-expr.pla: 0285: def sweep_used#0
_C002 					; sweep_used()
; lisp/s-expr.pla: 0286:   var symptr, h, i, memptr, size
					; symptr -> [0]
					; h -> [2]
					; i -> [4]
					; memptr -> [6]
					; size -> [8]
; lisp/s-expr.pla: 0287: 
; lisp/s-expr.pla: 0288:   sweep_expr(assoc_list)
	!BYTE	$58,$0A,$00		; ENTER	10,0
; lisp/s-expr.pla: 0289:   for h = 0 to HASH_SIZE-1
	!BYTE	$6A			; LAW	_D070+0
_F009 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C001
_F010 	!WORD	_C001		
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$00			; CN	0
_B009 
	!BYTE	$6E,$02			; DLW	[2]
; lisp/s-expr.pla: 0290:     symptr = hashtbl[h]
; lisp/s-expr.pla: 0291:     while symptr
	!BYTE	$26			; LA	_D079+0
_F011 	!WORD	_D079+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B013
	!WORD	_B013-*
_B011 
; lisp/s-expr.pla: 0292:       //
; lisp/s-expr.pla: 0293:       // Sweep symbol properties
; lisp/s-expr.pla: 0294:       //
; lisp/s-expr.pla: 0295:       if symptr=>apval
; lisp/s-expr.pla: 0296:         sweep_expr(symptr=>apval ^ NULL_HACK)
; lisp/s-expr.pla: 0297:       elsif symptr=>lambda
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B014
	!WORD	_B014-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$54			; CALL	_C001
_F012 	!WORD	_C001		
	!BYTE	$50			; BRNCH	_B015
	!WORD	_B015-*
_B014 
; lisp/s-expr.pla: 0298:         sweep_expr(symptr=>lambda)
; lisp/s-expr.pla: 0299:       elsif symptr=>array
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B016
	!WORD	_B016-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F013 	!WORD	_C001		
	!BYTE	$50			; BRNCH	_B015
	!WORD	_B015-*
_B016 
; lisp/s-expr.pla: 0300:         memptr = symptr=>array=>arraymem
; lisp/s-expr.pla: 0301:         size   = symptr=>array=>arraysize - 1
; lisp/s-expr.pla: 0302:         for i = 0 to size
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B017
	!WORD	_B017-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$38,$13			; ADDI	19
	!BYTE	$62			; LW
	!BYTE	$8E			; DECR
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B018
	!WORD	_B018-*
_B019 
	!BYTE	$6E,$04			; DLW	[4]
; lisp/s-expr.pla: 0303:           sweep_expr(memptr=>[i])
; lisp/s-expr.pla: 0304:         next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F014 	!WORD	_C001		
_B020 
	!BYTE	$A4			; INCBRLE	_B019
	!WORD	_B019-*
_B018 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0305:       fin
_B017 
_B015 
; lisp/s-expr.pla: 0306:       symptr = symptr=>link
; lisp/s-expr.pla: 0307:     loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B013 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B011
	!WORD	_B011-*
_B012 
; lisp/s-expr.pla: 0308:   next
_B010 
	!BYTE	$A4			; INCBRLE	_B009
	!WORD	_B009-*
_B008 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0309:   if sweep_stack_top
; lisp/s-expr.pla: 0310:     //
; lisp/s-expr.pla: 0311:     // Sweep in-flight parameters
; lisp/s-expr.pla: 0312:     //
; lisp/s-expr.pla: 0313:     for i = 0 to sweep_stack_top - 1
	!BYTE	$68			; LAB	_D096+0
_F015 	!WORD	_D096+0		
	!BYTE	$4C			; BRFLS	_B021
	!WORD	_B021-*
	!BYTE	$68			; LAB	_D096+0
_F016 	!WORD	_D096+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B023
	!WORD	_B023-*
_B024 
	!BYTE	$6E,$04			; DLW	[4]
; lisp/s-expr.pla: 0314:       sweep_expr(sweep_stack[i])
; lisp/s-expr.pla: 0315:     next
	!BYTE	$26			; LA	_D097+0
_F017 	!WORD	_D097+0		
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C001
_F018 	!WORD	_C001		
_B025 
	!BYTE	$A4			; INCBRLE	_B024
	!WORD	_B024-*
_B023 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0316:   fin
_B021 
_B022 
; lisp/s-expr.pla: 0317: end
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-expr.pla: 0318: 
; lisp/s-expr.pla: 0319: def push_sweep_stack(expr)#1
					; expr -> [0]
_C003 					; push_sweep_stack()
; lisp/s-expr.pla: 0320:   if sweep_stack_top == SWEEPSTACK_MAX - 1
	!BYTE	$58,$02,$01		; ENTER	2,1
; lisp/s-expr.pla: 0321:     throw(exception, ERR_SWEEP_OVRFLW)
; lisp/s-expr.pla: 0322:   fin
	!BYTE	$68			; LAB	_D096+0
_F019 	!WORD	_D096+0		
	!BYTE	$1E			; CN	15
	!BYTE	$24			; BRNE	_B026
	!WORD	_B026-*
	!BYTE	$6A			; LAW	_D067+0
_F020 	!WORD	_D067+0		
	!BYTE	$5E,$FD			; CFFB	-3
	!BYTE	$54			; CALL	_X062
_F021 	!WORD	0		
	!BYTE	$30			; DROP 
_B026 
_B027 
; lisp/s-expr.pla: 0323:   sweep_stack[sweep_stack_top] = expr
; lisp/s-expr.pla: 0324:   sweep_stack_top++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D097+0
_F022 	!WORD	_D097+0		
	!BYTE	$BC			; IDXAB	_D096+0
_F023 	!WORD	_D096+0		
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D096+0
_F024 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0325:   return expr
	!BYTE	$78			; SAB	_D096+0
_F025 	!WORD	_D096+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0326: end
; lisp/s-expr.pla: 0327: 
; lisp/s-expr.pla: 0328: def pop_sweep_stack#1
_C004 					; pop_sweep_stack()
; lisp/s-expr.pla: 0329:   if sweep_stack_top == 0
; lisp/s-expr.pla: 0330:     throw(exception, ERR_SWEEP_UNDFLW)
; lisp/s-expr.pla: 0331:   fin
	!BYTE	$68			; LAB	_D096+0
_F026 	!WORD	_D096+0		
	!BYTE	$4E			; BRTRU	_B028
	!WORD	_B028-*
	!BYTE	$6A			; LAW	_D067+0
_F027 	!WORD	_D067+0		
	!BYTE	$5E,$FC			; CFFB	-4
	!BYTE	$54			; CALL	_X062
_F028 	!WORD	0		
	!BYTE	$30			; DROP 
_B028 
_B029 
; lisp/s-expr.pla: 0332:   sweep_stack_top--
	!BYTE	$68			; LAB	_D096+0
_F029 	!WORD	_D096+0		
	!BYTE	$8E			; DECR
; lisp/s-expr.pla: 0333:   return sweep_stack[sweep_stack_top]
	!BYTE	$78			; SAB	_D096+0
_F030 	!WORD	_D096+0		
	!BYTE	$26			; LA	_D097+0
_F031 	!WORD	_D097+0		
	!BYTE	$BC			; IDXAB	_D096+0
_F032 	!WORD	_D096+0		
	!BYTE	$62			; LW
	!BYTE	$5C			; RET
; lisp/s-expr.pla: 0334: end
; lisp/s-expr.pla: 0335: 
; lisp/s-expr.pla: 0336: def collect_list(listhead, freehead)#2
					; listhead -> [0]
					; freehead -> [2]
_C005 					; collect_list()
; lisp/s-expr.pla: 0337:   var elemptr, prevptr
					; elemptr -> [4]
					; prevptr -> [6]
; lisp/s-expr.pla: 0338: 
; lisp/s-expr.pla: 0339:   prevptr = NULL
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-expr.pla: 0340:   elemptr = listhead
; lisp/s-expr.pla: 0341:   while elemptr
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
_B030 
; lisp/s-expr.pla: 0342:     if elemptr->type & MARK_BIT
; lisp/s-expr.pla: 0343:       elemptr->type = elemptr->type & MARK_MASK
; lisp/s-expr.pla: 0344:       if prevptr
; lisp/s-expr.pla: 0345:         prevptr=>link = elemptr=>link
; lisp/s-expr.pla: 0346:         elemptr=>link = freehead
; lisp/s-expr.pla: 0347:         freehead      = elemptr
; lisp/s-expr.pla: 0348:         elemptr       = prevptr=>link
; lisp/s-expr.pla: 0349:       else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B035
	!WORD	_B035-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B036
	!WORD	_B036-*
_B035 
; lisp/s-expr.pla: 0350:         listhead      = elemptr=>link
; lisp/s-expr.pla: 0351:         elemptr=>link = freehead
; lisp/s-expr.pla: 0352:         freehead      = elemptr
; lisp/s-expr.pla: 0353:         elemptr       = listhead
; lisp/s-expr.pla: 0354:       fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
_B036 
; lisp/s-expr.pla: 0355:     else
	!BYTE	$50			; BRNCH	_B034
	!WORD	_B034-*
_B033 
; lisp/s-expr.pla: 0356:       prevptr = elemptr
; lisp/s-expr.pla: 0357:       elemptr = elemptr=>link
; lisp/s-expr.pla: 0358:     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B034 
; lisp/s-expr.pla: 0359:   loop
_B032 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4E			; BRTRU	_B030
	!WORD	_B030-*
_B031 
; lisp/s-expr.pla: 0360:   return listhead, freehead
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-expr.pla: 0361: end
; lisp/s-expr.pla: 0362: 
; lisp/s-expr.pla: 0363: def collect_unused#0
_C006 					; collect_unused()
; lisp/s-expr.pla: 0364:   cons_list,   cons_free   = collect_list(cons_list,   cons_free)
; lisp/s-expr.pla: 0365:   int_list,    int_free    = collect_list(int_list,    int_free)
; lisp/s-expr.pla: 0366:   float_list,  float_free  = collect_list(float_list,  float_free)
; lisp/s-expr.pla: 0367:   string_list, string_free = collect_list(string_list, string_free)
; lisp/s-expr.pla: 0368: end
	!BYTE	$6A			; LAW	_D071+0
_F033 	!WORD	_D071+0		
	!BYTE	$6A			; LAW	_D072+0
_F034 	!WORD	_D072+0		
	!BYTE	$54			; CALL	_C005
_F035 	!WORD	_C005		
	!BYTE	$7A			; SAW	_D072+0
_F036 	!WORD	_D072+0		
	!BYTE	$7A			; SAW	_D071+0
_F037 	!WORD	_D071+0		
	!BYTE	$6A			; LAW	_D073+0
_F038 	!WORD	_D073+0		
	!BYTE	$6A			; LAW	_D074+0
_F039 	!WORD	_D074+0		
	!BYTE	$54			; CALL	_C005
_F040 	!WORD	_C005		
	!BYTE	$7A			; SAW	_D074+0
_F041 	!WORD	_D074+0		
	!BYTE	$7A			; SAW	_D073+0
_F042 	!WORD	_D073+0		
	!BYTE	$6A			; LAW	_D075+0
_F043 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D076+0
_F044 	!WORD	_D076+0		
	!BYTE	$54			; CALL	_C005
_F045 	!WORD	_C005		
	!BYTE	$7A			; SAW	_D076+0
_F046 	!WORD	_D076+0		
	!BYTE	$7A			; SAW	_D075+0
_F047 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D077+0
_F048 	!WORD	_D077+0		
	!BYTE	$6A			; LAW	_D078+0
_F049 	!WORD	_D078+0		
	!BYTE	$54			; CALL	_C005
_F050 	!WORD	_C005		
	!BYTE	$7A			; SAW	_D078+0
_F051 	!WORD	_D078+0		
	!BYTE	$7A			; SAW	_D077+0
_F052 	!WORD	_D077+0		
	!BYTE	$5C			; RET
; lisp/s-expr.pla: 0369: 
; lisp/s-expr.pla: 0370: export def gc#0
_C007 					; gc()
; lisp/s-expr.pla: 0371:   mark_elems
; lisp/s-expr.pla: 0372:   sweep_used
; lisp/s-expr.pla: 0373:   collect_unused
; lisp/s-expr.pla: 0374:   gc_pull = 0
; lisp/s-expr.pla: 0375:   gc_trigger = (heapavail >> GC_SHIFT_AVAIL) + 1
; lisp/s-expr.pla: 0376: end
	!BYTE	$54			; CALL	_C000
_F053 	!WORD	_C000		
	!BYTE	$54			; CALL	_C002
_F054 	!WORD	_C002		
	!BYTE	$54			; CALL	_C006
_F055 	!WORD	_C006		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D099+0
_F056 	!WORD	_D099+0		
	!BYTE	$54			; CALL	_X016
_F057 	!WORD	0		
	!BYTE	$0C			; CN	6
	!BYTE	$9C			; SHR
	!BYTE	$8C			; INCR
	!BYTE	$7A			; SAW	_D098+0
_F058 	!WORD	_D098+0		
	!BYTE	$5C			; RET
; lisp/s-expr.pla: 0377: 
; lisp/s-expr.pla: 0378: //
; lisp/s-expr.pla: 0379: // Build ATOMS
; lisp/s-expr.pla: 0380: //
; lisp/s-expr.pla: 0381: 
; lisp/s-expr.pla: 0382: def new(size)
					; size -> [0]
_C008 					; new()
; lisp/s-expr.pla: 0383:   var memptr
					; memptr -> [2]
; lisp/s-expr.pla: 0384: 
; lisp/s-expr.pla: 0385:   gc_pull++
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$6A			; LAW	_D099+0
_F059 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0386:   memptr = heapalloc(size)
; lisp/s-expr.pla: 0387:   if !memptr
; lisp/s-expr.pla: 0388:     throw(exception, ERR_OUT_OF_MEM)
; lisp/s-expr.pla: 0389:   fin
	!BYTE	$7A			; SAW	_D099+0
_F060 	!WORD	_D099+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X014
_F061 	!WORD	0		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B037
	!WORD	_B037-*
	!BYTE	$6A			; LAW	_D067+0
_F062 	!WORD	_D067+0		
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$54			; CALL	_X062
_F063 	!WORD	0		
	!BYTE	$30			; DROP 
_B037 
_B038 
; lisp/s-expr.pla: 0390:   return memptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0391: end
; lisp/s-expr.pla: 0392: 
; lisp/s-expr.pla: 0393: export def new_cons#1
_C009 					; new_cons()
; lisp/s-expr.pla: 0394:   var consptr
					; consptr -> [0]
; lisp/s-expr.pla: 0395: 
; lisp/s-expr.pla: 0396:   gc_pull++
	!BYTE	$58,$02,$00		; ENTER	2,0
	!BYTE	$6A			; LAW	_D099+0
_F064 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0397:   if cons_free
; lisp/s-expr.pla: 0398:     consptr   = cons_free
; lisp/s-expr.pla: 0399:     cons_free = cons_free=>link
; lisp/s-expr.pla: 0400:   else
	!BYTE	$7A			; SAW	_D099+0
_F065 	!WORD	_D099+0		
	!BYTE	$6A			; LAW	_D072+0
_F066 	!WORD	_D072+0		
	!BYTE	$4C			; BRFLS	_B039
	!WORD	_B039-*
	!BYTE	$6A			; LAW	_D072+0
_F067 	!WORD	_D072+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D072+0
_F068 	!WORD	_D072+0		
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D072+0
_F069 	!WORD	_D072+0		
	!BYTE	$50			; BRNCH	_B040
	!WORD	_B040-*
_B039 
; lisp/s-expr.pla: 0401:     consptr = new(t_cons)
; lisp/s-expr.pla: 0402:   fin
	!BYTE	$0E			; CN	7
	!BYTE	$54			; CALL	_C008
_F070 	!WORD	_C008		
	!BYTE	$76,$00			; SLW	[0]
_B040 
; lisp/s-expr.pla: 0403:   consptr=>link = cons_list
; lisp/s-expr.pla: 0404:   cons_list     = consptr
; lisp/s-expr.pla: 0405:   consptr->type = CONS_TYPE
; lisp/s-expr.pla: 0406:   consptr=>car  = NULL
; lisp/s-expr.pla: 0407:   consptr=>cdr  = NULL
; lisp/s-expr.pla: 0408:   return consptr
	!BYTE	$6A			; LAW	_D071+0
_F071 	!WORD	_D071+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D071+0
_F072 	!WORD	_D071+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0409: end
; lisp/s-expr.pla: 0410: 
; lisp/s-expr.pla: 0411: export def new_int(intlo, inthi)#1
					; intlo -> [0]
					; inthi -> [2]
_C010 					; new_int()
; lisp/s-expr.pla: 0412:   var intptr
					; intptr -> [4]
; lisp/s-expr.pla: 0413: 
; lisp/s-expr.pla: 0414:   gc_pull++
	!BYTE	$58,$06,$02		; ENTER	6,2
	!BYTE	$6A			; LAW	_D099+0
_F073 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0415:   if int_free
; lisp/s-expr.pla: 0416:     intptr   = int_free
; lisp/s-expr.pla: 0417:     int_free = int_free=>link
; lisp/s-expr.pla: 0418:   else
	!BYTE	$7A			; SAW	_D099+0
_F074 	!WORD	_D099+0		
	!BYTE	$6A			; LAW	_D074+0
_F075 	!WORD	_D074+0		
	!BYTE	$4C			; BRFLS	_B041
	!WORD	_B041-*
	!BYTE	$6A			; LAW	_D074+0
_F076 	!WORD	_D074+0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_D074+0
_F077 	!WORD	_D074+0		
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D074+0
_F078 	!WORD	_D074+0		
	!BYTE	$50			; BRNCH	_B042
	!WORD	_B042-*
_B041 
; lisp/s-expr.pla: 0419:     intptr = new(t_numint)
; lisp/s-expr.pla: 0420:   fin
	!BYTE	$0E			; CN	7
	!BYTE	$54			; CALL	_C008
_F079 	!WORD	_C008		
	!BYTE	$76,$04			; SLW	[4]
_B042 
; lisp/s-expr.pla: 0421:   intptr=>link      = int_list
; lisp/s-expr.pla: 0422:   int_list          = intptr
; lisp/s-expr.pla: 0423:   intptr->type      = NUM_INT
; lisp/s-expr.pla: 0424:   intptr=>intval[0] = intlo
; lisp/s-expr.pla: 0425:   intptr=>intval[1] = inthi
; lisp/s-expr.pla: 0426:   return intptr
	!BYTE	$6A			; LAW	_D073+0
_F080 	!WORD	_D073+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D073+0
_F081 	!WORD	_D073+0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0427: end
; lisp/s-expr.pla: 0428: 
; lisp/s-expr.pla: 0429: export def new_float(extptr)#1
					; extptr -> [0]
_C011 					; new_float()
; lisp/s-expr.pla: 0430:   var floatptr
					; floatptr -> [2]
; lisp/s-expr.pla: 0431: 
; lisp/s-expr.pla: 0432:   gc_pull++
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$6A			; LAW	_D099+0
_F082 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0433:   if float_free
; lisp/s-expr.pla: 0434:     floatptr   = float_free
; lisp/s-expr.pla: 0435:     float_free = float_free=>link
; lisp/s-expr.pla: 0436:   else
	!BYTE	$7A			; SAW	_D099+0
_F083 	!WORD	_D099+0		
	!BYTE	$6A			; LAW	_D076+0
_F084 	!WORD	_D076+0		
	!BYTE	$4C			; BRFLS	_B043
	!WORD	_B043-*
	!BYTE	$6A			; LAW	_D076+0
_F085 	!WORD	_D076+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D076+0
_F086 	!WORD	_D076+0		
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D076+0
_F087 	!WORD	_D076+0		
	!BYTE	$50			; BRNCH	_B044
	!WORD	_B044-*
_B043 
; lisp/s-expr.pla: 0437:     floatptr = new(t_numfloat)
; lisp/s-expr.pla: 0438:   fin
	!BYTE	$1A			; CN	13
	!BYTE	$54			; CALL	_C008
_F088 	!WORD	_C008		
	!BYTE	$76,$02			; SLW	[2]
_B044 
; lisp/s-expr.pla: 0439:   floatptr=>link = float_list
; lisp/s-expr.pla: 0440:   float_list     = floatptr
; lisp/s-expr.pla: 0441:   floatptr->type = NUM_FLOAT
; lisp/s-expr.pla: 0442:   memcpy(floatptr + floatval, extptr, 10)
; lisp/s-expr.pla: 0443:   return floatptr
	!BYTE	$6A			; LAW	_D075+0
_F089 	!WORD	_D075+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D075+0
_F090 	!WORD	_D075+0		
	!BYTE	$2A,$32			; CB	50
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F091 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0444: end
; lisp/s-expr.pla: 0445: 
; lisp/s-expr.pla: 0446: def new_array(dim0, dim1, dim2, dim3)
					; dim0 -> [0]
					; dim1 -> [2]
					; dim2 -> [4]
					; dim3 -> [6]
_C012 					; new_array()
; lisp/s-expr.pla: 0447:   var ofst0, ofst1, ofst2, ofst3
					; ofst0 -> [8]
					; ofst1 -> [10]
					; ofst2 -> [12]
					; ofst3 -> [14]
; lisp/s-expr.pla: 0448:   var size, aptr, memptr
					; size -> [16]
					; aptr -> [18]
					; memptr -> [20]
; lisp/s-expr.pla: 0449: 
; lisp/s-expr.pla: 0450:   gc_pull++
	!BYTE	$58,$16,$04		; ENTER	22,4
	!BYTE	$6A			; LAW	_D099+0
_F092 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0451:   if dim3
; lisp/s-expr.pla: 0452:     ofst3 = 2
; lisp/s-expr.pla: 0453:     ofst2 = dim3  * 2
; lisp/s-expr.pla: 0454:     ofst1 = ofst2 * dim2
; lisp/s-expr.pla: 0455:     ofst0 = ofst1 * dim1
; lisp/s-expr.pla: 0456:   elsif dim2
	!BYTE	$7A			; SAW	_D099+0
_F093 	!WORD	_D099+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B045
	!WORD	_B045-*
	!BYTE	$04			; CN	2
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$6E,$0C			; DLW	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$86			; MUL
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$86			; MUL
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B046
	!WORD	_B046-*
_B045 
; lisp/s-expr.pla: 0457:     ofst2 = 2
; lisp/s-expr.pla: 0458:     ofst1 = dim2 * 2
; lisp/s-expr.pla: 0459:     ofst0 = ofst1 * dim1
; lisp/s-expr.pla: 0460:   elsif dim1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B047
	!WORD	_B047-*
	!BYTE	$04			; CN	2
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$86			; MUL
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B046
	!WORD	_B046-*
_B047 
; lisp/s-expr.pla: 0461:     ofst1 = 2
; lisp/s-expr.pla: 0462:     ofst0 = dim1 * 2
; lisp/s-expr.pla: 0463:   else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B048
	!WORD	_B048-*
	!BYTE	$04			; CN	2
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B046
	!WORD	_B046-*
_B048 
; lisp/s-expr.pla: 0464:     ofst0 = 2
; lisp/s-expr.pla: 0465:   fin
	!BYTE	$04			; CN	2
	!BYTE	$76,$08			; SLW	[8]
_B046 
; lisp/s-expr.pla: 0466:   size   = dim0 * ofst0
; lisp/s-expr.pla: 0467:   memptr = new(size)
; lisp/s-expr.pla: 0468:   memset(memptr, NULL, size)
; lisp/s-expr.pla: 0469:   aptr               = new(t_array)
; lisp/s-expr.pla: 0470:   aptr=>link         = NULL
; lisp/s-expr.pla: 0471:   aptr->type         = ARRAY_TYPE
; lisp/s-expr.pla: 0472:   aptr=>dimension[0] = dim0
; lisp/s-expr.pla: 0473:   aptr=>dimension[1] = dim1
; lisp/s-expr.pla: 0474:   aptr=>dimension[2] = dim2
; lisp/s-expr.pla: 0475:   aptr=>dimension[3] = dim3
; lisp/s-expr.pla: 0476:   aptr=>offset[0]    = ofst0
; lisp/s-expr.pla: 0477:   aptr=>offset[1]    = ofst1
; lisp/s-expr.pla: 0478:   aptr=>offset[2]    = ofst2
; lisp/s-expr.pla: 0479:   aptr=>offset[3]    = ofst3
; lisp/s-expr.pla: 0480:   aptr=>arraysize    = size/2
; lisp/s-expr.pla: 0481:   aptr=>arraymem     = memptr
; lisp/s-expr.pla: 0482:   return aptr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$86			; MUL
	!BYTE	$6E,$10			; DLW	[16]
	!BYTE	$54			; CALL	_C008
_F094 	!WORD	_C008		
	!BYTE	$6E,$14			; DLW	[20]
	!BYTE	$00			; CN	0
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_X017
_F095 	!WORD	0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$54			; CALL	_C008
_F096 	!WORD	_C008		
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$00			; CN	0
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$72			; SW
	!BYTE	$2A,$40			; CB	64
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$04			; CN	2
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$06			; CN	3
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$04			; CN	2
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$06			; CN	3
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$13			; ADDI	19
	!BYTE	$72			; SW
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$72			; SW
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-expr.pla: 0483: end
; lisp/s-expr.pla: 0484: 
; lisp/s-expr.pla: 0485: def match_string(strptr)
					; strptr -> [0]
_C013 					; match_string()
; lisp/s-expr.pla: 0486:   var stringptr
					; stringptr -> [2]
; lisp/s-expr.pla: 0487:   byte len, i
					; len -> [4]
					; i -> [5]
; lisp/s-expr.pla: 0488: 
; lisp/s-expr.pla: 0489:   len       = ^strptr
	!BYTE	$58,$06,$01		; ENTER	6,1
; lisp/s-expr.pla: 0490:   stringptr = string_list
; lisp/s-expr.pla: 0491:   while stringptr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$6A			; LAW	_D077+0
_F097 	!WORD	_D077+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B051
	!WORD	_B051-*
_B049 
; lisp/s-expr.pla: 0492:     if stringptr->stringstr== len
; lisp/s-expr.pla: 0493:       for i = len downto 1
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$24			; BRNE	_B052
	!WORD	_B052-*
	!BYTE	$02			; CN	1
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$A2			; BRLT	_B054
	!WORD	_B054-*
_B055 
	!BYTE	$6C,$05			; DLB	[5]
; lisp/s-expr.pla: 0494:         if stringptr->stringstr[i] <> ^(strptr + i)
; lisp/s-expr.pla: 0495:           break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B057
	!WORD	_B057-*
	!BYTE	$50			; BRNCH	_B054
	!WORD	_B054-*
; lisp/s-expr.pla: 0496:         fin
_B057 
_B058 
; lisp/s-expr.pla: 0497:       next
_B056 
	!BYTE	$A8			; DECBRGE	_B055
	!WORD	_B055-*
_B054 
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0498:       if i == 0
; lisp/s-expr.pla: 0499:         return stringptr
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$4E			; BRTRU	_B059
	!WORD	_B059-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0500:       fin
_B059 
_B060 
; lisp/s-expr.pla: 0501:     fin
_B052 
_B053 
; lisp/s-expr.pla: 0502:     stringptr = stringptr=>link
; lisp/s-expr.pla: 0503:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B051 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B049
	!WORD	_B049-*
_B050 
; lisp/s-expr.pla: 0504:   return NULL
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0505: end
; lisp/s-expr.pla: 0506: 
; lisp/s-expr.pla: 0507: export def new_string(strptr)#1
					; strptr -> [0]
_C014 					; new_string()
; lisp/s-expr.pla: 0508:   var stringptr, alloclen, prevptr
					; stringptr -> [2]
					; alloclen -> [4]
					; prevptr -> [6]
; lisp/s-expr.pla: 0509: 
; lisp/s-expr.pla: 0510:   stringptr = match_string(strptr)
	!BYTE	$58,$08,$01		; ENTER	8,1
; lisp/s-expr.pla: 0511:   if stringptr; return stringptr; fin // Return matching string
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F098 	!WORD	_C013		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B061
	!WORD	_B061-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$08			; LEAVE	8
_B061 
_B062 
; lisp/s-expr.pla: 0512:   alloclen = ^strptr | 15 // Round up size to 15 chars in length
; lisp/s-expr.pla: 0513:   gc_pull++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3E,$0F			; ORI	15
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_D099+0
_F099 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0514:   if string_free
; lisp/s-expr.pla: 0515:     prevptr   = NULL
; lisp/s-expr.pla: 0516:     stringptr = string_free
; lisp/s-expr.pla: 0517:     while stringptr and (stringptr->stringstr | 15) <> alloclen
	!BYTE	$7A			; SAW	_D099+0
_F100 	!WORD	_D099+0		
	!BYTE	$6A			; LAW	_D078+0
_F101 	!WORD	_D078+0		
	!BYTE	$4C			; BRFLS	_B063
	!WORD	_B063-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_D078+0
_F102 	!WORD	_D078+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B067
	!WORD	_B067-*
_B065 
; lisp/s-expr.pla: 0518:       prevptr   = stringptr
; lisp/s-expr.pla: 0519:       stringptr = stringptr=>link
; lisp/s-expr.pla: 0520:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B067 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B068
	!WORD	_B068-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$3E,$0F			; ORI	15
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$42			; ISNE
_B068 
	!BYTE	$4E			; BRTRU	_B065
	!WORD	_B065-*
_B066 
; lisp/s-expr.pla: 0521:     if stringptr
; lisp/s-expr.pla: 0522:       if prevptr
; lisp/s-expr.pla: 0523:         prevptr=>link = stringptr=>link
; lisp/s-expr.pla: 0524:       else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B069
	!WORD	_B069-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B071
	!WORD	_B071-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B072
	!WORD	_B072-*
_B071 
; lisp/s-expr.pla: 0525:         string_free = stringptr=>link
; lisp/s-expr.pla: 0526:       fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D078+0
_F103 	!WORD	_D078+0		
_B072 
; lisp/s-expr.pla: 0527:     fin
_B069 
_B070 
; lisp/s-expr.pla: 0528:   fin
_B063 
_B064 
; lisp/s-expr.pla: 0529:   if !stringptr // Nothing free
; lisp/s-expr.pla: 0530:     gc_pull++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B073
	!WORD	_B073-*
	!BYTE	$6A			; LAW	_D099+0
_F104 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0531:     stringptr = new(t_string + alloclen)
; lisp/s-expr.pla: 0532:   fin
	!BYTE	$7A			; SAW	_D099+0
_F105 	!WORD	_D099+0		
	!BYTE	$08			; CN	4
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$54			; CALL	_C008
_F106 	!WORD	_C008		
	!BYTE	$76,$02			; SLW	[2]
_B073 
_B074 
; lisp/s-expr.pla: 0533:   stringptr=>link = string_list
; lisp/s-expr.pla: 0534:   string_list     = stringptr
; lisp/s-expr.pla: 0535:   stringptr->type = STRING_TYPE
; lisp/s-expr.pla: 0536:   memcpy(stringptr + stringstr, strptr, ^strptr + 1)
; lisp/s-expr.pla: 0537:   return stringptr
	!BYTE	$6A			; LAW	_D077+0
_F107 	!WORD	_D077+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D077+0
_F108 	!WORD	_D077+0		
	!BYTE	$2A,$50			; CB	80
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F109 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-expr.pla: 0538: end
; lisp/s-expr.pla: 0539: 
; lisp/s-expr.pla: 0540: export def new_sym(symstr)#1
					; symstr -> [0]
_C015 					; new_sym()
; lisp/s-expr.pla: 0541:   var symptr, index
					; symptr -> [2]
					; index -> [4]
; lisp/s-expr.pla: 0542: 
; lisp/s-expr.pla: 0543:   index  = hashstr(symstr) // (^symstr ^ ^(symstr + 1 + ^symstr/2) << 2) & HASH_MASK
	!BYTE	$58,$06,$01		; ENTER	6,1
; lisp/s-expr.pla: 0544:   symptr = match_sym(symstr, hashtbl[index])
; lisp/s-expr.pla: 0545:   if symptr; return symptr; fin // Return already existing symbol
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A000
_F110 	!WORD	_A000		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D079+0
_F111 	!WORD	_D079+0		
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A002
_F112 	!WORD	_A002		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$06			; LEAVE	6
_B075 
_B076 
; lisp/s-expr.pla: 0546:   gc_pull++
	!BYTE	$6A			; LAW	_D099+0
_F113 	!WORD	_D099+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0547:   symptr         = new(t_sym + ^symstr)
; lisp/s-expr.pla: 0548:   symptr=>link   = hashtbl[index]
; lisp/s-expr.pla: 0549:   hashtbl[index] = symptr
; lisp/s-expr.pla: 0550:   symptr->type   = ^symstr | SYM_TYPE
; lisp/s-expr.pla: 0551:   symptr=>natv   = NULL
; lisp/s-expr.pla: 0552:   symptr=>lambda = NULL
; lisp/s-expr.pla: 0553:   symptr=>array  = NULL
; lisp/s-expr.pla: 0554:   symptr=>apval  = NULL
; lisp/s-expr.pla: 0555:   memcpy(symptr + name, symstr + 1, ^symstr)
; lisp/s-expr.pla: 0556:   return symptr
	!BYTE	$7A			; SAW	_D099+0
_F114 	!WORD	_D099+0		
	!BYTE	$16			; CN	11
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_C008
_F115 	!WORD	_C008		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$26			; LA	_D079+0
_F116 	!WORD	_D079+0		
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D079+0
_F117 	!WORD	_D079+0		
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3E,$20			; ORI	32
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F118 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0557: end
; lisp/s-expr.pla: 0558: 
; lisp/s-expr.pla: 0559: //
; lisp/s-expr.pla: 0560: // Print textual representation of S-expression
; lisp/s-expr.pla: 0561: //
; lisp/s-expr.pla: 0562: 
; lisp/s-expr.pla: 0563: def print_atom(atom)#0
					; atom -> [0]
_C016 					; print_atom()
; lisp/s-expr.pla: 0564:   char prstr[32]
					; prstr -> [2]
; lisp/s-expr.pla: 0565:   var elemptr, i, j, k, l
					; elemptr -> [34]
					; i -> [36]
					; j -> [38]
					; k -> [40]
					; l -> [42]
; lisp/s-expr.pla: 0566: 
; lisp/s-expr.pla: 0567:   if not atom
	!BYTE	$58,$2C,$01		; ENTER	44,1
; lisp/s-expr.pla: 0568:     puts("NIL")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B077
	!WORD	_B077-*
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4E,$49,$4C
	!BYTE	$54			; CALL	_X004
_F119 	!WORD	0		
; lisp/s-expr.pla: 0569:   else
	!BYTE	$50			; BRNCH	_B078
	!WORD	_B078-*
_B077 
; lisp/s-expr.pla: 0570:     when atom->type & TYPE_MASK
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$52			; SEL
	!WORD	_B080-*
; lisp/s-expr.pla: 0571:       is NUM_TYPE
_B081 
; lisp/s-expr.pla: 0572:         when atom->type
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B083-*
; lisp/s-expr.pla: 0573:           is NUM_INT
_B084 
; lisp/s-expr.pla: 0574:             if prhex
; lisp/s-expr.pla: 0575:               putc('$')
; lisp/s-expr.pla: 0576:               puth(atom=>intval[1]); puth(atom=>intval[0])
; lisp/s-expr.pla: 0577:             else
	!BYTE	$68			; LAB	_D063+0
_F120 	!WORD	_D063+0		
	!BYTE	$4C			; BRFLS	_B085
	!WORD	_B085-*
	!BYTE	$2A,$24			; CB	36
	!BYTE	$54			; CALL	_X002
_F121 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X009
_F122 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X009
_F123 	!WORD	0		
	!BYTE	$50			; BRNCH	_B086
	!WORD	_B086-*
_B085 
; lisp/s-expr.pla: 0578:               if atom=>intval[1] >= 0; putc(' '); fin // Add space for pos
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B087
	!WORD	_B087-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F124 	!WORD	0		
_B087 
_B088 
; lisp/s-expr.pla: 0579:               puti32(atom + intval)
; lisp/s-expr.pla: 0580:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X056
_F125 	!WORD	0		
_B086 
; lisp/s-expr.pla: 0581:             break
	!BYTE	$50			; BRNCH	_B082
	!WORD	_B082-*
; lisp/s-expr.pla: 0582:           is NUM_FLOAT
_B089 
; lisp/s-expr.pla: 0583:             puts(ext2str(atom + floatval, @prstr, fmt_fpint, fmt_fpfrac, fmt_fp))
; lisp/s-expr.pla: 0584:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_D064+0
_F126 	!WORD	_D064+0		
	!BYTE	$6A			; LAW	_D065+0
_F127 	!WORD	_D065+0		
	!BYTE	$16			; CN	11
	!BYTE	$54			; CALL	_X059
_F128 	!WORD	0		
	!BYTE	$54			; CALL	_X004
_F129 	!WORD	0		
	!BYTE	$50			; BRNCH	_B082
	!WORD	_B082-*
; lisp/s-expr.pla: 0585:         wend
	!BYTE	$50			; BRNCH	_B082
	!WORD	_B082-*
_B083 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0031
	!WORD	_B084-*
	!WORD	$0032
	!WORD	_B089-*
_B082 
; lisp/s-expr.pla: 0586:         break
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; lisp/s-expr.pla: 0587:       is SYM_TYPE
_B090 
; lisp/s-expr.pla: 0588:         prstr = atom->type & SYM_LEN
; lisp/s-expr.pla: 0589:         memcpy(@prstr + 1, atom + name, prstr)
; lisp/s-expr.pla: 0590:         puts(@prstr)
; lisp/s-expr.pla: 0591:         break;
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$54			; CALL	_X018
_F130 	!WORD	0		
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$54			; CALL	_X004
_F131 	!WORD	0		
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; lisp/s-expr.pla: 0592:       is ARRAY_TYPE
_B091 
; lisp/s-expr.pla: 0593:         elemptr = atom=>arraymem
; lisp/s-expr.pla: 0594:         puts("[ ")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$62			; LW
	!BYTE	$76,$22			; SLW	[34]
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$5B,$20
	!BYTE	$54			; CALL	_X004
_F132 	!WORD	0		
; lisp/s-expr.pla: 0595:         for i = 1 to atom=>dimension[0]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B092
	!WORD	_B092-*
_B093 
	!BYTE	$6E,$24			; DLW	[36]
; lisp/s-expr.pla: 0596:           if atom=>dimension[1]
; lisp/s-expr.pla: 0597:             puts("\n[ ")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B095
	!WORD	_B095-*
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$0D,$5B,$20
	!BYTE	$54			; CALL	_X004
_F133 	!WORD	0		
; lisp/s-expr.pla: 0598:             for j = 1 to atom=>dimension[1]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B097
	!WORD	_B097-*
_B098 
	!BYTE	$6E,$26			; DLW	[38]
; lisp/s-expr.pla: 0599:               if atom=>dimension[2]
; lisp/s-expr.pla: 0600:                 puts("\n[ ")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$04			; CN	2
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B100
	!WORD	_B100-*
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$0D,$5B,$20
	!BYTE	$54			; CALL	_X004
_F134 	!WORD	0		
; lisp/s-expr.pla: 0601:                 for k = 1 to atom=>dimension[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$04			; CN	2
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B102
	!WORD	_B102-*
_B103 
	!BYTE	$6E,$28			; DLW	[40]
; lisp/s-expr.pla: 0602:                   if atom=>dimension[3]
; lisp/s-expr.pla: 0603:                     puts("\n[ ")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$06			; CN	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$0D,$5B,$20
	!BYTE	$54			; CALL	_X004
_F135 	!WORD	0		
; lisp/s-expr.pla: 0604:                     for l = 1 to atom=>dimension[3]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$06			; CN	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B107
	!WORD	_B107-*
_B108 
	!BYTE	$6E,$2A			; DLW	[42]
; lisp/s-expr.pla: 0605:                       print_atom(*elemptr); putc(' ')
; lisp/s-expr.pla: 0606:                       elemptr = elemptr + 2
; lisp/s-expr.pla: 0607:                     next
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C016
_F136 	!WORD	_C016		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F137 	!WORD	0		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$22			; SLW	[34]
_B109 
	!BYTE	$A4			; INCBRLE	_B108
	!WORD	_B108-*
_B107 
	!BYTE	$76,$2A			; SLW	[42]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0608:                     puts("]")
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$5D
	!BYTE	$54			; CALL	_X004
_F138 	!WORD	0		
; lisp/s-expr.pla: 0609:                   else
	!BYTE	$50			; BRNCH	_B106
	!WORD	_B106-*
_B105 
; lisp/s-expr.pla: 0610:                     print_atom(*elemptr); putc(' ')
; lisp/s-expr.pla: 0611:                     elemptr = elemptr + 2
; lisp/s-expr.pla: 0612:                   fin
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C016
_F139 	!WORD	_C016		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F140 	!WORD	0		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$22			; SLW	[34]
_B106 
; lisp/s-expr.pla: 0613:                 next
_B104 
	!BYTE	$A4			; INCBRLE	_B103
	!WORD	_B103-*
_B102 
	!BYTE	$76,$28			; SLW	[40]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0614:                 puts("]")
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$5D
	!BYTE	$54			; CALL	_X004
_F141 	!WORD	0		
; lisp/s-expr.pla: 0615:               else
	!BYTE	$50			; BRNCH	_B101
	!WORD	_B101-*
_B100 
; lisp/s-expr.pla: 0616:                 print_atom(*elemptr); putc(' ')
; lisp/s-expr.pla: 0617:                 elemptr = elemptr + 2
; lisp/s-expr.pla: 0618:               fin
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C016
_F142 	!WORD	_C016		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F143 	!WORD	0		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$22			; SLW	[34]
_B101 
; lisp/s-expr.pla: 0619:             next
_B099 
	!BYTE	$A4			; INCBRLE	_B098
	!WORD	_B098-*
_B097 
	!BYTE	$76,$26			; SLW	[38]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0620:             puts("]")
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$5D
	!BYTE	$54			; CALL	_X004
_F144 	!WORD	0		
; lisp/s-expr.pla: 0621:           else
	!BYTE	$50			; BRNCH	_B096
	!WORD	_B096-*
_B095 
; lisp/s-expr.pla: 0622:             print_atom(*elemptr); putc(' ')
; lisp/s-expr.pla: 0623:             elemptr = elemptr + 2
; lisp/s-expr.pla: 0624:           fin
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C016
_F145 	!WORD	_C016		
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F146 	!WORD	0		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$76,$22			; SLW	[34]
_B096 
; lisp/s-expr.pla: 0625:         next
_B094 
	!BYTE	$A4			; INCBRLE	_B093
	!WORD	_B093-*
_B092 
	!BYTE	$76,$24			; SLW	[36]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 0626:         puts("]\n")
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$5D,$0D
	!BYTE	$54			; CALL	_X004
_F147 	!WORD	0		
; lisp/s-expr.pla: 0627:         break
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; lisp/s-expr.pla: 0628:       is STRING_TYPE
_B110 
; lisp/s-expr.pla: 0629:         puts(atom + stringstr)
; lisp/s-expr.pla: 0630:         break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_X004
_F148 	!WORD	0		
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
; lisp/s-expr.pla: 0631:       otherwise
_B080 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0020
	!WORD	_B090-*
	!WORD	$0030
	!WORD	_B081-*
	!WORD	$0040
	!WORD	_B091-*
	!WORD	$0050
	!WORD	_B110-*
; lisp/s-expr.pla: 0632:         err_expr = atom
; lisp/s-expr.pla: 0633:         throw(exception, ERR_INTERNAL)
; lisp/s-expr.pla: 0634:     wend
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F149 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F150 	!WORD	_D067+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_X062
_F151 	!WORD	0		
	!BYTE	$30			; DROP 
_B079 
; lisp/s-expr.pla: 0635:   fin
_B078 
; lisp/s-expr.pla: 0636: end
	!BYTE	$5A,$2C			; LEAVE	44
; lisp/s-expr.pla: 0637: 
; lisp/s-expr.pla: 0638: export def print_expr(expr)#0
					; expr -> [0]
_P000 					; print_expr(expr)#0()
_C017 					; print_expr()
; lisp/s-expr.pla: 0639:   if not expr
	!BYTE	$58,$02,$01		; ENTER	2,1
; lisp/s-expr.pla: 0640:     puts("NIL")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B111
	!WORD	_B111-*
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4E,$49,$4C
	!BYTE	$54			; CALL	_X004
_F152 	!WORD	0		
; lisp/s-expr.pla: 0641:   else
	!BYTE	$50			; BRNCH	_B112
	!WORD	_B112-*
_B111 
; lisp/s-expr.pla: 0642:     if expr->type == CONS_TYPE
; lisp/s-expr.pla: 0643:       putc('(')
; lisp/s-expr.pla: 0644:       while expr and expr->type == CONS_TYPE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B113
	!WORD	_B113-*
	!BYTE	$2A,$28			; CB	40
	!BYTE	$54			; CALL	_X002
_F153 	!WORD	0		
	!BYTE	$50			; BRNCH	_B117
	!WORD	_B117-*
_B115 
; lisp/s-expr.pla: 0645:         print_expr(expr=>car)
; lisp/s-expr.pla: 0646:         expr = expr=>cdr
; lisp/s-expr.pla: 0647:         if expr
; lisp/s-expr.pla: 0648:           if expr->type <> CONS_TYPE
; lisp/s-expr.pla: 0649:             putc('.')
; lisp/s-expr.pla: 0650:             print_atom(expr)
; lisp/s-expr.pla: 0651:             expr = NULL
; lisp/s-expr.pla: 0652:           else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C017
_F154 	!WORD	_C017		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B119
	!WORD	_B119-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$22			; BREQ	_B121
	!WORD	_B121-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F155 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C016
_F156 	!WORD	_C016		
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B122
	!WORD	_B122-*
_B121 
; lisp/s-expr.pla: 0653:             putc(' ')
; lisp/s-expr.pla: 0654:           fin
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F157 	!WORD	0		
_B122 
; lisp/s-expr.pla: 0655:         fin
_B119 
_B120 
; lisp/s-expr.pla: 0656:       loop
_B117 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B118
	!WORD	_B118-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$40			; ISEQ
_B118 
	!BYTE	$4E			; BRTRU	_B115
	!WORD	_B115-*
_B116 
; lisp/s-expr.pla: 0657:       putc(')')
; lisp/s-expr.pla: 0658:     else
	!BYTE	$2A,$29			; CB	41
	!BYTE	$54			; CALL	_X002
_F158 	!WORD	0		
	!BYTE	$50			; BRNCH	_B114
	!WORD	_B114-*
_B113 
; lisp/s-expr.pla: 0659:       print_atom(expr)
; lisp/s-expr.pla: 0660:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C016
_F159 	!WORD	_C016		
_B114 
; lisp/s-expr.pla: 0661:   fin
_B112 
; lisp/s-expr.pla: 0662: end
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0663: 
; lisp/s-expr.pla: 0664: //
; lisp/s-expr.pla: 0665: // Parse textual representation of S-expression
; lisp/s-expr.pla: 0666: //
; lisp/s-expr.pla: 0667: 
; lisp/s-expr.pla: 0668: def is_num(cptr)
					; cptr -> [0]
_C018 					; is_num()
; lisp/s-expr.pla: 0669:   if ^cptr == '-' or ^cptr == '+'; cptr++; fin
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B123
	!WORD	_B123-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$40			; ISEQ
_B123 
	!BYTE	$4C			; BRFLS	_B124
	!WORD	_B124-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$76,$00			; SLW	[0]
_B124 
_B125 
; lisp/s-expr.pla: 0670:   if ^cptr == '$'
; lisp/s-expr.pla: 0671:     cptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$24			; CB	36
	!BYTE	$24			; BRNE	_B126
	!WORD	_B126-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0672:     if toupper(^cptr) >= 'A' and toupper(^cptr) <= 'F'
; lisp/s-expr.pla: 0673:       return TRUE
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F160 	!WORD	0		
	!BYTE	$2A,$41			; CB	65
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B128
	!WORD	_B128-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F161 	!WORD	0		
	!BYTE	$2A,$46			; CB	70
	!BYTE	$4A			; ISLE
_B128 
	!BYTE	$4C			; BRFLS	_B129
	!WORD	_B129-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0674:     fin
_B129 
_B130 
; lisp/s-expr.pla: 0675:   fin
_B126 
_B127 
; lisp/s-expr.pla: 0676:   return ^cptr >= '0' and ^cptr <= '9'
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B131
	!WORD	_B131-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B131 
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0677: end
; lisp/s-expr.pla: 0678: 
; lisp/s-expr.pla: 0679: def is_alphasym(c)
					; c -> [0]
_C019 					; is_alphasym()
; lisp/s-expr.pla: 0680:   return (c >= '*' and c <= 'z') and (c <> '.') and (c <> ',')
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B132
	!WORD	_B132-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$7A			; CB	122
	!BYTE	$4A			; ISLE
_B132 
	!BYTE	$AC			; BRAND	_B133
	!WORD	_B133-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B134
	!WORD	_B134-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$42			; ISNE
_B134 
_B133 
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 0681: end
; lisp/s-expr.pla: 0682: 
; lisp/s-expr.pla: 0683: def parse_num(evalptr)#2 // return evalptr, intptr
					; evalptr -> [0]
_C020 					; parse_num()
; lisp/s-expr.pla: 0684:   var startptr
					; startptr -> [2]
; lisp/s-expr.pla: 0685:   var int[2], ext[5]
					; int -> [4]
					; ext -> [8]
; lisp/s-expr.pla: 0686:   byte sign, h
					; sign -> [18]
					; h -> [19]
; lisp/s-expr.pla: 0687: 
; lisp/s-expr.pla: 0688:   sign = FALSE
	!BYTE	$58,$14,$01		; ENTER	20,1
; lisp/s-expr.pla: 0689:   if ^evalptr == '-'
; lisp/s-expr.pla: 0690:     sign = TRUE
; lisp/s-expr.pla: 0691:     evalptr++
	!BYTE	$00			; CN	0
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$24			; BRNE	_B135
	!WORD	_B135-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0692:   elsif ^evalptr == '+'
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B136
	!WORD	_B136-*
_B135 
; lisp/s-expr.pla: 0693:     evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$24			; BRNE	_B137
	!WORD	_B137-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0694:   fin
	!BYTE	$76,$00			; SLW	[0]
_B137 
_B136 
; lisp/s-expr.pla: 0695:   if ^evalptr == '$'
; lisp/s-expr.pla: 0696:     evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$24			; CB	36
	!BYTE	$24			; BRNE	_B138
	!WORD	_B138-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0697:     h = toupper(^evalptr)
; lisp/s-expr.pla: 0698:     zero32
; lisp/s-expr.pla: 0699:     while h >= '0' and h <= 'F'
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F162 	!WORD	0		
	!BYTE	$74,$13			; SLB	[19]
	!BYTE	$54			; CALL	_X029
_F163 	!WORD	0		
	!BYTE	$50			; BRNCH	_B142
	!WORD	_B142-*
_B140 
; lisp/s-expr.pla: 0700:       if h > '9'
; lisp/s-expr.pla: 0701:         h = h - 'A' + 10
; lisp/s-expr.pla: 0702:         if h > 16; break; fin
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B144
	!WORD	_B144-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$3A,$41			; SUBI	65
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$6C,$13			; DLB	[19]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B146
	!WORD	_B146-*
	!BYTE	$50			; BRNCH	_B141
	!WORD	_B141-*
_B146 
_B147 
; lisp/s-expr.pla: 0703:       else
	!BYTE	$50			; BRNCH	_B145
	!WORD	_B145-*
_B144 
; lisp/s-expr.pla: 0704:         h = h - '0'
; lisp/s-expr.pla: 0705:       fin
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$74,$13			; SLB	[19]
_B145 
; lisp/s-expr.pla: 0706:       muli16(16); addi16(h)
; lisp/s-expr.pla: 0707:       evalptr++
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_X042
_F164 	!WORD	0		
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$54			; CALL	_X036
_F165 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0708:       h = toupper(^evalptr)
; lisp/s-expr.pla: 0709:     loop
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F166 	!WORD	0		
	!BYTE	$74,$13			; SLB	[19]
_B142 
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B143
	!WORD	_B143-*
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$2A,$46			; CB	70
	!BYTE	$4A			; ISLE
_B143 
	!BYTE	$4E			; BRTRU	_B140
	!WORD	_B140-*
_B141 
; lisp/s-expr.pla: 0710:   else
	!BYTE	$50			; BRNCH	_B139
	!WORD	_B139-*
_B138 
; lisp/s-expr.pla: 0711:     startptr = evalptr
; lisp/s-expr.pla: 0712:     while ^evalptr >= '0' and ^evalptr <= '9'
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B150
	!WORD	_B150-*
_B148 
; lisp/s-expr.pla: 0713:       evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0714:     loop
	!BYTE	$76,$00			; SLW	[0]
_B150 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B151
	!WORD	_B151-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B151 
	!BYTE	$4E			; BRTRU	_B148
	!WORD	_B148-*
_B149 
; lisp/s-expr.pla: 0715:     if (evalptr - startptr > 10) or ^evalptr == '.' or toupper(^evalptr) == 'E'
; lisp/s-expr.pla: 0716:       if ^evalptr == '.'
; lisp/s-expr.pla: 0717:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$14			; CN	10
	!BYTE	$44			; ISGT
	!BYTE	$AE			; BROR	_B152
	!WORD	_B152-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B153
	!WORD	_B153-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F167 	!WORD	0		
	!BYTE	$2A,$45			; CB	69
	!BYTE	$40			; ISEQ
_B153 
_B152 
	!BYTE	$4C			; BRFLS	_B154
	!WORD	_B154-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$24			; BRNE	_B156
	!WORD	_B156-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0718:         while ^evalptr >= '0' and ^evalptr <= '9'
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B160
	!WORD	_B160-*
_B158 
; lisp/s-expr.pla: 0719:           evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0720:         loop
	!BYTE	$76,$00			; SLW	[0]
_B160 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B161
	!WORD	_B161-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B161 
	!BYTE	$4E			; BRTRU	_B158
	!WORD	_B158-*
_B159 
; lisp/s-expr.pla: 0721:       fin
_B156 
_B157 
; lisp/s-expr.pla: 0722:       if toupper(^evalptr) == 'E'
; lisp/s-expr.pla: 0723:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F168 	!WORD	0		
	!BYTE	$2A,$45			; CB	69
	!BYTE	$24			; BRNE	_B162
	!WORD	_B162-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0724:         if ^evalptr == '-' or ^evalptr == '+'; evalptr++; fin
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B164
	!WORD	_B164-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$40			; ISEQ
_B164 
	!BYTE	$4C			; BRFLS	_B165
	!WORD	_B165-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$76,$00			; SLW	[0]
_B165 
_B166 
; lisp/s-expr.pla: 0725:         while ^evalptr >= '0' and ^evalptr <= '9'
	!BYTE	$50			; BRNCH	_B169
	!WORD	_B169-*
_B167 
; lisp/s-expr.pla: 0726:           evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0727:         loop
	!BYTE	$76,$00			; SLW	[0]
_B169 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B170
	!WORD	_B170-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B170 
	!BYTE	$4E			; BRTRU	_B167
	!WORD	_B167-*
_B168 
; lisp/s-expr.pla: 0728:       fin
_B162 
_B163 
; lisp/s-expr.pla: 0729:       if sign; startptr--; fin
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$4C			; BRFLS	_B171
	!WORD	_B171-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$76,$02			; SLW	[2]
_B171 
_B172 
; lisp/s-expr.pla: 0730:       ^(startptr - 1) = evalptr - startptr
; lisp/s-expr.pla: 0731:       str2ext(startptr - 1, @ext)
; lisp/s-expr.pla: 0732:       return evalptr, new_float(@ext)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_X058
_F169 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C011
_F170 	!WORD	_C011		
	!BYTE	$5A,$14			; LEAVE	20
; lisp/s-expr.pla: 0733:     fin
_B154 
_B155 
; lisp/s-expr.pla: 0734:     zero32
; lisp/s-expr.pla: 0735:     while startptr <> evalptr
	!BYTE	$54			; CALL	_X029
_F171 	!WORD	0		
	!BYTE	$50			; BRNCH	_B175
	!WORD	_B175-*
_B173 
; lisp/s-expr.pla: 0736:       muli16(10); addi16(^startptr - '0')
; lisp/s-expr.pla: 0737:       startptr++
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X042
_F172 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$54			; CALL	_X036
_F173 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0738:     loop
	!BYTE	$76,$02			; SLW	[2]
_B175 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B173
	!WORD	_B173-*
_B174 
; lisp/s-expr.pla: 0739:   fin
_B139 
; lisp/s-expr.pla: 0740:   if sign; neg32; fin
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$4C			; BRFLS	_B176
	!WORD	_B176-*
	!BYTE	$54			; CALL	_X031
_F174 	!WORD	0		
_B176 
_B177 
; lisp/s-expr.pla: 0741:   store32(@int)
; lisp/s-expr.pla: 0742:   return evalptr, new_int(int[0], int[1])
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_X034
_F175 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C010
_F176 	!WORD	_C010		
	!BYTE	$5A,$14			; LEAVE	20
; lisp/s-expr.pla: 0743: end
; lisp/s-expr.pla: 0744: 
; lisp/s-expr.pla: 0745: def parse_sym(evalptr)#2 // return evalptr, symptr
					; evalptr -> [0]
_C021 					; parse_sym()
; lisp/s-expr.pla: 0746:   var symstr
					; symstr -> [2]
; lisp/s-expr.pla: 0747: 
; lisp/s-expr.pla: 0748:   symstr = evalptr - 1
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 0749:   while is_alphasym(^evalptr)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B180
	!WORD	_B180-*
_B178 
; lisp/s-expr.pla: 0750:     ^evalptr = toupper(^evalptr)
; lisp/s-expr.pla: 0751:     evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F177 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0752:   loop
	!BYTE	$76,$00			; SLW	[0]
_B180 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C019
_F178 	!WORD	_C019		
	!BYTE	$4E			; BRTRU	_B178
	!WORD	_B178-*
_B179 
; lisp/s-expr.pla: 0753:   ^symstr = evalptr - symstr - 1
; lisp/s-expr.pla: 0754:   if ^symstr > 31; ^symstr = 31; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$1F			; CB	31
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B181
	!WORD	_B181-*
	!BYTE	$2A,$1F			; CB	31
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
_B181 
_B182 
; lisp/s-expr.pla: 0755:   return evalptr, new_sym(symstr)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C015
_F179 	!WORD	_C015		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0756: end
; lisp/s-expr.pla: 0757: 
; lisp/s-expr.pla: 0758: def parse_str(evalptr)#2 // return evalptr, symptr
					; evalptr -> [0]
_C022 					; parse_str()
; lisp/s-expr.pla: 0759:   var strptr
					; strptr -> [2]
; lisp/s-expr.pla: 0760: 
; lisp/s-expr.pla: 0761:   strptr = evalptr
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 0762:   ^strptr = 0
; lisp/s-expr.pla: 0763:   evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0764:   while ^evalptr and ^evalptr <> '"'
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B185
	!WORD	_B185-*
_B183 
; lisp/s-expr.pla: 0765:     ^strptr++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0766:     evalptr++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0767:   loop
	!BYTE	$76,$00			; SLW	[0]
_B185 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$AC			; BRAND	_B186
	!WORD	_B186-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$22			; CB	34
	!BYTE	$42			; ISNE
_B186 
	!BYTE	$4E			; BRTRU	_B183
	!WORD	_B183-*
_B184 
; lisp/s-expr.pla: 0768:   return evalptr + (^evalptr ?? 1 :: 0), new_string(strptr)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B187
	!WORD	_B187-*
	!BYTE	$02			; CN	1
	!BYTE	$50			; BRNCH	_B188
	!WORD	_B188-*
_B187 
	!BYTE	$00			; CN	0
_B188 
	!BYTE	$82			; ADD 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C014
_F180 	!WORD	_C014		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0769: end
; lisp/s-expr.pla: 0770: 
; lisp/s-expr.pla: 0771: export def parse_expr(evalptr, level, refill)#2 // return evalptr, exprptr
					; evalptr -> [0]
					; level -> [2]
					; refill -> [4]
_C023 					; parse_expr()
; lisp/s-expr.pla: 0772:   var exprptr, consptr, elemptr, quotecons
					; exprptr -> [6]
					; consptr -> [8]
					; elemptr -> [10]
					; quotecons -> [12]
; lisp/s-expr.pla: 0773: 
; lisp/s-expr.pla: 0774:   exprptr = NULL
	!BYTE	$58,$0E,$03		; ENTER	14,3
; lisp/s-expr.pla: 0775:   consptr = NULL
; lisp/s-expr.pla: 0776:   while TRUE
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B191
	!WORD	_B191-*
_B189 
; lisp/s-expr.pla: 0777:     //
; lisp/s-expr.pla: 0778:     // Parse textual S-expression
; lisp/s-expr.pla: 0779:     //
; lisp/s-expr.pla: 0780:     elemptr = NULL
; lisp/s-expr.pla: 0781:     when ^evalptr
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B193-*
; lisp/s-expr.pla: 0782:       is 0   // End of line
_B194 
; lisp/s-expr.pla: 0783:       is ';' // Comment to end of line
_B195 
; lisp/s-expr.pla: 0784:         if !exprptr or level
; lisp/s-expr.pla: 0785:           evalptr = refill() // Refill input buffer
; lisp/s-expr.pla: 0786:         else
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B196
	!WORD	_B196-*
	!BYTE	$66,$02			; LLW	[2]
_B196 
	!BYTE	$4C			; BRFLS	_B197
	!WORD	_B197-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$56			; ICAL
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B198
	!WORD	_B198-*
_B197 
; lisp/s-expr.pla: 0787:           return evalptr, exprptr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-expr.pla: 0788:         fin
_B198 
; lisp/s-expr.pla: 0789:         break
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
; lisp/s-expr.pla: 0790:       is ' '
_B199 
; lisp/s-expr.pla: 0791:       is ','
_B200 
; lisp/s-expr.pla: 0792:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0793:         break
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
; lisp/s-expr.pla: 0794:       is ')'
_B201 
; lisp/s-expr.pla: 0795:         if not exprptr
; lisp/s-expr.pla: 0796:           exprptr = sym_nil
; lisp/s-expr.pla: 0797:         fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4E			; BRTRU	_B202
	!WORD	_B202-*
	!BYTE	$6A			; LAW	_D080+0
_F181 	!WORD	_D080+0		
	!BYTE	$76,$06			; SLW	[6]
_B202 
_B203 
; lisp/s-expr.pla: 0798:         return evalptr + 1, exprptr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-expr.pla: 0799:       is '('
_B204 
; lisp/s-expr.pla: 0800:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0801:         if level == 0
; lisp/s-expr.pla: 0802:           level++
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B205
	!WORD	_B205-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0803:         else
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B206
	!WORD	_B206-*
_B205 
; lisp/s-expr.pla: 0804:           evalptr, elemptr = parse_expr(evalptr, 1, refill)
; lisp/s-expr.pla: 0805:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$02			; CN	1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C023
_F182 	!WORD	_C023		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
_B206 
; lisp/s-expr.pla: 0806:         break
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
; lisp/s-expr.pla: 0807:       is '\''
_B207 
; lisp/s-expr.pla: 0808:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0809:         evalptr, elemptr    = parse_expr(evalptr, 0, refill)
; lisp/s-expr.pla: 0810:         quotecons           = new_cons
; lisp/s-expr.pla: 0811:         quotecons=>car      = sym_quote
; lisp/s-expr.pla: 0812:         quotecons=>cdr      = new_cons
; lisp/s-expr.pla: 0813:         quotecons=>cdr=>car = elemptr
; lisp/s-expr.pla: 0814:         elemptr             = quotecons
; lisp/s-expr.pla: 0815:         if level == 0
; lisp/s-expr.pla: 0816:           return evalptr, elemptr
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C023
_F183 	!WORD	_C023		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$54			; CALL	_C009
_F184 	!WORD	_C009		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$6A			; LAW	_D082+0
_F185 	!WORD	_D082+0		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C009
_F186 	!WORD	_C009		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B208
	!WORD	_B208-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-expr.pla: 0817:         fin
_B208 
_B209 
; lisp/s-expr.pla: 0818:         break
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
; lisp/s-expr.pla: 0819:       is '.'
_B210 
; lisp/s-expr.pla: 0820:         evalptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0821:         evalptr, elemptr = parse_expr(evalptr, 0, refill)
; lisp/s-expr.pla: 0822:         //
; lisp/s-expr.pla: 0823:         // Add expression to CDR
; lisp/s-expr.pla: 0824:         //
; lisp/s-expr.pla: 0825:         if not (consptr and consptr=>car)
; lisp/s-expr.pla: 0826:           err_expr = consptr
; lisp/s-expr.pla: 0827:           throw(exception, ERR_BAD_DOT)
; lisp/s-expr.pla: 0828:         fin
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C023
_F187 	!WORD	_C023		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$AC			; BRAND	_B211
	!WORD	_B211-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
_B211 
	!BYTE	$4E			; BRTRU	_B212
	!WORD	_B212-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$7A			; SAW	_D068+0
_F188 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F189 	!WORD	_D067+0		
	!BYTE	$5E,$FB			; CFFB	-5
	!BYTE	$54			; CALL	_X062
_F190 	!WORD	0		
	!BYTE	$30			; DROP 
_B212 
_B213 
; lisp/s-expr.pla: 0829:         consptr=>cdr = elemptr
; lisp/s-expr.pla: 0830:         elemptr = NULL
; lisp/s-expr.pla: 0831:         break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
; lisp/s-expr.pla: 0832:       otherwise
_B193 
	!BYTE	$08			; CASEBLOCK
	!WORD	$0000
	!WORD	_B194-*
	!WORD	$0020
	!WORD	_B199-*
	!WORD	$0027
	!WORD	_B207-*
	!WORD	$0028
	!WORD	_B204-*
	!WORD	$0029
	!WORD	_B201-*
	!WORD	$002C
	!WORD	_B200-*
	!WORD	$002E
	!WORD	_B210-*
	!WORD	$003B
	!WORD	_B195-*
; lisp/s-expr.pla: 0833:         if is_num(evalptr)
; lisp/s-expr.pla: 0834:           evalptr, elemptr = parse_num(evalptr)
; lisp/s-expr.pla: 0835:         elsif is_alphasym(^evalptr)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C018
_F191 	!WORD	_C018		
	!BYTE	$4C			; BRFLS	_B214
	!WORD	_B214-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C020
_F192 	!WORD	_C020		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B215
	!WORD	_B215-*
_B214 
; lisp/s-expr.pla: 0836:           evalptr, elemptr = parse_sym(evalptr)
; lisp/s-expr.pla: 0837:         elsif ^evalptr == '"'
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C019
_F193 	!WORD	_C019		
	!BYTE	$4C			; BRFLS	_B216
	!WORD	_B216-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C021
_F194 	!WORD	_C021		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B215
	!WORD	_B215-*
_B216 
; lisp/s-expr.pla: 0838:           evalptr, elemptr = parse_str(evalptr)
; lisp/s-expr.pla: 0839:         else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$22			; CB	34
	!BYTE	$24			; BRNE	_B217
	!WORD	_B217-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C022
_F195 	!WORD	_C022		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B215
	!WORD	_B215-*
_B217 
; lisp/s-expr.pla: 0840:           putc('\\')
; lisp/s-expr.pla: 0841:           putc(^evalptr)
; lisp/s-expr.pla: 0842:           evalptr++
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$54			; CALL	_X002
_F196 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X002
_F197 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0843:         fin
	!BYTE	$76,$00			; SLW	[0]
_B215 
; lisp/s-expr.pla: 0844:         if level == 0
; lisp/s-expr.pla: 0845:           return evalptr, elemptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B218
	!WORD	_B218-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-expr.pla: 0846:         fin
_B218 
_B219 
; lisp/s-expr.pla: 0847:     wend
_B192 
; lisp/s-expr.pla: 0848:     if elemptr
; lisp/s-expr.pla: 0849:       //
; lisp/s-expr.pla: 0850:       // Add element to S-expression
; lisp/s-expr.pla: 0851:       //
; lisp/s-expr.pla: 0852:       if not consptr
; lisp/s-expr.pla: 0853:         consptr = new_cons
; lisp/s-expr.pla: 0854:         exprptr = consptr
; lisp/s-expr.pla: 0855:       else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$4C			; BRFLS	_B220
	!WORD	_B220-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4E			; BRTRU	_B222
	!WORD	_B222-*
	!BYTE	$54			; CALL	_C009
_F198 	!WORD	_C009		
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B223
	!WORD	_B223-*
_B222 
; lisp/s-expr.pla: 0856:         if consptr=>cdr
; lisp/s-expr.pla: 0857:           err_expr = consptr
; lisp/s-expr.pla: 0858:           throw(exception, ERR_BAD_DOT)
; lisp/s-expr.pla: 0859:         fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B224
	!WORD	_B224-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$7A			; SAW	_D068+0
_F199 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F200 	!WORD	_D067+0		
	!BYTE	$5E,$FB			; CFFB	-5
	!BYTE	$54			; CALL	_X062
_F201 	!WORD	0		
	!BYTE	$30			; DROP 
_B224 
_B225 
; lisp/s-expr.pla: 0860:         consptr=>cdr = new_cons
; lisp/s-expr.pla: 0861:         consptr      = consptr=>cdr
; lisp/s-expr.pla: 0862:       fin
	!BYTE	$54			; CALL	_C009
_F202 	!WORD	_C009		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B223 
; lisp/s-expr.pla: 0863:       //
; lisp/s-expr.pla: 0864:       // Add element to CAR
; lisp/s-expr.pla: 0865:       //
; lisp/s-expr.pla: 0866:       consptr=>car = elemptr
; lisp/s-expr.pla: 0867:     fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
_B220 
_B221 
; lisp/s-expr.pla: 0868:   loop
_B191 
	!BYTE	$50			; BRNCH	_B189
	!WORD	_B189-*
_B190 
; lisp/s-expr.pla: 0869:   return evalptr, exprptr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$0E			; LEAVE	14
; lisp/s-expr.pla: 0870: end
; lisp/s-expr.pla: 0871: 
; lisp/s-expr.pla: 0872: //
; lisp/s-expr.pla: 0873: // Build/set association between symbols and values
; lisp/s-expr.pla: 0874: //
; lisp/s-expr.pla: 0875: 
; lisp/s-expr.pla: 0876: def new_assoc(symptr, valptr)#0
					; symptr -> [0]
					; valptr -> [2]
_C024 					; new_assoc()
; lisp/s-expr.pla: 0877:   var pair, pairlist
					; pair -> [4]
					; pairlist -> [6]
; lisp/s-expr.pla: 0878: 
; lisp/s-expr.pla: 0879:   if symptr and (symptr->type & TYPE_MASK <> SYM_TYPE)
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-expr.pla: 0880:     err_expr = symptr
; lisp/s-expr.pla: 0881:     throw(exception, ERR_NOT_SYM)
; lisp/s-expr.pla: 0882:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B226
	!WORD	_B226-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$42			; ISNE
_B226 
	!BYTE	$4C			; BRFLS	_B227
	!WORD	_B227-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F203 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F204 	!WORD	_D067+0		
	!BYTE	$5E,$FA			; CFFB	-6
	!BYTE	$54			; CALL	_X062
_F205 	!WORD	0		
	!BYTE	$30			; DROP 
_B227 
_B228 
; lisp/s-expr.pla: 0883:   pair          = new_cons
; lisp/s-expr.pla: 0884:   pair=>car     = symptr
; lisp/s-expr.pla: 0885:   pair=>cdr     = valptr
; lisp/s-expr.pla: 0886:   pairlist      = new_cons
; lisp/s-expr.pla: 0887:   pairlist=>car = pair
; lisp/s-expr.pla: 0888:   pairlist=>cdr = assoc_list
; lisp/s-expr.pla: 0889:   assoc_list    = pairlist
; lisp/s-expr.pla: 0890:   if trace
; lisp/s-expr.pla: 0891:     puts("\n New ASSOC:"); print_expr(pair); putln
	!BYTE	$54			; CALL	_C009
_F206 	!WORD	_C009		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C009
_F207 	!WORD	_C009		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D070+0
_F208 	!WORD	_D070+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$7A			; SAW	_D070+0
_F209 	!WORD	_D070+0		
	!BYTE	$68			; LAB	_D066+0
_F210 	!WORD	_D066+0		
	!BYTE	$4C			; BRFLS	_B229
	!WORD	_B229-*
	!BYTE	$2E			; CS
	!BYTE	$0C
	!BYTE	$0D,$20,$4E,$65,$77,$20,$41,$53
	!BYTE	$53,$4F,$43,$3A
	!BYTE	$54			; CALL	_X004
_F211 	!WORD	0		
; lisp/s-expr.pla: 0892:   fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C017
_F212 	!WORD	_C017		
	!BYTE	$54			; CALL	_X003
_F213 	!WORD	0		
_B229 
_B230 
; lisp/s-expr.pla: 0893: end
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-expr.pla: 0894: 
; lisp/s-expr.pla: 0895: def assoc_pair(symptr)
					; symptr -> [0]
_C025 					; assoc_pair()
; lisp/s-expr.pla: 0896:   var pair
					; pair -> [2]
; lisp/s-expr.pla: 0897: 
; lisp/s-expr.pla: 0898:   //
; lisp/s-expr.pla: 0899:   // Search local association list for symbol
; lisp/s-expr.pla: 0900:   //
; lisp/s-expr.pla: 0901:   pair = assoc_list
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 0902:   while pair
	!BYTE	$6A			; LAW	_D070+0
_F214 	!WORD	_D070+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B233
	!WORD	_B233-*
_B231 
; lisp/s-expr.pla: 0903:     if (pair=>car=>car == symptr)
; lisp/s-expr.pla: 0904:       return pair=>car
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B234
	!WORD	_B234-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0905:     fin
_B234 
_B235 
; lisp/s-expr.pla: 0906:     pair = pair=>cdr
; lisp/s-expr.pla: 0907:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B233 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B231
	!WORD	_B231-*
_B232 
; lisp/s-expr.pla: 0908:   return NULL // SYM not associated
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0909: end
; lisp/s-expr.pla: 0910: 
; lisp/s-expr.pla: 0911: def set_assoc(symptr, valptr)#1
					; symptr -> [0]
					; valptr -> [2]
_C026 					; set_assoc()
; lisp/s-expr.pla: 0912:   var pair
					; pair -> [4]
; lisp/s-expr.pla: 0913: 
; lisp/s-expr.pla: 0914:   //
; lisp/s-expr.pla: 0915:   // Search association list for symbol
; lisp/s-expr.pla: 0916:   //
; lisp/s-expr.pla: 0917:   pair = assoc_pair(symptr)
	!BYTE	$58,$06,$02		; ENTER	6,2
; lisp/s-expr.pla: 0918:   if pair
; lisp/s-expr.pla: 0919:     pair=>cdr = valptr // Update association
; lisp/s-expr.pla: 0920:   else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C025
_F215 	!WORD	_C025		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B236
	!WORD	_B236-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B237
	!WORD	_B237-*
_B236 
; lisp/s-expr.pla: 0921:     err_expr = symptr
; lisp/s-expr.pla: 0922:     throw(exception, ERR_NOT_ASSOC)
; lisp/s-expr.pla: 0923:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F216 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F217 	!WORD	_D067+0		
	!BYTE	$5E,$F9			; CFFB	-7
	!BYTE	$54			; CALL	_X062
_F218 	!WORD	0		
	!BYTE	$30			; DROP 
_B237 
; lisp/s-expr.pla: 0924:   return pair
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0925: end
; lisp/s-expr.pla: 0926: 
; lisp/s-expr.pla: 0927: def assoc(symptr)
					; symptr -> [0]
_C027 					; assoc()
; lisp/s-expr.pla: 0928:   var pair
					; pair -> [2]
; lisp/s-expr.pla: 0929: 
; lisp/s-expr.pla: 0930:   //
; lisp/s-expr.pla: 0931:   // Search local association list for symbol
; lisp/s-expr.pla: 0932:   //
; lisp/s-expr.pla: 0933:   pair = assoc_list
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 0934:   while pair
	!BYTE	$6A			; LAW	_D070+0
_F219 	!WORD	_D070+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B240
	!WORD	_B240-*
_B238 
; lisp/s-expr.pla: 0935:     if (pair=>car=>car == symptr)
; lisp/s-expr.pla: 0936:       return pair=>car=>cdr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B241
	!WORD	_B241-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0937:     fin
_B241 
_B242 
; lisp/s-expr.pla: 0938:     pair = pair=>cdr
; lisp/s-expr.pla: 0939:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B240 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B238
	!WORD	_B238-*
_B239 
; lisp/s-expr.pla: 0940:   return NULL // SYM not associated
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0941: end
; lisp/s-expr.pla: 0942: 
; lisp/s-expr.pla: 0943: //
; lisp/s-expr.pla: 0944: // Evaluate expression
; lisp/s-expr.pla: 0945: //
; lisp/s-expr.pla: 0946: 
; lisp/s-expr.pla: 0947: def eval_args(argvals)
					; argvals -> [0]
_C028 					; eval_args()
; lisp/s-expr.pla: 0948:   var argstart
					; argstart -> [2]
; lisp/s-expr.pla: 0949: 
; lisp/s-expr.pla: 0950:   //
; lisp/s-expr.pla: 0951:   // Evaluate the argument parameters
; lisp/s-expr.pla: 0952:   // - manipulate sweep_stack directly for performance
; lisp/s-expr.pla: 0953:   //
; lisp/s-expr.pla: 0954:   argstart = sweep_stack_top
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 0955:   while argvals
	!BYTE	$68			; LAB	_D096+0
_F220 	!WORD	_D096+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B245
	!WORD	_B245-*
_B243 
; lisp/s-expr.pla: 0956:     sweep_stack[sweep_stack_top] = eval_expr(argvals=>car)
; lisp/s-expr.pla: 0957:     sweep_stack_top++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_P001
_F221 	!WORD	_P001		
	!BYTE	$26			; LA	_D097+0
_F222 	!WORD	_D097+0		
	!BYTE	$BC			; IDXAB	_D096+0
_F223 	!WORD	_D096+0		
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D096+0
_F224 	!WORD	_D096+0		
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0958:     if sweep_stack_top >= SWEEPSTACK_MAX
; lisp/s-expr.pla: 0959:       err_expr = argvals
; lisp/s-expr.pla: 0960:       throw(exception, ERR_SWEEP_OVRFLW)
; lisp/s-expr.pla: 0961:     fin
	!BYTE	$7C			; DAB	_D096+0
_F225 	!WORD	_D096+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B246
	!WORD	_B246-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F226 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F227 	!WORD	_D067+0		
	!BYTE	$5E,$FD			; CFFB	-3
	!BYTE	$54			; CALL	_X062
_F228 	!WORD	0		
	!BYTE	$30			; DROP 
_B246 
_B247 
; lisp/s-expr.pla: 0962:     argvals = argvals=>cdr
; lisp/s-expr.pla: 0963:   loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B245 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B243
	!WORD	_B243-*
_B244 
; lisp/s-expr.pla: 0964:   sweep_stack_top = argstart
; lisp/s-expr.pla: 0965:   return sweep_stack_top
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7C			; DAB	_D096+0
_F229 	!WORD	_D096+0		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 0966: end
; lisp/s-expr.pla: 0967: 
; lisp/s-expr.pla: 0968: def set_args(argsyms, argbase)#0
					; argsyms -> [0]
					; argbase -> [2]
_C029 					; set_args()
; lisp/s-expr.pla: 0969:   var arglist
					; arglist -> [4]
; lisp/s-expr.pla: 0970: 
; lisp/s-expr.pla: 0971:   if argsyms == sym_nil; return; fin
	!BYTE	$58,$06,$02		; ENTER	6,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D080+0
_F230 	!WORD	_D080+0		
	!BYTE	$24			; BRNE	_B248
	!WORD	_B248-*
	!BYTE	$5A,$06			; LEAVE	6
_B248 
_B249 
; lisp/s-expr.pla: 0972:   arglist = assoc_list
; lisp/s-expr.pla: 0973:   while argsyms
	!BYTE	$6A			; LAW	_D070+0
_F231 	!WORD	_D070+0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B252
	!WORD	_B252-*
_B250 
; lisp/s-expr.pla: 0974:     arglist=>car=>cdr = sweep_stack[argbase]
; lisp/s-expr.pla: 0975:     arglist           = arglist=>cdr
; lisp/s-expr.pla: 0976:     argsyms           = argsyms=>cdr
; lisp/s-expr.pla: 0977:     argbase++
	!BYTE	$26			; LA	_D097+0
_F232 	!WORD	_D097+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 0978:   loop
	!BYTE	$76,$02			; SLW	[2]
_B252 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B250
	!WORD	_B250-*
_B251 
; lisp/s-expr.pla: 0979: end
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 0980: 
; lisp/s-expr.pla: 0981: def pair_args(argsyms, argbase)#0
					; argsyms -> [0]
					; argbase -> [2]
_C030 					; pair_args()
; lisp/s-expr.pla: 0982:   var arglist, pairlist
					; arglist -> [4]
					; pairlist -> [6]
; lisp/s-expr.pla: 0983: 
; lisp/s-expr.pla: 0984:   if argsyms == sym_nil; return; fin
	!BYTE	$58,$08,$02		; ENTER	8,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D080+0
_F233 	!WORD	_D080+0		
	!BYTE	$24			; BRNE	_B253
	!WORD	_B253-*
	!BYTE	$5A,$08			; LEAVE	8
_B253 
_B254 
; lisp/s-expr.pla: 0985:   arglist = NULL
; lisp/s-expr.pla: 0986:   while argsyms
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B257
	!WORD	_B257-*
_B255 
; lisp/s-expr.pla: 0987:     //
; lisp/s-expr.pla: 0988:     // Build argument/value pairs
; lisp/s-expr.pla: 0989:     //
; lisp/s-expr.pla: 0990:     if arglist
; lisp/s-expr.pla: 0991:       pairlist=>cdr = new_cons
; lisp/s-expr.pla: 0992:       pairlist      = pairlist=>cdr
; lisp/s-expr.pla: 0993:     else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B258
	!WORD	_B258-*
	!BYTE	$54			; CALL	_C009
_F234 	!WORD	_C009		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B259
	!WORD	_B259-*
_B258 
; lisp/s-expr.pla: 0994:       arglist  = new_cons
; lisp/s-expr.pla: 0995:       pairlist = arglist
; lisp/s-expr.pla: 0996:     fin
	!BYTE	$54			; CALL	_C009
_F235 	!WORD	_C009		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$76,$06			; SLW	[6]
_B259 
; lisp/s-expr.pla: 0997:     pairlist=>car      = new_cons
; lisp/s-expr.pla: 0998:     pairlist=>car=>car = argsyms=>car
; lisp/s-expr.pla: 0999:     pairlist=>car=>cdr = sweep_stack[argbase]
; lisp/s-expr.pla: 1000:     argsyms            = argsyms=>cdr
; lisp/s-expr.pla: 1001:     argbase++
	!BYTE	$54			; CALL	_C009
_F236 	!WORD	_C009		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D097+0
_F237 	!WORD	_D097+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 1002:   loop
	!BYTE	$76,$02			; SLW	[2]
_B257 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B255
	!WORD	_B255-*
_B256 
; lisp/s-expr.pla: 1003:   pairlist=>cdr = assoc_list
; lisp/s-expr.pla: 1004:   assoc_list    = arglist
; lisp/s-expr.pla: 1005: end
	!BYTE	$6A			; LAW	_D070+0
_F238 	!WORD	_D070+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D070+0
_F239 	!WORD	_D070+0		
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-expr.pla: 1006: 
; lisp/s-expr.pla: 1007: def apply_funargs(funarg, argvals)
					; funarg -> [0]
					; argvals -> [2]
_C031 					; apply_funargs()
; lisp/s-expr.pla: 1008:   var funexpr, argbase, funalist
					; funexpr -> [4]
					; argbase -> [6]
					; funalist -> [8]
; lisp/s-expr.pla: 1009: 
; lisp/s-expr.pla: 1010:   funexpr = funarg=>cdr=>car // Lambda expression
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-expr.pla: 1011:   if funexpr->type <> CONS_TYPE
; lisp/s-expr.pla: 1012:     return funexpr=>natv(funexpr, argvals) // Native function
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$22			; BREQ	_B260
	!WORD	_B260-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-expr.pla: 1013:   fin
_B260 
_B261 
; lisp/s-expr.pla: 1014:   //
; lisp/s-expr.pla: 1015:   // Build arg list before prepending to new assoc_list
; lisp/s-expr.pla: 1016:   //
; lisp/s-expr.pla: 1017:   push_sweep_stack(assoc_list) // Save current association list
; lisp/s-expr.pla: 1018:   argbase    = eval_args(argvals)
; lisp/s-expr.pla: 1019:   funalist   = funarg=>cdr=>cdr
; lisp/s-expr.pla: 1020:   assoc_list = funalist=>car // Swap association list pointer
; lisp/s-expr.pla: 1021:   pair_args(funexpr=>cdr=>car, argbase)
; lisp/s-expr.pla: 1022:   funexpr       = eval_expr(funexpr=>cdr=>cdr=>car)
; lisp/s-expr.pla: 1023:   funalist=>car = assoc_list      // Save updated FUNARG associations
; lisp/s-expr.pla: 1024:   assoc_list    = pop_sweep_stack // Restore association list
; lisp/s-expr.pla: 1025:   return funexpr
	!BYTE	$6A			; LAW	_D070+0
_F240 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C003
_F241 	!WORD	_C003		
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C028
_F242 	!WORD	_C028		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D070+0
_F243 	!WORD	_D070+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C030
_F244 	!WORD	_C030		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_P001
_F245 	!WORD	_P001		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_D070+0
_F246 	!WORD	_D070+0		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C004
_F247 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D070+0
_F248 	!WORD	_D070+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-expr.pla: 1026: end
; lisp/s-expr.pla: 1027: 
; lisp/s-expr.pla: 1028: def eval_atom(atom)#1
					; atom -> [0]
_C032 					; eval_atom()
; lisp/s-expr.pla: 1029:   //
; lisp/s-expr.pla: 1030:   // Atom - return the symbol value or the atom itself
; lisp/s-expr.pla: 1031:   //
; lisp/s-expr.pla: 1032:   if atom and atom->type & TYPE_MASK == SYM_TYPE
	!BYTE	$58,$02,$01		; ENTER	2,1
; lisp/s-expr.pla: 1033:     if atom=>lambda // DEFINEd lambda S-expression
; lisp/s-expr.pla: 1034:       return atom=>lambda
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B262
	!WORD	_B262-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$40			; ISEQ
_B262 
	!BYTE	$4C			; BRFLS	_B263
	!WORD	_B263-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B265
	!WORD	_B265-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1035:     fin
_B265 
_B266 
; lisp/s-expr.pla: 1036:     if atom=>apval // Constant
; lisp/s-expr.pla: 1037:       return atom=>apval ^ NULL_HACK
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B267
	!WORD	_B267-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1038:     fin
_B267 
_B268 
; lisp/s-expr.pla: 1039:     if atom=>array // Array
; lisp/s-expr.pla: 1040:       return atom=>array
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B269
	!WORD	_B269-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1041:     fin // Look on the association list last
_B269 
_B270 
; lisp/s-expr.pla: 1042:     return assoc(atom)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C027
_F249 	!WORD	_C027		
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1043:   fin
_B263 
_B264 
; lisp/s-expr.pla: 1044:   return atom
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1045: end
; lisp/s-expr.pla: 1046: 
; lisp/s-expr.pla: 1047: export def eval_expr(expr)#1
					; expr -> [0]
_P001 					; eval_expr(expr)#1()
_C033 					; eval_expr()
; lisp/s-expr.pla: 1048:   var alist_enter, curl, func, args
					; alist_enter -> [2]
					; curl -> [4]
					; func -> [6]
					; args -> [8]
; lisp/s-expr.pla: 1049: 
; lisp/s-expr.pla: 1050:   if expr
	!BYTE	$58,$0A,$01		; ENTER	10,1
; lisp/s-expr.pla: 1051:     if expr->type <> CONS_TYPE; return eval_atom(expr); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B271
	!WORD	_B271-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$22			; BREQ	_B273
	!WORD	_B273-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C032
_F250 	!WORD	_C032		
	!BYTE	$5A,$0A			; LEAVE	10
_B273 
_B274 
; lisp/s-expr.pla: 1052:     if hook_eval; expr = hook_eval(expr); fin
	!BYTE	$6A			; LAW	_D069+0
_F251 	!WORD	_D069+0		
	!BYTE	$4C			; BRFLS	_B275
	!WORD	_B275-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D069+0
_F252 	!WORD	_D069+0		
	!BYTE	$56			; ICAL
	!BYTE	$76,$00			; SLW	[0]
_B275 
_B276 
; lisp/s-expr.pla: 1053:     if gc_pull > gc_trigger; gc; fin
	!BYTE	$6A			; LAW	_D099+0
_F253 	!WORD	_D099+0		
	!BYTE	$6A			; LAW	_D098+0
_F254 	!WORD	_D098+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B277
	!WORD	_B277-*
	!BYTE	$54			; CALL	_C007
_F255 	!WORD	_C007		
_B277 
_B278 
; lisp/s-expr.pla: 1054:     alist_enter = assoc_list
; lisp/s-expr.pla: 1055:     curl        = NULL // Current lambda
; lisp/s-expr.pla: 1056:     while expr
	!BYTE	$6A			; LAW	_D070+0
_F256 	!WORD	_D070+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B281
	!WORD	_B281-*
_B279 
; lisp/s-expr.pla: 1057:       if expr->type == CONS_TYPE
; lisp/s-expr.pla: 1058:         //
; lisp/s-expr.pla: 1059:         // List - first element better be a function
; lisp/s-expr.pla: 1060:         //
; lisp/s-expr.pla: 1061:         func = expr=>car
; lisp/s-expr.pla: 1062:         args = expr=>cdr
; lisp/s-expr.pla: 1063:         if func->type & TYPE_MASK == SYM_TYPE
; lisp/s-expr.pla: 1064:           if func=>natv
; lisp/s-expr.pla: 1065:             expr = func=>natv(func, args) // Native function
; lisp/s-expr.pla: 1066:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B282
	!WORD	_B282-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B284
	!WORD	_B284-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B286
	!WORD	_B286-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B280
	!WORD	_B280-*
; lisp/s-expr.pla: 1067:           elsif func == sym_cond // Inline cond() evaluation
	!BYTE	$50			; BRNCH	_B287
	!WORD	_B287-*
_B286 
; lisp/s-expr.pla: 1068:             while args
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D087+0
_F257 	!WORD	_D087+0		
	!BYTE	$24			; BRNE	_B288
	!WORD	_B288-*
	!BYTE	$50			; BRNCH	_B291
	!WORD	_B291-*
_B289 
; lisp/s-expr.pla: 1069:               if eval_expr(args=>car=>car)
; lisp/s-expr.pla: 1070:                 expr = args=>car=>cdr=>car
; lisp/s-expr.pla: 1071:                 break
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F258 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B292
	!WORD	_B292-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B290
	!WORD	_B290-*
; lisp/s-expr.pla: 1072:               fin
_B292 
_B293 
; lisp/s-expr.pla: 1073:               args = args=>cdr
; lisp/s-expr.pla: 1074:             loop
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B291 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4E			; BRTRU	_B289
	!WORD	_B289-*
_B290 
; lisp/s-expr.pla: 1075:           elsif func == sym_if // Inline if() evaluation
	!BYTE	$50			; BRNCH	_B287
	!WORD	_B287-*
_B288 
; lisp/s-expr.pla: 1076:             if eval_expr(args=>car)
; lisp/s-expr.pla: 1077:               expr = args=>cdr=>car // THEN clause
; lisp/s-expr.pla: 1078:             else
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D088+0
_F259 	!WORD	_D088+0		
	!BYTE	$24			; BRNE	_B294
	!WORD	_B294-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F260 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B295
	!WORD	_B295-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B296
	!WORD	_B296-*
_B295 
; lisp/s-expr.pla: 1079:               expr = args=>cdr=>cdr
; lisp/s-expr.pla: 1080:               if expr // Check for ELSE clause
; lisp/s-expr.pla: 1081:                 expr = expr=>car
; lisp/s-expr.pla: 1082:               fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B297
	!WORD	_B297-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B297 
_B298 
; lisp/s-expr.pla: 1083:             fin
_B296 
; lisp/s-expr.pla: 1084:           else // Associated symbol
	!BYTE	$50			; BRNCH	_B287
	!WORD	_B287-*
_B294 
; lisp/s-expr.pla: 1085:             func = eval_atom(func)
; lisp/s-expr.pla: 1086:             if !func or func->type <> CONS_TYPE
; lisp/s-expr.pla: 1087:               err_expr = expr
; lisp/s-expr.pla: 1088:               throw(exception, ERR_NOT_FUN)
; lisp/s-expr.pla: 1089:             fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C032
_F261 	!WORD	_C032		
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B299
	!WORD	_B299-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$42			; ISNE
_B299 
	!BYTE	$4C			; BRFLS	_B300
	!WORD	_B300-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F262 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F263 	!WORD	_D067+0		
	!BYTE	$5E,$F8			; CFFB	-8
	!BYTE	$54			; CALL	_X062
_F264 	!WORD	0		
	!BYTE	$30			; DROP 
_B300 
_B301 
; lisp/s-expr.pla: 1090:           fin
_B287 
; lisp/s-expr.pla: 1091:         else
	!BYTE	$50			; BRNCH	_B285
	!WORD	_B285-*
_B284 
; lisp/s-expr.pla: 1092:           curl = NULL // Set-up for in-line function
; lisp/s-expr.pla: 1093:         fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
_B285 
; lisp/s-expr.pla: 1094:         if func->type == CONS_TYPE
; lisp/s-expr.pla: 1095:           if func=>car == sym_label // LABEL
; lisp/s-expr.pla: 1096:             new_assoc(func=>cdr=>car, func=>cdr=>cdr=>car) // Add LABEL
; lisp/s-expr.pla: 1097:             func = func=>cdr=>cdr=>car  // Continue evaluating LAMBDA
; lisp/s-expr.pla: 1098:           fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B302
	!WORD	_B302-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D089+0
_F265 	!WORD	_D089+0		
	!BYTE	$24			; BRNE	_B304
	!WORD	_B304-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C024
_F266 	!WORD	_C024		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B304 
_B305 
; lisp/s-expr.pla: 1099:           if func=>car == sym_lambda // LAMBDA
; lisp/s-expr.pla: 1100:             if curl == func // Tail recursion: overwrite associations
; lisp/s-expr.pla: 1101:               set_args(func=>cdr=>car, eval_args(args))
; lisp/s-expr.pla: 1102:             else // Add argument association pair list
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D083+0
_F267 	!WORD	_D083+0		
	!BYTE	$24			; BRNE	_B306
	!WORD	_B306-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$24			; BRNE	_B308
	!WORD	_B308-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C028
_F268 	!WORD	_C028		
	!BYTE	$54			; CALL	_C029
_F269 	!WORD	_C029		
	!BYTE	$50			; BRNCH	_B309
	!WORD	_B309-*
_B308 
; lisp/s-expr.pla: 1103:               pair_args(func=>cdr=>car, eval_args(args))
; lisp/s-expr.pla: 1104:               curl = func
; lisp/s-expr.pla: 1105:             fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C028
_F270 	!WORD	_C028		
	!BYTE	$54			; CALL	_C030
_F271 	!WORD	_C030		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$76,$04			; SLW	[4]
_B309 
; lisp/s-expr.pla: 1106:             expr = func=>cdr=>cdr=>car
; lisp/s-expr.pla: 1107:           elsif func=>car == sym_funarg // FUNARG
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B307
	!WORD	_B307-*
_B306 
; lisp/s-expr.pla: 1108:             expr = apply_funargs(func, expr=>cdr)
; lisp/s-expr.pla: 1109:             break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D084+0
_F272 	!WORD	_D084+0		
	!BYTE	$24			; BRNE	_B310
	!WORD	_B310-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C031
_F273 	!WORD	_C031		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B280
	!WORD	_B280-*
; lisp/s-expr.pla: 1110:           elsif func=>car == sym_macro // MACRO
	!BYTE	$50			; BRNCH	_B307
	!WORD	_B307-*
_B310 
; lisp/s-expr.pla: 1111:             new_assoc(func=>cdr=>car=>car, args) // Add args list argument
; lisp/s-expr.pla: 1112:             curl = NULL
; lisp/s-expr.pla: 1113:             expr = func=>cdr=>cdr=>car
; lisp/s-expr.pla: 1114:           else
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D086+0
_F274 	!WORD	_D086+0		
	!BYTE	$24			; BRNE	_B311
	!WORD	_B311-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C024
_F275 	!WORD	_C024		
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B307
	!WORD	_B307-*
_B311 
; lisp/s-expr.pla: 1115:             err_expr = expr
; lisp/s-expr.pla: 1116:             throw(exception, ERR_NOT_FUN)
; lisp/s-expr.pla: 1117:           fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F276 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F277 	!WORD	_D067+0		
	!BYTE	$5E,$F8			; CFFB	-8
	!BYTE	$54			; CALL	_X062
_F278 	!WORD	0		
	!BYTE	$30			; DROP 
_B307 
; lisp/s-expr.pla: 1118:           if trace
; lisp/s-expr.pla: 1119:             puts("\nTRACE:"); print_expr(func)
	!BYTE	$68			; LAB	_D066+0
_F279 	!WORD	_D066+0		
	!BYTE	$4C			; BRFLS	_B312
	!WORD	_B312-*
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$0D,$54,$52,$41,$43,$45,$3A
	!BYTE	$54			; CALL	_X004
_F280 	!WORD	0		
; lisp/s-expr.pla: 1120:             puts("\n ASSOC:"); print_expr(assoc_list); putln
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C017
_F281 	!WORD	_C017		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$20,$41,$53,$53,$4F,$43,$3A
	!BYTE	$54			; CALL	_X004
_F282 	!WORD	0		
; lisp/s-expr.pla: 1121:           fin
	!BYTE	$6A			; LAW	_D070+0
_F283 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C017
_F284 	!WORD	_C017		
	!BYTE	$54			; CALL	_X003
_F285 	!WORD	0		
_B312 
_B313 
; lisp/s-expr.pla: 1122:         fin
_B302 
_B303 
; lisp/s-expr.pla: 1123:       else
	!BYTE	$50			; BRNCH	_B283
	!WORD	_B283-*
_B282 
; lisp/s-expr.pla: 1124:         expr = eval_atom(expr)
; lisp/s-expr.pla: 1125:         break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C032
_F286 	!WORD	_C032		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B280
	!WORD	_B280-*
; lisp/s-expr.pla: 1126:       fin
_B283 
; lisp/s-expr.pla: 1127:     loop
_B281 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B279
	!WORD	_B279-*
_B280 
; lisp/s-expr.pla: 1128:     assoc_list = alist_enter // Unwind assoc_list
; lisp/s-expr.pla: 1129:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D070+0
_F287 	!WORD	_D070+0		
_B271 
_B272 
; lisp/s-expr.pla: 1130:   return expr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-expr.pla: 1131: end
; lisp/s-expr.pla: 1132: 
; lisp/s-expr.pla: 1133: export def eval_quote(expr)#1
					; expr -> [0]
_C034 					; eval_quote()
; lisp/s-expr.pla: 1134:   assoc_list      = NULL
	!BYTE	$58,$02,$01		; ENTER	2,1
; lisp/s-expr.pla: 1135:   sweep_stack_top = 0
; lisp/s-expr.pla: 1136:   push_sweep_stack(expr) // Keep expr from being GC'ed
; lisp/s-expr.pla: 1137:   expr = eval_expr(expr)
; lisp/s-expr.pla: 1138:   pop_sweep_stack
; lisp/s-expr.pla: 1139:   return expr
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D070+0
_F288 	!WORD	_D070+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D096+0
_F289 	!WORD	_D096+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C003
_F290 	!WORD	_C003		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C033
_F291 	!WORD	_C033		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$54			; CALL	_C004
_F292 	!WORD	_C004		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1140: end
; lisp/s-expr.pla: 1141: 
; lisp/s-expr.pla: 1142: //
; lisp/s-expr.pla: 1143: // Make a copy of an expr
; lisp/s-expr.pla: 1144: //
; lisp/s-expr.pla: 1145: 
; lisp/s-expr.pla: 1146: def copy_expr(expr)
					; expr -> [0]
_C035 					; copy_expr()
; lisp/s-expr.pla: 1147:   var copy
					; copy -> [2]
; lisp/s-expr.pla: 1148: 
; lisp/s-expr.pla: 1149:   if expr and expr->type == CONS_TYPE
	!BYTE	$58,$04,$01		; ENTER	4,1
; lisp/s-expr.pla: 1150:     //
; lisp/s-expr.pla: 1151:     // Copy cons structure
; lisp/s-expr.pla: 1152:     //
; lisp/s-expr.pla: 1153:     copy = push_sweep_stack(new_cons)
; lisp/s-expr.pla: 1154:     while expr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B314
	!WORD	_B314-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$40			; ISEQ
_B314 
	!BYTE	$4C			; BRFLS	_B315
	!WORD	_B315-*
	!BYTE	$54			; CALL	_C009
_F293 	!WORD	_C009		
	!BYTE	$54			; CALL	_C003
_F294 	!WORD	_C003		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B319
	!WORD	_B319-*
_B317 
; lisp/s-expr.pla: 1155:       if expr=>car and expr=>car->type == CONS_TYPE
; lisp/s-expr.pla: 1156:         copy=>car = copy_expr(expr=>car)
; lisp/s-expr.pla: 1157:       else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$AC			; BRAND	_B320
	!WORD	_B320-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$40			; ISEQ
_B320 
	!BYTE	$4C			; BRFLS	_B321
	!WORD	_B321-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C035
_F295 	!WORD	_C035		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B322
	!WORD	_B322-*
_B321 
; lisp/s-expr.pla: 1158:         copy=>car = expr=>car
; lisp/s-expr.pla: 1159:       fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
_B322 
; lisp/s-expr.pla: 1160:       if expr=>cdr and expr=>cdr->type == CONS_TYPE
; lisp/s-expr.pla: 1161:         copy=>cdr = new_cons
; lisp/s-expr.pla: 1162:         copy = copy=>cdr
; lisp/s-expr.pla: 1163:         expr = expr=>cdr
; lisp/s-expr.pla: 1164:       else // End of list
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$AC			; BRAND	_B323
	!WORD	_B323-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$40			; ISEQ
_B323 
	!BYTE	$4C			; BRFLS	_B324
	!WORD	_B324-*
	!BYTE	$54			; CALL	_C009
_F296 	!WORD	_C009		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B325
	!WORD	_B325-*
_B324 
; lisp/s-expr.pla: 1165:         copy=>cdr = expr=>cdr
; lisp/s-expr.pla: 1166:         expr = NULL
; lisp/s-expr.pla: 1167:       fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B325 
; lisp/s-expr.pla: 1168:     loop
_B319 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B317
	!WORD	_B317-*
_B318 
; lisp/s-expr.pla: 1169:     return pop_sweep_stack
	!BYTE	$54			; CALL	_C004
_F297 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1170:   fin
_B315 
_B316 
; lisp/s-expr.pla: 1171:   return expr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1172: end
; lisp/s-expr.pla: 1173: 
; lisp/s-expr.pla: 1174: //
; lisp/s-expr.pla: 1175: // Base native functions
; lisp/s-expr.pla: 1176: //
; lisp/s-expr.pla: 1177: 
; lisp/s-expr.pla: 1178: export def bool_pred(bool)
					; bool -> [0]
_C036 					; bool_pred()
; lisp/s-expr.pla: 1179:   return bool ?? sym_true :: NULL
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B326
	!WORD	_B326-*
	!BYTE	$6A			; LAW	_D081+0
_F298 	!WORD	_D081+0		
	!BYTE	$50			; BRNCH	_B327
	!WORD	_B327-*
_B326 
	!BYTE	$00			; CN	0
_B327 
	!BYTE	$5A,$02			; LEAVE	2
; lisp/s-expr.pla: 1180: end
; lisp/s-expr.pla: 1181: 
; lisp/s-expr.pla: 1182: def natv_atom(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C037 					; natv_atom()
; lisp/s-expr.pla: 1183:   symptr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1184:   return bool_pred(!symptr or symptr->type <> CONS_TYPE))
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F299 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B328
	!WORD	_B328-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$42			; ISNE
_B328 
	!BYTE	$54			; CALL	_C036
_F300 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1185: end
; lisp/s-expr.pla: 1186: 
; lisp/s-expr.pla: 1187: def natv_null(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C038 					; natv_null()
; lisp/s-expr.pla: 1188:   return bool_pred(!eval_expr(expr=>car))
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F301 	!WORD	_C033		
	!BYTE	$80			; NOT
	!BYTE	$54			; CALL	_C036
_F302 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1189: end
; lisp/s-expr.pla: 1190: 
; lisp/s-expr.pla: 1191: def natv_eq(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C039 					; natv_eq()
; lisp/s-expr.pla: 1192:   byte iseq, i
					; iseq -> [4]
					; i -> [5]
; lisp/s-expr.pla: 1193:   var int[2], ext[5]
					; int -> [6]
					; ext -> [10]
; lisp/s-expr.pla: 1194: 
; lisp/s-expr.pla: 1195:   iseq   = FALSE
	!BYTE	$58,$14,$02		; ENTER	20,2
; lisp/s-expr.pla: 1196:   symptr = eval_expr(expr=>car)
; lisp/s-expr.pla: 1197:   if symptr->type == NUM_INT
; lisp/s-expr.pla: 1198:     int[0] = symptr=>intval[0]
; lisp/s-expr.pla: 1199:     int[1] = symptr=>intval[1]
; lisp/s-expr.pla: 1200:     expr   = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1201:     if expr->type == NUM_INT
; lisp/s-expr.pla: 1202:       iseq = int[0] == expr=>intval[0] and int[1] == expr=>intval[1]
; lisp/s-expr.pla: 1203:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F303 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B329
	!WORD	_B329-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F304 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B331
	!WORD	_B331-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B333
	!WORD	_B333-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B333 
	!BYTE	$74,$04			; SLB	[4]
_B331 
_B332 
; lisp/s-expr.pla: 1204:   elsif symptr->type == NUM_FLOAT
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
_B329 
; lisp/s-expr.pla: 1205:     ext[0] = symptr=>floatval[0]
; lisp/s-expr.pla: 1206:     ext[1] = symptr=>floatval[1]
; lisp/s-expr.pla: 1207:     ext[2] = symptr=>floatval[2]
; lisp/s-expr.pla: 1208:     ext[3] = symptr=>floatval[3]
; lisp/s-expr.pla: 1209:     ext[4] = symptr=>floatval[4]
; lisp/s-expr.pla: 1210:     expr   = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1211:     if expr->type == NUM_FLOAT
; lisp/s-expr.pla: 1212:       iseq = TRUE
; lisp/s-expr.pla: 1213:       for i = 0 to 4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B334
	!WORD	_B334-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$04			; CN	2
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$06			; CN	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$08			; CN	4
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F305 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B335
	!WORD	_B335-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$08			; CN	4
	!BYTE	$00			; CN	0
_B338 
	!BYTE	$6C,$05			; DLB	[5]
; lisp/s-expr.pla: 1214:         if ext[i] <> expr=>floatval[i]
; lisp/s-expr.pla: 1215:           iseq = FALSE
; lisp/s-expr.pla: 1216:           break
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$B8,$05			; IDXLB	[5]
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$B8,$05			; IDXLB	[5]
	!BYTE	$62			; LW
	!BYTE	$22			; BREQ	_B340
	!WORD	_B340-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B337
	!WORD	_B337-*
; lisp/s-expr.pla: 1217:         fin
_B340 
_B341 
; lisp/s-expr.pla: 1218:       next
_B339 
	!BYTE	$A4			; INCBRLE	_B338
	!WORD	_B338-*
_B337 
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$30			; DROP 
; lisp/s-expr.pla: 1219:     fin
_B335 
_B336 
; lisp/s-expr.pla: 1220:   else
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
_B334 
; lisp/s-expr.pla: 1221:     iseq = symptr == eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1222:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F306 	!WORD	_C033		
	!BYTE	$40			; ISEQ
	!BYTE	$74,$04			; SLB	[4]
_B330 
; lisp/s-expr.pla: 1223:   return bool_pred(iseq)
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$54			; CALL	_C036
_F307 	!WORD	_C036		
	!BYTE	$5A,$14			; LEAVE	20
; lisp/s-expr.pla: 1224: end
; lisp/s-expr.pla: 1225: 
; lisp/s-expr.pla: 1226: def natv_number(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C040 					; natv_number()
; lisp/s-expr.pla: 1227:   var num
					; num -> [4]
; lisp/s-expr.pla: 1228:   char tempstr[TMPSTR_SIZE]
					; tempstr -> [6]
; lisp/s-expr.pla: 1229: 
; lisp/s-expr.pla: 1230:   expr = eval_expr(expr=>car)
	!BYTE	$58,$86,$02		; ENTER	134,2
; lisp/s-expr.pla: 1231:   if not expr; return NULL; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F308 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B342
	!WORD	_B342-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$86			; LEAVE	134
_B342 
_B343 
; lisp/s-expr.pla: 1232:   when expr->type & TYPE_MASK
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$52			; SEL
	!WORD	_B345-*
; lisp/s-expr.pla: 1233:     is STRING_TYPE // Convert string to number
_B346 
; lisp/s-expr.pla: 1234:       memcpy(@tempstr, expr + stringstr, expr->stringstr + 1)
; lisp/s-expr.pla: 1235:       tempstr[tempstr[0] + 1] = 0
; lisp/s-expr.pla: 1236:       drop, expr = parse_num(@tempstr + 1)
; lisp/s-expr.pla: 1237:       break
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F309 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_C020
_F310 	!WORD	_C020		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B344
	!WORD	_B344-*
; lisp/s-expr.pla: 1238:     is SYM_TYPE
_B347 
; lisp/s-expr.pla: 1239:     is ARRAY_TYPE
_B348 
; lisp/s-expr.pla: 1240:       expr = NULL
; lisp/s-expr.pla: 1241:     is NUM_TYPE
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
_B349 
; lisp/s-expr.pla: 1242:   wend
	!BYTE	$50			; BRNCH	_B344
	!WORD	_B344-*
_B345 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0020
	!WORD	_B347-*
	!WORD	$0030
	!WORD	_B349-*
	!WORD	$0040
	!WORD	_B348-*
	!WORD	$0050
	!WORD	_B346-*
_B344 
; lisp/s-expr.pla: 1243:   return expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$86			; LEAVE	134
; lisp/s-expr.pla: 1244: end
; lisp/s-expr.pla: 1245: 
; lisp/s-expr.pla: 1246: def natv_numberp(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C041 					; natv_numberp()
; lisp/s-expr.pla: 1247:   expr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1248:   return bool_pred(expr and (expr->type & TYPE_MASK == NUM_TYPE))
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F311 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$AC			; BRAND	_B350
	!WORD	_B350-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$30			; CB	48
	!BYTE	$40			; ISEQ
_B350 
	!BYTE	$54			; CALL	_C036
_F312 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1249: end
; lisp/s-expr.pla: 1250: 
; lisp/s-expr.pla: 1251: def natv_and(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C042 					; natv_and()
; lisp/s-expr.pla: 1252:   while expr and eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$50			; BRNCH	_B353
	!WORD	_B353-*
_B351 
; lisp/s-expr.pla: 1253:     expr = expr=>cdr
; lisp/s-expr.pla: 1254:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B353 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B354
	!WORD	_B354-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F313 	!WORD	_C033		
_B354 
	!BYTE	$4E			; BRTRU	_B351
	!WORD	_B351-*
_B352 
; lisp/s-expr.pla: 1255:   return bool_pred(!expr)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$80			; NOT
	!BYTE	$54			; CALL	_C036
_F314 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1256: end
; lisp/s-expr.pla: 1257: 
; lisp/s-expr.pla: 1258: def natv_or(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C043 					; natv_or()
; lisp/s-expr.pla: 1259:   while expr and !eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$50			; BRNCH	_B357
	!WORD	_B357-*
_B355 
; lisp/s-expr.pla: 1260:     expr = expr=>cdr
; lisp/s-expr.pla: 1261:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B357 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B358
	!WORD	_B358-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F315 	!WORD	_C033		
	!BYTE	$80			; NOT
_B358 
	!BYTE	$4E			; BRTRU	_B355
	!WORD	_B355-*
_B356 
; lisp/s-expr.pla: 1262:   return bool_pred(expr)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C036
_F316 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1263: end
; lisp/s-expr.pla: 1264: 
; lisp/s-expr.pla: 1265: def natv_cons(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C044 					; natv_cons()
; lisp/s-expr.pla: 1266:   symptr         = push_sweep_stack(new_cons)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1267:   symptr=>car    = eval_expr(expr=>car)
; lisp/s-expr.pla: 1268:   symptr=>cdr    = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1269:   return pop_sweep_stack
	!BYTE	$54			; CALL	_C009
_F317 	!WORD	_C009		
	!BYTE	$54			; CALL	_C003
_F318 	!WORD	_C003		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F319 	!WORD	_C033		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F320 	!WORD	_C033		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C004
_F321 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1270: end
; lisp/s-expr.pla: 1271: 
; lisp/s-expr.pla: 1272: def natv_list(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C045 					; natv_list()
; lisp/s-expr.pla: 1273:   if expr
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1274:     symptr = push_sweep_stack(new_cons)
; lisp/s-expr.pla: 1275:     repeat
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B359
	!WORD	_B359-*
	!BYTE	$54			; CALL	_C009
_F322 	!WORD	_C009		
	!BYTE	$54			; CALL	_C003
_F323 	!WORD	_C003		
	!BYTE	$76,$00			; SLW	[0]
_B362 
; lisp/s-expr.pla: 1276:       symptr=>car = eval_expr(expr=>car)
; lisp/s-expr.pla: 1277:       expr        = expr=>cdr
; lisp/s-expr.pla: 1278:       if expr
; lisp/s-expr.pla: 1279:         symptr=>cdr = new_cons
; lisp/s-expr.pla: 1280:         symptr      = symptr=>cdr
; lisp/s-expr.pla: 1281:       fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F324 	!WORD	_C033		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B364
	!WORD	_B364-*
	!BYTE	$54			; CALL	_C009
_F325 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B364 
_B365 
; lisp/s-expr.pla: 1282:     until !expr
_B363 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B362
	!WORD	_B362-*
_B361 
; lisp/s-expr.pla: 1283:     return pop_sweep_stack
	!BYTE	$54			; CALL	_C004
_F326 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1284:   fin
_B359 
_B360 
; lisp/s-expr.pla: 1285:   return NULL
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1286: end
; lisp/s-expr.pla: 1287: 
; lisp/s-expr.pla: 1288: def natv_car(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C046 					; natv_car()
; lisp/s-expr.pla: 1289:   return eval_expr(expr=>car)=>car
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F327 	!WORD	_C033		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1290: end
; lisp/s-expr.pla: 1291: 
; lisp/s-expr.pla: 1292: def natv_cdr(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C047 					; natv_cdr()
; lisp/s-expr.pla: 1293:   return eval_expr(expr=>car)=>cdr
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F328 	!WORD	_C033		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1294: end
; lisp/s-expr.pla: 1295: 
; lisp/s-expr.pla: 1296: def natv_quote(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C048 					; natv_quote()
; lisp/s-expr.pla: 1297:   return expr=>car
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1298: end
; lisp/s-expr.pla: 1299: 
; lisp/s-expr.pla: 1300: def natv_function(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C049 					; natv_function()
; lisp/s-expr.pla: 1301:   var funptr
					; funptr -> [4]
; lisp/s-expr.pla: 1302: 
; lisp/s-expr.pla: 1303:   expr = expr=>car
	!BYTE	$58,$06,$02		; ENTER	6,2
; lisp/s-expr.pla: 1304:   if expr->type & TYPE_MASK == SYM_TYPE
; lisp/s-expr.pla: 1305:     if !expr=>natv // Not native function
; lisp/s-expr.pla: 1306:       if expr=>lambda // DEFINEd lambda S-expression
; lisp/s-expr.pla: 1307:         expr = expr=>lambda
; lisp/s-expr.pla: 1308:       else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B366
	!WORD	_B366-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B368
	!WORD	_B368-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B370
	!WORD	_B370-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B371
	!WORD	_B371-*
_B370 
; lisp/s-expr.pla: 1309:         expr = assoc(expr)
; lisp/s-expr.pla: 1310:       fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C027
_F329 	!WORD	_C027		
	!BYTE	$76,$02			; SLW	[2]
_B371 
; lisp/s-expr.pla: 1311:       if !expr or expr->type <> CONS_TYPE or expr=>car <> sym_lambda
; lisp/s-expr.pla: 1312:         err_expr = expr
; lisp/s-expr.pla: 1313:         throw(exception, ERR_NOT_FUN)
; lisp/s-expr.pla: 1314:       fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B372
	!WORD	_B372-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B373
	!WORD	_B373-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D083+0
_F330 	!WORD	_D083+0		
	!BYTE	$42			; ISNE
_B373 
_B372 
	!BYTE	$4C			; BRFLS	_B374
	!WORD	_B374-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D068+0
_F331 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F332 	!WORD	_D067+0		
	!BYTE	$5E,$F8			; CFFB	-8
	!BYTE	$54			; CALL	_X062
_F333 	!WORD	0		
	!BYTE	$30			; DROP 
_B374 
_B375 
; lisp/s-expr.pla: 1315:     fin
_B368 
_B369 
; lisp/s-expr.pla: 1316:   fin
_B366 
_B367 
; lisp/s-expr.pla: 1317:   funptr      = new_cons
; lisp/s-expr.pla: 1318:   symptr      = funptr
; lisp/s-expr.pla: 1319:   symptr=>car = sym_funarg
; lisp/s-expr.pla: 1320:   symptr=>cdr = new_cons
; lisp/s-expr.pla: 1321:   symptr      = symptr=>cdr
; lisp/s-expr.pla: 1322:   symptr=>car = expr
; lisp/s-expr.pla: 1323:   symptr=>cdr = new_cons
; lisp/s-expr.pla: 1324:   symptr      = symptr=>cdr
; lisp/s-expr.pla: 1325:   symptr=>car = copy_expr(assoc_list)
; lisp/s-expr.pla: 1326:   return funptr
	!BYTE	$54			; CALL	_C009
_F334 	!WORD	_C009		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D084+0
_F335 	!WORD	_D084+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C009
_F336 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$54			; CALL	_C009
_F337 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D070+0
_F338 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C035
_F339 	!WORD	_C035		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 1327: end
; lisp/s-expr.pla: 1328: 
; lisp/s-expr.pla: 1329: def natv_define(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C050 					; natv_define()
; lisp/s-expr.pla: 1330: 
; lisp/s-expr.pla: 1331:   var deflist, funcptr
					; deflist -> [4]
					; funcptr -> [6]
; lisp/s-expr.pla: 1332: 
; lisp/s-expr.pla: 1333:   deflist = NULL
	!BYTE	$58,$08,$02		; ENTER	8,2
; lisp/s-expr.pla: 1334:   if expr
; lisp/s-expr.pla: 1335:     deflist  = new_cons
; lisp/s-expr.pla: 1336:     funcptr  = deflist
; lisp/s-expr.pla: 1337:   fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B376
	!WORD	_B376-*
	!BYTE	$54			; CALL	_C009
_F340 	!WORD	_C009		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$76,$06			; SLW	[6]
_B376 
_B377 
; lisp/s-expr.pla: 1338:   while expr
	!BYTE	$50			; BRNCH	_B380
	!WORD	_B380-*
_B378 
; lisp/s-expr.pla: 1339:     symptr         = expr=>car=>car
; lisp/s-expr.pla: 1340:     symptr=>lambda = expr=>car=>cdr=>car
; lisp/s-expr.pla: 1341:     funcptr=>car   = symptr
; lisp/s-expr.pla: 1342:     expr           = expr=>cdr
; lisp/s-expr.pla: 1343:     if expr
; lisp/s-expr.pla: 1344:       funcptr=>cdr = new_cons
; lisp/s-expr.pla: 1345:       funcptr      = funcptr=>cdr
; lisp/s-expr.pla: 1346:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B381
	!WORD	_B381-*
	!BYTE	$54			; CALL	_C009
_F341 	!WORD	_C009		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B381 
_B382 
; lisp/s-expr.pla: 1347:   loop
_B380 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B378
	!WORD	_B378-*
_B379 
; lisp/s-expr.pla: 1348:   return deflist
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$08			; LEAVE	8
; lisp/s-expr.pla: 1349: end
; lisp/s-expr.pla: 1350: 
; lisp/s-expr.pla: 1351: def natv_cset(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C051 					; natv_cset()
; lisp/s-expr.pla: 1352:   symptr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1353:   if symptr->type & TYPE_MASK <> SYM_TYPE
; lisp/s-expr.pla: 1354:     err_expr = symptr
; lisp/s-expr.pla: 1355:     throw(exception, ERR_NOT_SYM)
; lisp/s-expr.pla: 1356:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F342 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B383
	!WORD	_B383-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F343 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F344 	!WORD	_D067+0		
	!BYTE	$5E,$FA			; CFFB	-6
	!BYTE	$54			; CALL	_X062
_F345 	!WORD	0		
	!BYTE	$30			; DROP 
_B383 
_B384 
; lisp/s-expr.pla: 1357:   expr = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1358:   symptr=>apval = expr ^ NULL_HACK
; lisp/s-expr.pla: 1359:   return expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F346 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1360: end
; lisp/s-expr.pla: 1361: 
; lisp/s-expr.pla: 1362: def natv_csetq(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C052 					; natv_csetq()
; lisp/s-expr.pla: 1363:   symptr = expr=>car
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1364:   if symptr->type & TYPE_MASK <> SYM_TYPE
; lisp/s-expr.pla: 1365:     err_expr = symptr
; lisp/s-expr.pla: 1366:     throw(exception, ERR_NOT_SYM)
; lisp/s-expr.pla: 1367:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B385
	!WORD	_B385-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F347 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F348 	!WORD	_D067+0		
	!BYTE	$5E,$FA			; CFFB	-6
	!BYTE	$54			; CALL	_X062
_F349 	!WORD	0		
	!BYTE	$30			; DROP 
_B385 
_B386 
; lisp/s-expr.pla: 1368:   expr = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1369:   symptr=>apval = expr ^ NULL_HACK
; lisp/s-expr.pla: 1370:   return expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F350 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1371: end
; lisp/s-expr.pla: 1372: 
; lisp/s-expr.pla: 1373: def natv_prhex(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C053 					; natv_prhex()
; lisp/s-expr.pla: 1374:   if expr
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1375:     prhex = eval_expr(expr=>car) ?? TRUE :: FALSE
; lisp/s-expr.pla: 1376:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B387
	!WORD	_B387-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F351 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B389
	!WORD	_B389-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$50			; BRNCH	_B390
	!WORD	_B390-*
_B389 
	!BYTE	$00			; CN	0
_B390 
	!BYTE	$78			; SAB	_D063+0
_F352 	!WORD	_D063+0		
_B387 
_B388 
; lisp/s-expr.pla: 1377:   return bool_pred(prhex)
	!BYTE	$68			; LAB	_D063+0
_F353 	!WORD	_D063+0		
	!BYTE	$54			; CALL	_C036
_F354 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1378: end
; lisp/s-expr.pla: 1379: 
; lisp/s-expr.pla: 1380: def natv_prin(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C054 					; natv_prin()
; lisp/s-expr.pla: 1381:   var result
					; result -> [4]
; lisp/s-expr.pla: 1382: 
; lisp/s-expr.pla: 1383:   result = NULL
	!BYTE	$58,$06,$02		; ENTER	6,2
; lisp/s-expr.pla: 1384:   while expr
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B393
	!WORD	_B393-*
_B391 
; lisp/s-expr.pla: 1385:     result = eval_expr(expr=>car)
; lisp/s-expr.pla: 1386:     print_expr(result)
; lisp/s-expr.pla: 1387:     expr = expr=>cdr
; lisp/s-expr.pla: 1388:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F355 	!WORD	_C033		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C017
_F356 	!WORD	_C017		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B393 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B391
	!WORD	_B391-*
_B392 
; lisp/s-expr.pla: 1389:   return result
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 1390: end
; lisp/s-expr.pla: 1391: 
; lisp/s-expr.pla: 1392: def natv_print(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C055 					; natv_print()
; lisp/s-expr.pla: 1393:   expr = natv_prin(symptr, expr)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1394:   putln
; lisp/s-expr.pla: 1395:   return expr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C054
_F357 	!WORD	_C054		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$54			; CALL	_X003
_F358 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1396: end
; lisp/s-expr.pla: 1397: 
; lisp/s-expr.pla: 1398: def natv_eval(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C056 					; natv_eval()
; lisp/s-expr.pla: 1399:   return eval_expr(eval_expr(expr=>car))
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F359 	!WORD	_C033		
	!BYTE	$54			; CALL	_C033
_F360 	!WORD	_C033		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1400: end
; lisp/s-expr.pla: 1401: 
; lisp/s-expr.pla: 1402: def natv_trace(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C057 					; natv_trace()
; lisp/s-expr.pla: 1403:   if expr
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1404:     trace = eval_expr(expr=>car) ?? TRUE :: FALSE
; lisp/s-expr.pla: 1405:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B394
	!WORD	_B394-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F361 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B396
	!WORD	_B396-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$50			; BRNCH	_B397
	!WORD	_B397-*
_B396 
	!BYTE	$00			; CN	0
_B397 
	!BYTE	$78			; SAB	_D066+0
_F362 	!WORD	_D066+0		
_B394 
_B395 
; lisp/s-expr.pla: 1406:   return bool_pred(trace)
	!BYTE	$68			; LAB	_D066+0
_F363 	!WORD	_D066+0		
	!BYTE	$54			; CALL	_C036
_F364 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1407: end
; lisp/s-expr.pla: 1408: 
; lisp/s-expr.pla: 1409: def natv_copy(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C058 					; natv_copy()
; lisp/s-expr.pla: 1410:   return copy_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C035
_F365 	!WORD	_C035		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1411: end
; lisp/s-expr.pla: 1412: 
; lisp/s-expr.pla: 1413: //
; lisp/s-expr.pla: 1414: // Arrays
; lisp/s-expr.pla: 1415: //
; lisp/s-expr.pla: 1416: 
; lisp/s-expr.pla: 1417: def natv_arrayp(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C059 					; natv_arrayp()
; lisp/s-expr.pla: 1418:   expr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1419:   return bool_pred(expr and expr->type == ARRAY_TYPE)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F366 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$AC			; BRAND	_B398
	!WORD	_B398-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$40			; CB	64
	!BYTE	$40			; ISEQ
_B398 
	!BYTE	$54			; CALL	_C036
_F367 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1420: end
; lisp/s-expr.pla: 1421: 
; lisp/s-expr.pla: 1422: def eval_index(arrayptr, expr)
					; arrayptr -> [0]
					; expr -> [2]
_C060 					; eval_index()
; lisp/s-expr.pla: 1423:   var idx[4], i, ii, index
					; idx -> [4]
					; i -> [12]
					; ii -> [14]
					; index -> [16]
; lisp/s-expr.pla: 1424: 
; lisp/s-expr.pla: 1425:   ii = 0
	!BYTE	$58,$12,$02		; ENTER	18,2
; lisp/s-expr.pla: 1426:   while expr and ii < 4
	!BYTE	$00			; CN	0
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$50			; BRNCH	_B401
	!WORD	_B401-*
_B399 
; lisp/s-expr.pla: 1427:     index = eval_expr(expr=>car)
; lisp/s-expr.pla: 1428:     if index->type <> NUM_INT or isuge(index=>intval, arrayptr=>dimension[ii])
; lisp/s-expr.pla: 1429:       err_expr = expr
; lisp/s-expr.pla: 1430:       throw(exception, ERR_BAD_INDEX)
; lisp/s-expr.pla: 1431:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F368 	!WORD	_C033		
	!BYTE	$6E,$10			; DLW	[16]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B403
	!WORD	_B403-*
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X025
_F369 	!WORD	0		
_B403 
	!BYTE	$4C			; BRFLS	_B404
	!WORD	_B404-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D068+0
_F370 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F371 	!WORD	_D067+0		
	!BYTE	$5E,$F3			; CFFB	-13
	!BYTE	$54			; CALL	_X062
_F372 	!WORD	0		
	!BYTE	$30			; DROP 
_B404 
_B405 
; lisp/s-expr.pla: 1432:     idx[ii] = index=>intval
; lisp/s-expr.pla: 1433:     expr    = expr=>cdr
; lisp/s-expr.pla: 1434:     ii++
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 1435:   loop
	!BYTE	$76,$0E			; SLW	[14]
_B401 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$AC			; BRAND	_B402
	!WORD	_B402-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$08			; CN	4
	!BYTE	$46			; ISLT
_B402 
	!BYTE	$4E			; BRTRU	_B399
	!WORD	_B399-*
_B400 
; lisp/s-expr.pla: 1436:   index = 0
; lisp/s-expr.pla: 1437:   while ii
	!BYTE	$00			; CN	0
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$50			; BRNCH	_B408
	!WORD	_B408-*
_B406 
; lisp/s-expr.pla: 1438:     ii--
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$8E			; DECR
; lisp/s-expr.pla: 1439:     index = index + idx[ii] * arrayptr=>offset[ii]
; lisp/s-expr.pla: 1440:   loop
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$62			; LW
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$76,$10			; SLW	[16]
_B408 
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$4E			; BRTRU	_B406
	!WORD	_B406-*
_B407 
; lisp/s-expr.pla: 1441:   return arrayptr=>arraymem + index
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$62			; LW
	!BYTE	$B2,$10			; ADDLW	[16]
	!BYTE	$5A,$12			; LEAVE	18
; lisp/s-expr.pla: 1442: end
; lisp/s-expr.pla: 1443: 
; lisp/s-expr.pla: 1444: def natv_index(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C061 					; natv_index()
; lisp/s-expr.pla: 1445:   var elemptr
					; elemptr -> [4]
; lisp/s-expr.pla: 1446: 
; lisp/s-expr.pla: 1447:   if expr=>car == sym_set
	!BYTE	$58,$06,$02		; ENTER	6,2
; lisp/s-expr.pla: 1448:     elemptr = eval_index(symptr=>array, expr=>cdr=>cdr)
; lisp/s-expr.pla: 1449:     if elemptr; *elemptr = eval_expr(expr=>cdr=>car); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D085+0
_F373 	!WORD	_D085+0		
	!BYTE	$24			; BRNE	_B409
	!WORD	_B409-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C060
_F374 	!WORD	_C060		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B411
	!WORD	_B411-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F375 	!WORD	_C033		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
_B411 
_B412 
; lisp/s-expr.pla: 1450:   else
	!BYTE	$50			; BRNCH	_B410
	!WORD	_B410-*
_B409 
; lisp/s-expr.pla: 1451:     elemptr = eval_index(symptr=>array, expr)
; lisp/s-expr.pla: 1452:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C060
_F376 	!WORD	_C060		
	!BYTE	$76,$04			; SLW	[4]
_B410 
; lisp/s-expr.pla: 1453:   return elemptr ?? *elemptr :: NULL
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B413
	!WORD	_B413-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$50			; BRNCH	_B414
	!WORD	_B414-*
_B413 
	!BYTE	$00			; CN	0
_B414 
	!BYTE	$5A,$06			; LEAVE	6
; lisp/s-expr.pla: 1454: end
; lisp/s-expr.pla: 1455: 
; lisp/s-expr.pla: 1456: def natv_array(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C062 					; natv_array()
; lisp/s-expr.pla: 1457:   var arraylist, aptr
					; arraylist -> [4]
					; aptr -> [6]
; lisp/s-expr.pla: 1458:   var idx_expr, idx[4], ii, index
					; idx_expr -> [8]
					; idx -> [10]
					; ii -> [18]
					; index -> [20]
; lisp/s-expr.pla: 1459: 
; lisp/s-expr.pla: 1460:   arraylist = NULL
	!BYTE	$58,$16,$02		; ENTER	22,2
; lisp/s-expr.pla: 1461:   if expr
; lisp/s-expr.pla: 1462:     arraylist = new_cons
; lisp/s-expr.pla: 1463:     aptr      = arraylist
; lisp/s-expr.pla: 1464:   fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B415
	!WORD	_B415-*
	!BYTE	$54			; CALL	_C009
_F377 	!WORD	_C009		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$76,$06			; SLW	[6]
_B415 
_B416 
; lisp/s-expr.pla: 1465:   while expr
	!BYTE	$50			; BRNCH	_B419
	!WORD	_B419-*
_B417 
; lisp/s-expr.pla: 1466:     symptr       = expr=>car=>car
; lisp/s-expr.pla: 1467:     symptr=>natv = @natv_index
; lisp/s-expr.pla: 1468:     idx_expr     = expr=>car=>cdr=>car
; lisp/s-expr.pla: 1469:     idx[0]       = 0
; lisp/s-expr.pla: 1470:     idx[1]       = 0
; lisp/s-expr.pla: 1471:     idx[2]       = 0
; lisp/s-expr.pla: 1472:     idx[3]       = 0
; lisp/s-expr.pla: 1473:     ii           = 0
; lisp/s-expr.pla: 1474:     while idx_expr and ii < 4
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$26			; LA	_C061+0
_F378 	!WORD	_C061+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$00			; CN	0
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$50			; BRNCH	_B422
	!WORD	_B422-*
_B420 
; lisp/s-expr.pla: 1475:       index = eval_expr(idx_expr=>car)
; lisp/s-expr.pla: 1476:       if index->type <> NUM_INT
; lisp/s-expr.pla: 1477:         err_expr = index
; lisp/s-expr.pla: 1478:         throw(exception, ERR_BAD_INDEX)
; lisp/s-expr.pla: 1479:       fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F379 	!WORD	_C033		
	!BYTE	$6E,$14			; DLW	[20]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$22			; BREQ	_B424
	!WORD	_B424-*
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$7A			; SAW	_D068+0
_F380 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F381 	!WORD	_D067+0		
	!BYTE	$5E,$F3			; CFFB	-13
	!BYTE	$54			; CALL	_X062
_F382 	!WORD	0		
	!BYTE	$30			; DROP 
_B424 
_B425 
; lisp/s-expr.pla: 1480:       idx[ii]  = index=>intval
; lisp/s-expr.pla: 1481:       idx_expr = idx_expr=>cdr
; lisp/s-expr.pla: 1482:       ii++
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$BA,$12			; IDXLW	[18]
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 1483:     loop
	!BYTE	$76,$12			; SLW	[18]
_B422 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$AC			; BRAND	_B423
	!WORD	_B423-*
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$08			; CN	4
	!BYTE	$46			; ISLT
_B423 
	!BYTE	$4E			; BRTRU	_B420
	!WORD	_B420-*
_B421 
; lisp/s-expr.pla: 1484:     symptr=>array = new_array(idx[0], idx[1], idx[2], idx[3])
; lisp/s-expr.pla: 1485:     aptr=>car     = symptr
; lisp/s-expr.pla: 1486:     expr          = expr=>cdr
; lisp/s-expr.pla: 1487:     if expr
; lisp/s-expr.pla: 1488:       aptr=>cdr = new_cons
; lisp/s-expr.pla: 1489:       aptr      = aptr=>cdr
; lisp/s-expr.pla: 1490:     fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C012
_F383 	!WORD	_C012		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B426
	!WORD	_B426-*
	!BYTE	$54			; CALL	_C009
_F384 	!WORD	_C009		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B426 
_B427 
; lisp/s-expr.pla: 1491:   loop
_B419 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B417
	!WORD	_B417-*
_B418 
; lisp/s-expr.pla: 1492:   return arraylist
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$16			; LEAVE	22
; lisp/s-expr.pla: 1493: end
; lisp/s-expr.pla: 1494: 
; lisp/s-expr.pla: 1495: //
; lisp/s-expr.pla: 1496: // Strings language extension
; lisp/s-expr.pla: 1497: //
; lisp/s-expr.pla: 1498: 
; lisp/s-expr.pla: 1499: def natv_string(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C063 					; natv_string()
; lisp/s-expr.pla: 1500:   char tempstr[TMPSTR_SIZE]
					; tempstr -> [4]
; lisp/s-expr.pla: 1501: 
; lisp/s-expr.pla: 1502:   expr = eval_expr(expr=>car)
	!BYTE	$58,$84,$02		; ENTER	132,2
; lisp/s-expr.pla: 1503:   if not expr; return NULL; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F385 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B428
	!WORD	_B428-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$84			; LEAVE	132
_B428 
_B429 
; lisp/s-expr.pla: 1504:   tempstr[0] = 0
; lisp/s-expr.pla: 1505:   when expr->type & TYPE_MASK
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$52			; SEL
	!WORD	_B431-*
; lisp/s-expr.pla: 1506:     is NUM_TYPE
_B432 
; lisp/s-expr.pla: 1507:       when expr->type
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B434-*
; lisp/s-expr.pla: 1508:         is NUM_INT
_B435 
; lisp/s-expr.pla: 1509:           i32tos(expr + intval, @tempstr)
; lisp/s-expr.pla: 1510:           break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_X055
_F386 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B433
	!WORD	_B433-*
; lisp/s-expr.pla: 1511:         is NUM_FLOAT
_B436 
; lisp/s-expr.pla: 1512:           ext2str(expr + floatval, @tempstr, fmt_fpint, fmt_fpfrac, fmt_fp)
; lisp/s-expr.pla: 1513:           if tempstr[1] == ' ' // Remove leading space
; lisp/s-expr.pla: 1514:             memcpy (@tempstr + 1, @tempstr + 2, tempstr[0])
; lisp/s-expr.pla: 1515:             tempstr[0]--
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$6A			; LAW	_D064+0
_F387 	!WORD	_D064+0		
	!BYTE	$6A			; LAW	_D065+0
_F388 	!WORD	_D065+0		
	!BYTE	$16			; CN	11
	!BYTE	$54			; CALL	_X059
_F389 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$24			; BRNE	_B437
	!WORD	_B437-*
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$54			; CALL	_X018
_F390 	!WORD	0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
; lisp/s-expr.pla: 1516:           fin
	!BYTE	$74,$04			; SLB	[4]
_B437 
_B438 
; lisp/s-expr.pla: 1517:           break
	!BYTE	$50			; BRNCH	_B433
	!WORD	_B433-*
; lisp/s-expr.pla: 1518:       wend
	!BYTE	$50			; BRNCH	_B433
	!WORD	_B433-*
_B434 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0031
	!WORD	_B435-*
	!WORD	$0032
	!WORD	_B436-*
_B433 
; lisp/s-expr.pla: 1519:       break
	!BYTE	$50			; BRNCH	_B430
	!WORD	_B430-*
; lisp/s-expr.pla: 1520:     is SYM_TYPE
_B439 
; lisp/s-expr.pla: 1521:       tempstr[0] = expr->type & SYM_LEN
; lisp/s-expr.pla: 1522:       memcpy(@tempstr + 1, expr + name, tempstr[0])
; lisp/s-expr.pla: 1523:       break;
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$54			; CALL	_X018
_F391 	!WORD	0		
	!BYTE	$50			; BRNCH	_B430
	!WORD	_B430-*
; lisp/s-expr.pla: 1524:     is ARRAY_TYPE
_B440 
; lisp/s-expr.pla: 1525:       tempstr[0] = 2
; lisp/s-expr.pla: 1526:       tempstr[1] = '['
; lisp/s-expr.pla: 1527:       tempstr[2] = ']'
; lisp/s-expr.pla: 1528:       break;
	!BYTE	$04			; CN	2
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$2A,$5B			; CB	91
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$2A,$5D			; CB	93
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B430
	!WORD	_B430-*
; lisp/s-expr.pla: 1529:   wend
	!BYTE	$50			; BRNCH	_B430
	!WORD	_B430-*
_B431 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0020
	!WORD	_B439-*
	!WORD	$0030
	!WORD	_B432-*
	!WORD	$0040
	!WORD	_B440-*
_B430 
; lisp/s-expr.pla: 1530:   return new_string(@tempstr)
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C014
_F392 	!WORD	_C014		
	!BYTE	$5A,$84			; LEAVE	132
; lisp/s-expr.pla: 1531: end
; lisp/s-expr.pla: 1532: 
; lisp/s-expr.pla: 1533: def natv_stringp(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C064 					; natv_stringp()
; lisp/s-expr.pla: 1534:   return bool_pred(eval_expr(expr=>car)->type == STRING_TYPE)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F393 	!WORD	_C033		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$50			; CB	80
	!BYTE	$40			; ISEQ
	!BYTE	$54			; CALL	_C036
_F394 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1535: end
; lisp/s-expr.pla: 1536: 
; lisp/s-expr.pla: 1537: def natv_subs(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C065 					; natv_subs()
; lisp/s-expr.pla: 1538:   var stringptr
					; stringptr -> [4]
; lisp/s-expr.pla: 1539:   byte ofst, len
					; ofst -> [6]
					; len -> [7]
; lisp/s-expr.pla: 1540:   char tempstr[TMPSTR_SIZE]
					; tempstr -> [8]
; lisp/s-expr.pla: 1541: 
; lisp/s-expr.pla: 1542:   stringptr = eval_expr(expr=>car)
	!BYTE	$58,$88,$02		; ENTER	136,2
; lisp/s-expr.pla: 1543:   if stringptr->type <> STRING_TYPE
; lisp/s-expr.pla: 1544:     err_expr = stringptr
; lisp/s-expr.pla: 1545:     throw(exception, ERR_NOT_STR)
; lisp/s-expr.pla: 1546:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F395 	!WORD	_C033		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$50			; CB	80
	!BYTE	$22			; BREQ	_B441
	!WORD	_B441-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D068+0
_F396 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F397 	!WORD	_D067+0		
	!BYTE	$5E,$F4			; CFFB	-12
	!BYTE	$54			; CALL	_X062
_F398 	!WORD	0		
	!BYTE	$30			; DROP 
_B441 
_B442 
; lisp/s-expr.pla: 1547:   symptr = eval_expr(expr=>cdr=>car)
; lisp/s-expr.pla: 1548:   if symptr->type <> NUM_INT
; lisp/s-expr.pla: 1549:     err_expr = symptr
; lisp/s-expr.pla: 1550:     throw(exception, ERR_NOT_INT)
; lisp/s-expr.pla: 1551:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F399 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$22			; BREQ	_B443
	!WORD	_B443-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F400 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F401 	!WORD	_D067+0		
	!BYTE	$5E,$F6			; CFFB	-10
	!BYTE	$54			; CALL	_X062
_F402 	!WORD	0		
	!BYTE	$30			; DROP 
_B443 
_B444 
; lisp/s-expr.pla: 1552:   ofst = symptr=>intval[0]
; lisp/s-expr.pla: 1553:   symptr = eval_expr(expr=>cdr=>cdr=>car)
; lisp/s-expr.pla: 1554:   if symptr->type <> NUM_INT
; lisp/s-expr.pla: 1555:     err_expr = symptr
; lisp/s-expr.pla: 1556:     throw(exception, ERR_NOT_INT)
; lisp/s-expr.pla: 1557:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F403 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$22			; BREQ	_B445
	!WORD	_B445-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F404 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F405 	!WORD	_D067+0		
	!BYTE	$5E,$F6			; CFFB	-10
	!BYTE	$54			; CALL	_X062
_F406 	!WORD	0		
	!BYTE	$30			; DROP 
_B445 
_B446 
; lisp/s-expr.pla: 1558:   len = symptr=>intval[0]
; lisp/s-expr.pla: 1559:   if ofst > stringptr->stringstr
; lisp/s-expr.pla: 1560:     return NULL
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B447
	!WORD	_B447-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$88			; LEAVE	136
; lisp/s-expr.pla: 1561:   fin
_B447 
_B448 
; lisp/s-expr.pla: 1562:   if ofst + len > stringptr->stringstr
; lisp/s-expr.pla: 1563:     len = stringptr->stringstr - ofst
; lisp/s-expr.pla: 1564:   fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B0,$07			; ADDLB	[7]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B449
	!WORD	_B449-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$84			; SUB 
	!BYTE	$74,$07			; SLB	[7]
_B449 
_B450 
; lisp/s-expr.pla: 1565:   memcpy(@tempstr + 1, stringptr + stringstr + ofst + 1, len)
; lisp/s-expr.pla: 1566:   tempstr[0] = len
; lisp/s-expr.pla: 1567:   return new_string(@tempstr)
	!BYTE	$28,$09			; LLA	[9]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$8C			; INCR
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_X018
_F407 	!WORD	0		
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C014
_F408 	!WORD	_C014		
	!BYTE	$5A,$88			; LEAVE	136
; lisp/s-expr.pla: 1568: end
; lisp/s-expr.pla: 1569: 
; lisp/s-expr.pla: 1570: def natv_cats(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C066 					; natv_cats()
; lisp/s-expr.pla: 1571:   var len, stringptr
					; len -> [4]
					; stringptr -> [6]
; lisp/s-expr.pla: 1572:   char tempstr[TMPSTR_SIZE]
					; tempstr -> [8]
; lisp/s-expr.pla: 1573: 
; lisp/s-expr.pla: 1574:   len = 0
	!BYTE	$58,$88,$02		; ENTER	136,2
; lisp/s-expr.pla: 1575:   while expr
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
_B451 
; lisp/s-expr.pla: 1576:     stringptr = eval_expr(expr=>car)
; lisp/s-expr.pla: 1577:     if stringptr->type == STRING_TYPE
; lisp/s-expr.pla: 1578:       if len + stringptr->stringstr < TMPSTR_SIZE
; lisp/s-expr.pla: 1579:         memcpy(@tempstr + len + 1, stringptr + stringstr + 1, stringptr->stringstr)
; lisp/s-expr.pla: 1580:         len = len + stringptr->stringstr
; lisp/s-expr.pla: 1581:       fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F409 	!WORD	_C033		
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$50			; CB	80
	!BYTE	$24			; BRNE	_B454
	!WORD	_B454-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B456
	!WORD	_B456-*
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$8C			; INCR
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F410 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
_B456 
_B457 
; lisp/s-expr.pla: 1582:     fin
_B454 
_B455 
; lisp/s-expr.pla: 1583:     expr = expr=>cdr
; lisp/s-expr.pla: 1584:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B453 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B451
	!WORD	_B451-*
_B452 
; lisp/s-expr.pla: 1585:   tempstr[0] = len
; lisp/s-expr.pla: 1586:   return new_string(@tempstr)
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$54			; CALL	_C014
_F411 	!WORD	_C014		
	!BYTE	$5A,$88			; LEAVE	136
; lisp/s-expr.pla: 1587: end
; lisp/s-expr.pla: 1588: 
; lisp/s-expr.pla: 1589: def natv_lens(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C067 					; natv_lens()
; lisp/s-expr.pla: 1590:   symptr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1591:   if symptr->type <> STRING_TYPE
; lisp/s-expr.pla: 1592:     err_expr = symptr
; lisp/s-expr.pla: 1593:     throw(exception, ERR_NOT_STR)
; lisp/s-expr.pla: 1594:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F412 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$50			; CB	80
	!BYTE	$22			; BREQ	_B458
	!WORD	_B458-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F413 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F414 	!WORD	_D067+0		
	!BYTE	$5E,$F4			; CFFB	-12
	!BYTE	$54			; CALL	_X062
_F415 	!WORD	0		
	!BYTE	$30			; DROP 
_B458 
_B459 
; lisp/s-expr.pla: 1595:   return new_int(symptr->stringstr, 0)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C010
_F416 	!WORD	_C010		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1596: end
; lisp/s-expr.pla: 1597: 
; lisp/s-expr.pla: 1598: def natv_chars(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C068 					; natv_chars()
; lisp/s-expr.pla: 1599:   char tempstr[TMPSTR_SIZE]
					; tempstr -> [4]
; lisp/s-expr.pla: 1600: 
; lisp/s-expr.pla: 1601:   tempstr[0] = 0
	!BYTE	$58,$84,$02		; ENTER	132,2
; lisp/s-expr.pla: 1602:   while expr
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B462
	!WORD	_B462-*
_B460 
; lisp/s-expr.pla: 1603:     symptr = eval_expr(expr=>car)
; lisp/s-expr.pla: 1604:     if symptr->type == NUM_INT
; lisp/s-expr.pla: 1605:       tempstr[0]++
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F417 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$24			; BRNE	_B463
	!WORD	_B463-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
; lisp/s-expr.pla: 1606:       tempstr[tempstr[0]] = symptr=>intval[0]
; lisp/s-expr.pla: 1607:     fin
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$70			; SB
_B463 
_B464 
; lisp/s-expr.pla: 1608:     expr = expr=>cdr
; lisp/s-expr.pla: 1609:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B462 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B460
	!WORD	_B460-*
_B461 
; lisp/s-expr.pla: 1610:   return new_string(@tempstr)
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$54			; CALL	_C014
_F418 	!WORD	_C014		
	!BYTE	$5A,$84			; LEAVE	132
; lisp/s-expr.pla: 1611: end
; lisp/s-expr.pla: 1612: 
; lisp/s-expr.pla: 1613: def natv_ascii(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C069 					; natv_ascii()
; lisp/s-expr.pla: 1614:   symptr = eval_expr(expr=>car)
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1615:   if symptr->type <> STRING_TYPE
; lisp/s-expr.pla: 1616:     err_expr = symptr
; lisp/s-expr.pla: 1617:     throw(exception, ERR_NOT_STR)
; lisp/s-expr.pla: 1618:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F419 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$50			; CB	80
	!BYTE	$22			; BREQ	_B465
	!WORD	_B465-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F420 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F421 	!WORD	_D067+0		
	!BYTE	$5E,$F4			; CFFB	-12
	!BYTE	$54			; CALL	_X062
_F422 	!WORD	0		
	!BYTE	$30			; DROP 
_B465 
_B466 
; lisp/s-expr.pla: 1619:   return new_int(symptr->stringstr ?? symptr->stringstr[1] :: 0, 0)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B467
	!WORD	_B467-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$50			; BRNCH	_B468
	!WORD	_B468-*
_B467 
	!BYTE	$00			; CN	0
_B468 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C010
_F423 	!WORD	_C010		
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1620: end
; lisp/s-expr.pla: 1621: 
; lisp/s-expr.pla: 1622: //
; lisp/s-expr.pla: 1623: // FOR(...) loop language extension
; lisp/s-expr.pla: 1624: //
; lisp/s-expr.pla: 1625: 
; lisp/s-expr.pla: 1626: def natv_for(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C070 					; natv_for()
; lisp/s-expr.pla: 1627:   var index, ufunc, dlist
					; index -> [4]
					; ufunc -> [6]
					; dlist -> [8]
; lisp/s-expr.pla: 1628:   word[2] idxval, stepval
					; idxval -> [10]
					; stepval -> [14]
; lisp/s-expr.pla: 1629: 
; lisp/s-expr.pla: 1630:   index = expr=>car
	!BYTE	$58,$12,$02		; ENTER	18,2
; lisp/s-expr.pla: 1631:   if index->type & TYPE_MASK <> SYM_TYPE
; lisp/s-expr.pla: 1632:     err_expr = index
; lisp/s-expr.pla: 1633:     throw(exception, ERR_NOT_SYM)
; lisp/s-expr.pla: 1634:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B469
	!WORD	_B469-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D068+0
_F424 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F425 	!WORD	_D067+0		
	!BYTE	$5E,$FA			; CFFB	-6
	!BYTE	$54			; CALL	_X062
_F426 	!WORD	0		
	!BYTE	$30			; DROP 
_B469 
_B470 
; lisp/s-expr.pla: 1635:   expr   = expr=>cdr
; lisp/s-expr.pla: 1636:   symptr = eval_expr(expr=>car)
; lisp/s-expr.pla: 1637:   expr   = expr=>cdr
; lisp/s-expr.pla: 1638:   if symptr->type <> NUM_INT
; lisp/s-expr.pla: 1639:     err_expr = symptr
; lisp/s-expr.pla: 1640:     throw(exception, ERR_NOT_INT)
; lisp/s-expr.pla: 1641:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F427 	!WORD	_C033		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$22			; BREQ	_B471
	!WORD	_B471-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F428 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F429 	!WORD	_D067+0		
	!BYTE	$5E,$F6			; CFFB	-10
	!BYTE	$54			; CALL	_X062
_F430 	!WORD	0		
	!BYTE	$30			; DROP 
_B471 
_B472 
; lisp/s-expr.pla: 1642:   idxval[0] = symptr=>intval[0]
; lisp/s-expr.pla: 1643:   idxval[1] = symptr=>intval[1]
; lisp/s-expr.pla: 1644:   set_assoc(index, symptr)
; lisp/s-expr.pla: 1645:   symptr = eval_expr(expr=>car)
; lisp/s-expr.pla: 1646:   expr   = expr=>cdr
; lisp/s-expr.pla: 1647:   if symptr->type <> NUM_INT
; lisp/s-expr.pla: 1648:     err_expr = symptr
; lisp/s-expr.pla: 1649:     throw(exception, ERR_NOT_INT)
; lisp/s-expr.pla: 1650:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C026
_F431 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F432 	!WORD	_C033		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$31			; CB	49
	!BYTE	$22			; BREQ	_B473
	!WORD	_B473-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D068+0
_F433 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F434 	!WORD	_D067+0		
	!BYTE	$5E,$F6			; CFFB	-10
	!BYTE	$54			; CALL	_X062
_F435 	!WORD	0		
	!BYTE	$30			; DROP 
_B473 
_B474 
; lisp/s-expr.pla: 1651:   stepval[0] = symptr=>intval[0]
; lisp/s-expr.pla: 1652:   stepval[1] = symptr=>intval[1]
; lisp/s-expr.pla: 1653:   ufunc      = expr=>car
; lisp/s-expr.pla: 1654:   dlist      = expr=>cdr
; lisp/s-expr.pla: 1655:   //
; lisp/s-expr.pla: 1656:   // Enter loop
; lisp/s-expr.pla: 1657:   //
; lisp/s-expr.pla: 1658:   push_sweep_stack(NULL)
; lisp/s-expr.pla: 1659:   while eval_expr(ufunc)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$00			; CN	0
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$02			; CN	1
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C003
_F436 	!WORD	_C003		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
_B475 
; lisp/s-expr.pla: 1660:     expr = dlist
; lisp/s-expr.pla: 1661:     while expr
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B480
	!WORD	_B480-*
_B478 
; lisp/s-expr.pla: 1662:       //
; lisp/s-expr.pla: 1663:       // Keep result from getting GC'ed
; lisp/s-expr.pla: 1664:       //
; lisp/s-expr.pla: 1665:       sweep_stack[sweep_stack_top - 1] = eval_expr(expr=>car)
; lisp/s-expr.pla: 1666:       expr                             = expr=>cdr
; lisp/s-expr.pla: 1667:       if prog_return; return pop_sweep_stack; fin // Check for RETURN()
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F437 	!WORD	_C033		
	!BYTE	$26			; LA	_D097+0
_F438 	!WORD	_D097+0		
	!BYTE	$68			; LAB	_D096+0
_F439 	!WORD	_D096+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D093+0
_F440 	!WORD	_D093+0		
	!BYTE	$4C			; BRFLS	_B481
	!WORD	_B481-*
	!BYTE	$54			; CALL	_C004
_F441 	!WORD	_C004		
	!BYTE	$5A,$12			; LEAVE	18
_B481 
_B482 
; lisp/s-expr.pla: 1668:     loop
_B480 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B478
	!WORD	_B478-*
_B479 
; lisp/s-expr.pla: 1669:     load32(@idxval) // Update index value
; lisp/s-expr.pla: 1670:     add32(@stepval)
; lisp/s-expr.pla: 1671:     store32(@idxval)
; lisp/s-expr.pla: 1672:     set_assoc(index, new_int(idxval[0], idxval[1]))
; lisp/s-expr.pla: 1673:   loop
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$54			; CALL	_X032
_F442 	!WORD	0		
	!BYTE	$28,$0E			; LLA	[14]
	!BYTE	$54			; CALL	_X035
_F443 	!WORD	0		
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$54			; CALL	_X034
_F444 	!WORD	0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C010
_F445 	!WORD	_C010		
	!BYTE	$54			; CALL	_C026
_F446 	!WORD	_C026		
	!BYTE	$30			; DROP 
_B477 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C033
_F447 	!WORD	_C033		
	!BYTE	$4E			; BRTRU	_B475
	!WORD	_B475-*
_B476 
; lisp/s-expr.pla: 1674:   return pop_sweep_stack
	!BYTE	$54			; CALL	_C004
_F448 	!WORD	_C004		
	!BYTE	$5A,$12			; LEAVE	18
; lisp/s-expr.pla: 1675: end
; lisp/s-expr.pla: 1676: 
; lisp/s-expr.pla: 1677: //
; lisp/s-expr.pla: 1678: // PROG(...) language extension
; lisp/s-expr.pla: 1679: //
; lisp/s-expr.pla: 1680: 
; lisp/s-expr.pla: 1681: def natv_prog(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C071 					; natv_prog()
; lisp/s-expr.pla: 1682:   var prog_enter, prog_car, cond_expr
					; prog_enter -> [4]
					; prog_car -> [6]
					; cond_expr -> [8]
; lisp/s-expr.pla: 1683: 
; lisp/s-expr.pla: 1684:   prog_expr  = expr=>cdr
	!BYTE	$58,$0A,$02		; ENTER	10,2
; lisp/s-expr.pla: 1685:   prog       = prog_expr // Update current PROG expression
; lisp/s-expr.pla: 1686:   prog_enter = prog      // Save current prog
; lisp/s-expr.pla: 1687:   expr = expr=>car       // Set up local variables
; lisp/s-expr.pla: 1688:   while expr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$7E			; DAW	_D092+0
_F449 	!WORD	_D092+0		
	!BYTE	$7E			; DAW	_D091+0
_F450 	!WORD	_D091+0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B485
	!WORD	_B485-*
_B483 
; lisp/s-expr.pla: 1689:     new_assoc(expr=>car, NULL)
; lisp/s-expr.pla: 1690:     expr = expr=>cdr
; lisp/s-expr.pla: 1691:   loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C024
_F451 	!WORD	_C024		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B485 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B483
	!WORD	_B483-*
_B484 
; lisp/s-expr.pla: 1692:   prog_return = NULL
; lisp/s-expr.pla: 1693:   while prog_expr and not prog_return
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D093+0
_F452 	!WORD	_D093+0		
	!BYTE	$50			; BRNCH	_B488
	!WORD	_B488-*
_B486 
; lisp/s-expr.pla: 1694:     prog_car  = prog_expr=>car
; lisp/s-expr.pla: 1695:     prog_expr = prog_expr=>cdr // Assume continuation
; lisp/s-expr.pla: 1696:     if prog_car->type == CONS_TYPE
; lisp/s-expr.pla: 1697:       if prog_car=>car == sym_cond // Inline COND(...) evaluation
; lisp/s-expr.pla: 1698:         cond_expr = prog_car=>cdr
; lisp/s-expr.pla: 1699:         while cond_expr
	!BYTE	$6A			; LAW	_D092+0
_F453 	!WORD	_D092+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_D092+0
_F454 	!WORD	_D092+0		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D092+0
_F455 	!WORD	_D092+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B490
	!WORD	_B490-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D087+0
_F456 	!WORD	_D087+0		
	!BYTE	$24			; BRNE	_B492
	!WORD	_B492-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B496
	!WORD	_B496-*
_B494 
; lisp/s-expr.pla: 1700:           if eval_expr(cond_expr=>car=>car)
; lisp/s-expr.pla: 1701:             eval_expr(cond_expr=>car=>cdr=>car) // Drop result
; lisp/s-expr.pla: 1702:             break
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F457 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B497
	!WORD	_B497-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F458 	!WORD	_C033		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B495
	!WORD	_B495-*
; lisp/s-expr.pla: 1703:           fin
_B497 
_B498 
; lisp/s-expr.pla: 1704:           cond_expr = cond_expr=>cdr
; lisp/s-expr.pla: 1705:         loop
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B496 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4E			; BRTRU	_B494
	!WORD	_B494-*
_B495 
; lisp/s-expr.pla: 1706:       elsif prog_car=>car == sym_if // Inline IF(...) evaluation
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
_B492 
; lisp/s-expr.pla: 1707:         cond_expr = prog_car=>cdr
; lisp/s-expr.pla: 1708:         if eval_expr(cond_expr=>car)
; lisp/s-expr.pla: 1709:           eval_expr(cond_expr=>cdr=>car) // Drop result
; lisp/s-expr.pla: 1710:         elsif cond_expr=>cdr=>cdr=>car
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D088+0
_F459 	!WORD	_D088+0		
	!BYTE	$24			; BRNE	_B499
	!WORD	_B499-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F460 	!WORD	_C033		
	!BYTE	$4C			; BRFLS	_B500
	!WORD	_B500-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F461 	!WORD	_C033		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B501
	!WORD	_B501-*
_B500 
; lisp/s-expr.pla: 1711:           eval_expr(cond_expr=>cdr=>cdr=>car) // Drop result
; lisp/s-expr.pla: 1712:         fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B502
	!WORD	_B502-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F462 	!WORD	_C033		
	!BYTE	$30			; DROP 
_B502 
_B501 
; lisp/s-expr.pla: 1713:       else
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
_B499 
; lisp/s-expr.pla: 1714:         eval_expr(prog_car) // Drop result
; lisp/s-expr.pla: 1715:       fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C033
_F463 	!WORD	_C033		
	!BYTE	$30			; DROP 
_B493 
; lisp/s-expr.pla: 1716:     //else Atom - skip, i.e. GO() destination
; lisp/s-expr.pla: 1717:     fin
_B490 
_B491 
; lisp/s-expr.pla: 1718:     if prog_return // Check for RETURN()
; lisp/s-expr.pla: 1719:       expr        = prog_return ^ NULL_HACK
; lisp/s-expr.pla: 1720:       prog_return = NULL
; lisp/s-expr.pla: 1721:       prog_expr   = NULL
; lisp/s-expr.pla: 1722:     fin
	!BYTE	$6A			; LAW	_D093+0
_F464 	!WORD	_D093+0		
	!BYTE	$4C			; BRFLS	_B503
	!WORD	_B503-*
	!BYTE	$6A			; LAW	_D093+0
_F465 	!WORD	_D093+0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D093+0
_F466 	!WORD	_D093+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D092+0
_F467 	!WORD	_D092+0		
_B503 
_B504 
; lisp/s-expr.pla: 1723:   loop
_B488 
	!BYTE	$6A			; LAW	_D092+0
_F468 	!WORD	_D092+0		
	!BYTE	$AC			; BRAND	_B489
	!WORD	_B489-*
	!BYTE	$6A			; LAW	_D093+0
_F469 	!WORD	_D093+0		
	!BYTE	$80			; NOT
_B489 
	!BYTE	$4E			; BRTRU	_B486
	!WORD	_B486-*
_B487 
; lisp/s-expr.pla: 1724:   prog = prog_enter
; lisp/s-expr.pla: 1725:   return expr
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D091+0
_F470 	!WORD	_D091+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$0A			; LEAVE	10
; lisp/s-expr.pla: 1726: end
; lisp/s-expr.pla: 1727: 
; lisp/s-expr.pla: 1728: def natv_return(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C072 					; natv_return()
; lisp/s-expr.pla: 1729:   prog_return = eval_expr(expr=>car) ^ NULL_HACK
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1730:   return NULL // This value will be dropped in natv_prog
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F471 	!WORD	_C033		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$7A			; SAW	_D093+0
_F472 	!WORD	_D093+0		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1731: end
; lisp/s-expr.pla: 1732: 
; lisp/s-expr.pla: 1733: def natv_go(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C073 					; natv_go()
; lisp/s-expr.pla: 1734:   expr   = expr=>car
	!BYTE	$58,$04,$02		; ENTER	4,2
; lisp/s-expr.pla: 1735:   symptr = prog // Scan prog list looking for matching SYM
; lisp/s-expr.pla: 1736:   while symptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D091+0
_F473 	!WORD	_D091+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B507
	!WORD	_B507-*
_B505 
; lisp/s-expr.pla: 1737:     if symptr=>car == expr
; lisp/s-expr.pla: 1738:       prog_expr = symptr=>cdr
; lisp/s-expr.pla: 1739:       return NULL
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$24			; BRNE	_B508
	!WORD	_B508-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D092+0
_F474 	!WORD	_D092+0		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1740:     fin
_B508 
_B509 
; lisp/s-expr.pla: 1741:     symptr = symptr=>cdr
; lisp/s-expr.pla: 1742:   loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B507 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B505
	!WORD	_B505-*
_B506 
; lisp/s-expr.pla: 1743:   err_expr = expr
; lisp/s-expr.pla: 1744:   throw(exception, ERR_BAD_GO)
; lisp/s-expr.pla: 1745:   return NULL
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D068+0
_F475 	!WORD	_D068+0		
	!BYTE	$6A			; LAW	_D067+0
_F476 	!WORD	_D067+0		
	!BYTE	$5E,$F2			; CFFB	-14
	!BYTE	$54			; CALL	_X062
_F477 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1746: end
; lisp/s-expr.pla: 1747: 
; lisp/s-expr.pla: 1748: def natv_set(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C074 					; natv_set()
; lisp/s-expr.pla: 1749:   return set_assoc(eval_expr(expr=>car), eval_expr(expr=>cdr=>car))=>cdr
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F478 	!WORD	_C033		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F479 	!WORD	_C033		
	!BYTE	$54			; CALL	_C026
_F480 	!WORD	_C026		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1750: end
; lisp/s-expr.pla: 1751: 
; lisp/s-expr.pla: 1752: def natv_setq(symptr, expr)
					; symptr -> [0]
					; expr -> [2]
_C075 					; natv_setq()
; lisp/s-expr.pla: 1753:   return set_assoc(expr=>car, eval_expr(expr=>cdr=>car))=>cdr
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C033
_F481 	!WORD	_C033		
	!BYTE	$54			; CALL	_C026
_F482 	!WORD	_C026		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$5A,$04			; LEAVE	4
; lisp/s-expr.pla: 1754: end
; lisp/s-expr.pla: 1755: 
; lisp/s-expr.pla: 1756: //
; lisp/s-expr.pla: 1757: // Debug
; lisp/s-expr.pla: 1758: //
; lisp/s-expr.pla: 1759: 
; lisp/s-expr.pla: 1760: //def natv_syms(symptr, expr)
; lisp/s-expr.pla: 1761: //  var count
; lisp/s-expr.pla: 1762: //  byte h
; lisp/s-expr.pla: 1763: //
; lisp/s-expr.pla: 1764: //  count = 0
; lisp/s-expr.pla: 1765: //  for h = 0 to HASH_SIZE-1
; lisp/s-expr.pla: 1766: //    symptr = hashtbl[h]
; lisp/s-expr.pla: 1767: //    puti(h); puts(" -----\n")
; lisp/s-expr.pla: 1768: //    while symptr
; lisp/s-expr.pla: 1769: //      print_atom(symptr); putc(':')
; lisp/s-expr.pla: 1770: //      if symptr=>natv
; lisp/s-expr.pla: 1771: //        puts("NATIVE")
; lisp/s-expr.pla: 1772: //      elsif symptr=>lambda
; lisp/s-expr.pla: 1773: //        print_expr(symptr=>lambda)
; lisp/s-expr.pla: 1774: //      elsif symptr=>apval
; lisp/s-expr.pla: 1775: //        print_expr(symptr=>apval ^ NULL_HACK)
; lisp/s-expr.pla: 1776: //      elsif symptr=>array
; lisp/s-expr.pla: 1777: //        print_expr(symptr)
; lisp/s-expr.pla: 1778: //      elsif symptr=>array
; lisp/s-expr.pla: 1779: //        print_expr(assoc(symptr))
; lisp/s-expr.pla: 1780: //      fin
; lisp/s-expr.pla: 1781: //      putln
; lisp/s-expr.pla: 1782: //      count++
; lisp/s-expr.pla: 1783: //      if !(count & 15)
; lisp/s-expr.pla: 1784: //        getc()
; lisp/s-expr.pla: 1785: //      fin
; lisp/s-expr.pla: 1786: //      symptr = symptr=>link
; lisp/s-expr.pla: 1787: //    loop
; lisp/s-expr.pla: 1788: //  next
; lisp/s-expr.pla: 1789: //  return new_int(count, 0) // Total symbols
; lisp/s-expr.pla: 1790: //end
; lisp/s-expr.pla: 1791: 
; lisp/s-expr.pla: 1792: //
; lisp/s-expr.pla: 1793: // Install default functions
; lisp/s-expr.pla: 1794: //
; lisp/s-expr.pla: 1795: 
; lisp/s-expr.pla: 1796: sym_nil                   = new_sym("NIL")
_INIT 
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4E,$49,$4C
	!BYTE	$54			; CALL	_C015
_F483 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D080+0
_F484 	!WORD	_D080+0		
; lisp/s-expr.pla: 1797: sym_nil=>apval            = NULL_HACK
; lisp/s-expr.pla: 1798: sym_true                  = new_sym("*T*")
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_D080+0
_F485 	!WORD	_D080+0		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$2A,$54,$2A
	!BYTE	$54			; CALL	_C015
_F486 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D081+0
_F487 	!WORD	_D081+0		
; lisp/s-expr.pla: 1799: sym_true=>apval           = sym_true ^ NULL_HACK
; lisp/s-expr.pla: 1800: new_sym("T")=>apval       = sym_true ^ NULL_HACK
	!BYTE	$6A			; LAW	_D081+0
_F488 	!WORD	_D081+0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$6A			; LAW	_D081+0
_F489 	!WORD	_D081+0		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D081+0
_F490 	!WORD	_D081+0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$54
	!BYTE	$54			; CALL	_C015
_F491 	!WORD	_C015		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1801: new_sym("F")=>apval       = NULL_HACK
	!BYTE	$02			; CN	1
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$46
	!BYTE	$54			; CALL	_C015
_F492 	!WORD	_C015		
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1802: sym_lambda                = new_sym("LAMBDA")
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$4C,$41,$4D,$42,$44,$41
	!BYTE	$54			; CALL	_C015
_F493 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D083+0
_F494 	!WORD	_D083+0		
; lisp/s-expr.pla: 1803: sym_funarg                = new_sym("FUNARG")
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$46,$55,$4E,$41,$52,$47
	!BYTE	$54			; CALL	_C015
_F495 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D084+0
_F496 	!WORD	_D084+0		
; lisp/s-expr.pla: 1804: sym_macro                 = new_sym("MACRO")
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$4D,$41,$43,$52,$4F
	!BYTE	$54			; CALL	_C015
_F497 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D086+0
_F498 	!WORD	_D086+0		
; lisp/s-expr.pla: 1805: sym_cond                  = new_sym("COND")
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$4F,$4E,$44
	!BYTE	$54			; CALL	_C015
_F499 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D087+0
_F500 	!WORD	_D087+0		
; lisp/s-expr.pla: 1806: sym_if                    = new_sym("IF")
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$49,$46
	!BYTE	$54			; CALL	_C015
_F501 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D088+0
_F502 	!WORD	_D088+0		
; lisp/s-expr.pla: 1807: sym_set                   = new_sym("SET")
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$53,$45,$54
	!BYTE	$54			; CALL	_C015
_F503 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D085+0
_F504 	!WORD	_D085+0		
; lisp/s-expr.pla: 1808: sym_label                 = new_sym("LABEL")
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$4C,$41,$42,$45,$4C
	!BYTE	$54			; CALL	_C015
_F505 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D089+0
_F506 	!WORD	_D089+0		
; lisp/s-expr.pla: 1809: sym_quote                 = new_sym("QUOTE")
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$51,$55,$4F,$54,$45
	!BYTE	$54			; CALL	_C015
_F507 	!WORD	_C015		
	!BYTE	$7A			; SAW	_D082+0
_F508 	!WORD	_D082+0		
; lisp/s-expr.pla: 1810: sym_quote=>natv           = @natv_quote
; lisp/s-expr.pla: 1811: new_sym("CAR")=>natv      = @natv_car
	!BYTE	$26			; LA	_C048+0
_F509 	!WORD	_C048+0		
	!BYTE	$6A			; LAW	_D082+0
_F510 	!WORD	_D082+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_C046+0
_F511 	!WORD	_C046+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$43,$41,$52
	!BYTE	$54			; CALL	_C015
_F512 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1812: new_sym("CDR")=>natv      = @natv_cdr
	!BYTE	$26			; LA	_C047+0
_F513 	!WORD	_C047+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$43,$44,$52
	!BYTE	$54			; CALL	_C015
_F514 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1813: new_sym("CONS")=>natv     = @natv_cons
	!BYTE	$26			; LA	_C044+0
_F515 	!WORD	_C044+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$4F,$4E,$53
	!BYTE	$54			; CALL	_C015
_F516 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1814: new_sym("LIST")=>natv     = @natv_list
	!BYTE	$26			; LA	_C045+0
_F517 	!WORD	_C045+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4C,$49,$53,$54
	!BYTE	$54			; CALL	_C015
_F518 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1815: new_sym("ATOM")=>natv     = @natv_atom
	!BYTE	$26			; LA	_C037+0
_F519 	!WORD	_C037+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$41,$54,$4F,$4D
	!BYTE	$54			; CALL	_C015
_F520 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1816: new_sym("EQ")=>natv       = @natv_eq
	!BYTE	$26			; LA	_C039+0
_F521 	!WORD	_C039+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$45,$51
	!BYTE	$54			; CALL	_C015
_F522 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1817: new_sym("NUMBER?")=>natv  = @natv_numberp
	!BYTE	$26			; LA	_C041+0
_F523 	!WORD	_C041+0		
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$4E,$55,$4D,$42,$45,$52,$3F
	!BYTE	$54			; CALL	_C015
_F524 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1818: new_sym("NUMBER")=>natv   = @natv_number
	!BYTE	$26			; LA	_C040+0
_F525 	!WORD	_C040+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$4E,$55,$4D,$42,$45,$52
	!BYTE	$54			; CALL	_C015
_F526 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1819: new_sym("NOT")=>natv      = @natv_null
	!BYTE	$26			; LA	_C038+0
_F527 	!WORD	_C038+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$4E,$4F,$54
	!BYTE	$54			; CALL	_C015
_F528 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1820: new_sym("AND")=>natv      = @natv_and
	!BYTE	$26			; LA	_C042+0
_F529 	!WORD	_C042+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$41,$4E,$44
	!BYTE	$54			; CALL	_C015
_F530 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1821: new_sym("OR")=>natv       = @natv_or
	!BYTE	$26			; LA	_C043+0
_F531 	!WORD	_C043+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$4F,$52
	!BYTE	$54			; CALL	_C015
_F532 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1822: new_sym("NULL")=>natv     = @natv_null
	!BYTE	$26			; LA	_C038+0
_F533 	!WORD	_C038+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4E,$55,$4C,$4C
	!BYTE	$54			; CALL	_C015
_F534 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1823: new_sym("FUNCTION")=>natv = @natv_function
	!BYTE	$26			; LA	_C049+0
_F535 	!WORD	_C049+0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$46,$55,$4E,$43,$54,$49,$4F,$4E
	!BYTE	$54			; CALL	_C015
_F536 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1824: new_sym("DEFINE")=>natv   = @natv_define
	!BYTE	$26			; LA	_C050+0
_F537 	!WORD	_C050+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$44,$45,$46,$49,$4E,$45
	!BYTE	$54			; CALL	_C015
_F538 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1825: new_sym("ARRAY")=>natv    = @natv_array
	!BYTE	$26			; LA	_C062+0
_F539 	!WORD	_C062+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$41,$52,$52,$41,$59
	!BYTE	$54			; CALL	_C015
_F540 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1826: new_sym("ARRAY?")=>natv   = @natv_arrayp
	!BYTE	$26			; LA	_C059+0
_F541 	!WORD	_C059+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$41,$52,$52,$41,$59,$3F
	!BYTE	$54			; CALL	_C015
_F542 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1827: new_sym("CSET")=>natv     = @natv_cset
	!BYTE	$26			; LA	_C051+0
_F543 	!WORD	_C051+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$53,$45,$54
	!BYTE	$54			; CALL	_C015
_F544 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1828: new_sym("CSETQ")=>natv    = @natv_csetq
	!BYTE	$26			; LA	_C052+0
_F545 	!WORD	_C052+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$43,$53,$45,$54,$51
	!BYTE	$54			; CALL	_C015
_F546 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1829: new_sym(":=")=>natv       = @natv_csetq
	!BYTE	$26			; LA	_C052+0
_F547 	!WORD	_C052+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$3A,$3D
	!BYTE	$54			; CALL	_C015
_F548 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1830: new_sym("PRHEX")=>natv    = @natv_prhex
	!BYTE	$26			; LA	_C053+0
_F549 	!WORD	_C053+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$50,$52,$48,$45,$58
	!BYTE	$54			; CALL	_C015
_F550 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1831: new_sym("PRIN")=>natv     = @natv_prin
	!BYTE	$26			; LA	_C054+0
_F551 	!WORD	_C054+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$50,$52,$49,$4E
	!BYTE	$54			; CALL	_C015
_F552 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1832: new_sym("PRINT")=>natv    = @natv_print
	!BYTE	$26			; LA	_C055+0
_F553 	!WORD	_C055+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$50,$52,$49,$4E,$54
	!BYTE	$54			; CALL	_C015
_F554 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1833: new_sym("EVAL")=>natv     = @natv_eval
	!BYTE	$26			; LA	_C056+0
_F555 	!WORD	_C056+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$45,$56,$41,$4C
	!BYTE	$54			; CALL	_C015
_F556 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1834: new_sym("TRACE")=>natv    = @natv_trace
	!BYTE	$26			; LA	_C057+0
_F557 	!WORD	_C057+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$54,$52,$41,$43,$45
	!BYTE	$54			; CALL	_C015
_F558 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1835: new_sym("FOR")=>natv      = @natv_for
	!BYTE	$26			; LA	_C070+0
_F559 	!WORD	_C070+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$46,$4F,$52
	!BYTE	$54			; CALL	_C015
_F560 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1836: new_sym("COPY")=>natv     = @natv_copy
	!BYTE	$26			; LA	_C058+0
_F561 	!WORD	_C058+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$4F,$50,$59
	!BYTE	$54			; CALL	_C015
_F562 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1837: new_sym("PROG")=>natv     = @natv_prog
	!BYTE	$26			; LA	_C071+0
_F563 	!WORD	_C071+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$50,$52,$4F,$47
	!BYTE	$54			; CALL	_C015
_F564 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1838: new_sym("GO")=>natv       = @natv_go
	!BYTE	$26			; LA	_C073+0
_F565 	!WORD	_C073+0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$47,$4F
	!BYTE	$54			; CALL	_C015
_F566 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1839: new_sym("RETURN")=>natv   = @natv_return
	!BYTE	$26			; LA	_C072+0
_F567 	!WORD	_C072+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$52,$45,$54,$55,$52,$4E
	!BYTE	$54			; CALL	_C015
_F568 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1840: new_sym("SET")=>natv      = @natv_set
	!BYTE	$26			; LA	_C074+0
_F569 	!WORD	_C074+0		
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$53,$45,$54
	!BYTE	$54			; CALL	_C015
_F570 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1841: new_sym("SETQ")=>natv     = @natv_setq
	!BYTE	$26			; LA	_C075+0
_F571 	!WORD	_C075+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$53,$45,$54,$51
	!BYTE	$54			; CALL	_C015
_F572 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1842: new_sym("=")=>natv        = @natv_setq
	!BYTE	$26			; LA	_C075+0
_F573 	!WORD	_C075+0		
	!BYTE	$2E			; CS
	!BYTE	$01
	!BYTE	$3D
	!BYTE	$54			; CALL	_C015
_F574 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1843: new_sym("STRING?")=>natv  = @natv_stringp
	!BYTE	$26			; LA	_C064+0
_F575 	!WORD	_C064+0		
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$53,$54,$52,$49,$4E,$47,$3F
	!BYTE	$54			; CALL	_C015
_F576 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1844: new_sym("STRING")=>natv   = @natv_string
	!BYTE	$26			; LA	_C063+0
_F577 	!WORD	_C063+0		
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$53,$54,$52,$49,$4E,$47
	!BYTE	$54			; CALL	_C015
_F578 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1845: new_sym("SUBS")=>natv     = @natv_subs
	!BYTE	$26			; LA	_C065+0
_F579 	!WORD	_C065+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$53,$55,$42,$53
	!BYTE	$54			; CALL	_C015
_F580 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1846: new_sym("CATS")=>natv     = @natv_cats
	!BYTE	$26			; LA	_C066+0
_F581 	!WORD	_C066+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$43,$41,$54,$53
	!BYTE	$54			; CALL	_C015
_F582 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1847: new_sym("LENS")=>natv     = @natv_lens
	!BYTE	$26			; LA	_C067+0
_F583 	!WORD	_C067+0		
	!BYTE	$2E			; CS
	!BYTE	$04
	!BYTE	$4C,$45,$4E,$53
	!BYTE	$54			; CALL	_C015
_F584 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1848: new_sym("CHARS")=>natv    = @natv_chars
	!BYTE	$26			; LA	_C068+0
_F585 	!WORD	_C068+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$43,$48,$41,$52,$53
	!BYTE	$54			; CALL	_C015
_F586 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1849: new_sym("ASCII")=>natv    = @natv_ascii
	!BYTE	$26			; LA	_C069+0
_F587 	!WORD	_C069+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$41,$53,$43,$49,$49
	!BYTE	$54			; CALL	_C015
_F588 	!WORD	_C015		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$72			; SW
; lisp/s-expr.pla: 1850: //new_sym("SYMS")=>natv     = @natv_syms
; lisp/s-expr.pla: 1851: return modkeep | modinitkeep
	!BYTE	$2C,$00,$60		; CW	24576
	!BYTE	$5C			; RET
; lisp/s-expr.pla: 1852: done
_SYSFLAGS	=	0
_DEFCNT	=	77
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C050		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C051		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C052		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C053		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C054		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C055		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C056		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C057		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C058		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C059		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C060		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C061		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C062		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C063		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C064		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C065		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C066		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C067		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C068		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C069		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C070		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C071		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C072		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C073		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C074		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C075		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	56			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	59			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	36			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	58			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	36			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F361-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F363-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F364-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F365-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F367-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F368-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F369-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F370-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F372-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F373-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F375-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F376-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F377-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F378-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F379-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F382-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F384-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F385-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F386-_SEGBEGIN		
	!BYTE	55			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F388-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F389-_SEGBEGIN		
	!BYTE	59			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F390-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F391-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F393-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F395-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F396-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F398-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F400-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F401-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F402-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F403-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F404-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F405-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F406-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F407-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F408-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F410-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F411-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F413-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F414-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F415-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F418-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F420-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F421-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F422-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F423-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F425-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F426-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F429-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F430-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F431-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F432-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F433-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F434-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F435-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F436-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F438-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F440-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F441-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F442-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F443-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F444-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F446-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F448-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F449-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F451-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F452-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F453-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F456-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F458-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F460-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F461-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F464-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F465-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F466-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F467-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F468-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F469-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F470-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F473-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F475-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F477-_SEGBEGIN		
	!BYTE	62			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F478-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F479-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F482-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F483-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F485-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F487-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F488-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F489-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F490-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F491-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F492-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F493-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F495-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F496-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F497-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F498-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F501-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F504-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F505-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F506-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F507-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F510-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F513-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F515-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F516-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F517-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F518-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F519-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F520-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F521-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F522-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F523-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F525-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F526-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F527-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F528-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F529-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F530-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F532-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F533-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F534-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F535-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F538-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F540-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F541-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F543-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F544-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F545-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F546-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F547-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F548-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F549-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F552-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F561-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F562-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F563-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F564-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F565-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F568-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F569-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F570-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F571-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F572-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F573-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F574-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F578-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F579-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F580-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F581-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F582-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F583-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F586-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F587-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F588-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTH
	!BYTE	$D0,$D5,$D4,$48
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	9			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPAVAIL
	!BYTE	$C8,$C5,$C1,$D0,$C1,$D6,$C1,$C9,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	16			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: ISUGE
	!BYTE	$C9,$D3,$D5,$C7,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	25			; ESD INDEX
	; DCI STRING: ZERO32
	!BYTE	$DA,$C5,$D2,$CF,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: NEG32
	!BYTE	$CE,$C5,$C7,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: LOAD32
	!BYTE	$CC,$CF,$C1,$C4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	; DCI STRING: STORE32
	!BYTE	$D3,$D4,$CF,$D2,$C5,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	34			; ESD INDEX
	; DCI STRING: ADD32
	!BYTE	$C1,$C4,$C4,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	35			; ESD INDEX
	; DCI STRING: ADDI16
	!BYTE	$C1,$C4,$C4,$C9,$B1,$36
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	36			; ESD INDEX
	; DCI STRING: MULI16
	!BYTE	$CD,$D5,$CC,$C9,$B1,$36
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	42			; ESD INDEX
	; DCI STRING: I32TOS
	!BYTE	$C9,$B3,$B2,$D4,$CF,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	55			; ESD INDEX
	; DCI STRING: PUTI32
	!BYTE	$D0,$D5,$D4,$C9,$B3,$32
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	56			; ESD INDEX
	; DCI STRING: STR2EXT
	!BYTE	$D3,$D4,$D2,$B2,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	58			; ESD INDEX
	; DCI STRING: EXT2STR
	!BYTE	$C5,$D8,$D4,$B2,$D3,$D4,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	59			; ESD INDEX
	; DCI STRING: THROW
	!BYTE	$D4,$C8,$D2,$CF,$57
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	62			; ESD INDEX
	; DCI STRING: FMT_FPINT
	!BYTE	$C6,$CD,$D4,$DF,$C6,$D0,$C9,$CE,$54
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D064		
	; DCI STRING: FMT_FPFRAC
	!BYTE	$C6,$CD,$D4,$DF,$C6,$D0,$C6,$D2,$C1,$43
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D065		
	; DCI STRING: TRACE
	!BYTE	$D4,$D2,$C1,$C3,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D066		
	; DCI STRING: EXCEPTION
	!BYTE	$C5,$D8,$C3,$C5,$D0,$D4,$C9,$CF,$4E
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D067		
	; DCI STRING: ERR_EXPR
	!BYTE	$C5,$D2,$D2,$DF,$C5,$D8,$D0,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D068		
	; DCI STRING: HOOK_EVAL
	!BYTE	$C8,$CF,$CF,$CB,$DF,$C5,$D6,$C1,$4C
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D069		
	; DCI STRING: PRINT_EXPR
	!BYTE	$D0,$D2,$C9,$CE,$D4,$DF,$C5,$D8,$D0,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C017		
	; DCI STRING: EVAL_EXPR
	!BYTE	$C5,$D6,$C1,$CC,$DF,$C5,$D8,$D0,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C033		
	; DCI STRING: GC
	!BYTE	$C7,$43
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C007		
	; DCI STRING: NEW_CONS
	!BYTE	$CE,$C5,$D7,$DF,$C3,$CF,$CE,$53
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C009		
	; DCI STRING: NEW_INT
	!BYTE	$CE,$C5,$D7,$DF,$C9,$CE,$54
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C010		
	; DCI STRING: NEW_FLOAT
	!BYTE	$CE,$C5,$D7,$DF,$C6,$CC,$CF,$C1,$54
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C011		
	; DCI STRING: NEW_STRING
	!BYTE	$CE,$C5,$D7,$DF,$D3,$D4,$D2,$C9,$CE,$47
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C014		
	; DCI STRING: NEW_SYM
	!BYTE	$CE,$C5,$D7,$DF,$D3,$D9,$4D
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C015		
	; DCI STRING: PARSE_EXPR
	!BYTE	$D0,$C1,$D2,$D3,$C5,$DF,$C5,$D8,$D0,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C023		
	; DCI STRING: EVAL_QUOTE
	!BYTE	$C5,$D6,$C1,$CC,$DF,$D1,$D5,$CF,$D4,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C034		
	; DCI STRING: BOOL_PRED
	!BYTE	$C2,$CF,$CF,$CC,$DF,$D0,$D2,$C5,$44
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C036		
	!BYTE	$00			; END OF ESD
