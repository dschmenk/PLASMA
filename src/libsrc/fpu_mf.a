; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; libsrc/fpu_mf.pla: 0001: //
; libsrc/fpu_mf.pla: 0002: // MegaFlash Hardware-Accelerated FPU Library
; libsrc/fpu_mf.pla: 0003: // Drop-in replacement for fpu.pla using MegaFlash hardware acceleration
; libsrc/fpu_mf.pla: 0004: //
; libsrc/fpu_mf.pla: 0005: // This library maintains API compatibility with the standard SANE-based
; libsrc/fpu_mf.pla: 0006: // fpu.pla library, allowing users to switch between implementations
; libsrc/fpu_mf.pla: 0007: // by simply changing the import statement.
; libsrc/fpu_mf.pla: 0008: //
; libsrc/fpu_mf.pla: 0009: // HARDWARE-ACCELERATED OPERATIONS (direct MegaFlash FPU):
; libsrc/fpu_mf.pla: 0010: // - mul, div, sqrt
; libsrc/fpu_mf.pla: 0011: // - sin, cos, tan, atan
; libsrc/fpu_mf.pla: 0012: // - ln (natural log), exp (e^x)
; libsrc/fpu_mf.pla: 0013: //
; libsrc/fpu_mf.pla: 0014: // HARDWARE-ACCELERATED DERIVED OPERATIONS (using logarithm/trig identities):
; libsrc/fpu_mf.pla: 0015: // - neg(x) = x * -1 (hardware mul)
; libsrc/fpu_mf.pla: 0016: // - abs(x) = x if x >= 0, else neg(x)
; libsrc/fpu_mf.pla: 0017: // - log2(x) = ln(x) / ln(2)
; libsrc/fpu_mf.pla: 0018: // - log2(1+x) = ln(1+x) / ln(2)
; libsrc/fpu_mf.pla: 0019: // - ln(1+x) = ln(1 + x)
; libsrc/fpu_mf.pla: 0020: // - 2^x = e^(x * ln(2))
; libsrc/fpu_mf.pla: 0021: // - 2^x - 1 = e^(x*ln(2)) - 1
; libsrc/fpu_mf.pla: 0022: // - e^x - 1 = exp(x) - 1
; libsrc/fpu_mf.pla: 0023: // - e^(2x) - 1 = exp(2x) - 1
; libsrc/fpu_mf.pla: 0024: // - x^n = e^(n * ln(x))
; libsrc/fpu_mf.pla: 0025: // - x^y = e^(y * ln(x))
; libsrc/fpu_mf.pla: 0026: // - asin(x) = atan(x / sqrt(1 - x²))
; libsrc/fpu_mf.pla: 0027: // - acos(x) = π/2 - asin(x)
; libsrc/fpu_mf.pla: 0028: // - sinh(x) = (e^x - e^-x) / 2
; libsrc/fpu_mf.pla: 0029: // - cosh(x) = (e^x + e^-x) / 2
; libsrc/fpu_mf.pla: 0030: // - tanh(x) = sinh(x) / cosh(x)
; libsrc/fpu_mf.pla: 0031: // - sec(x) = 1 / cos(x)
; libsrc/fpu_mf.pla: 0032: // - csc(x) = 1 / sin(x)
; libsrc/fpu_mf.pla: 0033: // - cot(x) = 1 / tan(x)
; libsrc/fpu_mf.pla: 0034: //
; libsrc/fpu_mf.pla: 0035: // These functions all use hardware acceleration and maintain full precision
; libsrc/fpu_mf.pla: 0036: // by leveraging the MegaFlash FPU's native operations combined with
; libsrc/fpu_mf.pla: 0037: // mathematical identities and properties of logarithms/exponentials.
; libsrc/fpu_mf.pla: 0038: //
; libsrc/fpu_mf.pla: 0039: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0220 // Version built against
					; _SYSVER_ = 544
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $30
					; MACHID_MEM = 48
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     const vid80col    = $0800
					; vid80col = 2048
; inc/cmdsys.plh: 0038:     //
; inc/cmdsys.plh: 0039:     // Module don't free memory
; inc/cmdsys.plh: 0040:     //
; inc/cmdsys.plh: 0041:     const modflagkeep = $1000
					; modflagkeep = 4096
; inc/cmdsys.plh: 0042:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0043:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     // CMD exported interface table
; inc/cmdsys.plh: 0046:     //
; inc/cmdsys.plh: 0047:     struc t_cmdsys
; inc/cmdsys.plh: 0048:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0049:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0050:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0051:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0052:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0053:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0054:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0055:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0056:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0057:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0058:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0059:         word sysexec[] // Apple II specific
					; sysexec = 19
; inc/cmdsys.plh: 0060:         byte refcons   // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0061:         byte devcons   // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0062:         word lookupsym
					; lookupsym = 21
; inc/cmdsys.plh: 0063:         word _sysflags_ // Actual system flags (read only, don't write)
					; _sysflags_ = 23
; inc/cmdsys.plh: 0064:     end
					; t_cmdsys = 25
; inc/cmdsys.plh: 0065:     //
; inc/cmdsys.plh: 0066:     // CMD exported functions
; inc/cmdsys.plh: 0067:     //
; inc/cmdsys.plh: 0068:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0069:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0070:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0071:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0072:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0073:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0074: end
; libsrc/fpu_mf.pla: 0039: 
; libsrc/fpu_mf.pla: 0040: include "inc/sane.plh"
; inc/sane.plh: 0001: import sane
	; DCI STRING: SANE
	!BYTE	$D3,$C1,$CE,$45
					; SANE -> X028
; inc/sane.plh: 0002: //-----------------------------------------------------------
; inc/sane.plh: 0003: // Operation code masks.
; inc/sane.plh: 0004: //-----------------------------------------------------------
; inc/sane.plh: 0005: const FOADD     = $0000     // add
					; FOADD = 0
; inc/sane.plh: 0006: const FOSUB     = $0002     // subtract
					; FOSUB = 2
; inc/sane.plh: 0007: const FOMUL     = $0004     // multiply
					; FOMUL = 4
; inc/sane.plh: 0008: const FODIV     = $0006     // divide
					; FODIV = 6
; inc/sane.plh: 0009: const FOCMP     = $0008     // compare, no exception from unordered
					; FOCMP = 8
; inc/sane.plh: 0010: const FOCPX     = $000A     // compare, signal invalid if unordered
					; FOCPX = 10
; inc/sane.plh: 0011: const FOREM     = $000C     // remainder
					; FOREM = 12
; inc/sane.plh: 0012: const FOZ2X     = $000E     // convert to extended
					; FOZ2X = 14
; inc/sane.plh: 0013: const FOX2Z     = $0010     // convert from extended
					; FOX2Z = 16
; inc/sane.plh: 0014: const FOSQRT    = $0012     // square root
					; FOSQRT = 18
; inc/sane.plh: 0015: const FORTI     = $0014     // round to integral value
					; FORTI = 20
; inc/sane.plh: 0016: const FOTTI     = $0016     // truncate to integral value
					; FOTTI = 22
; inc/sane.plh: 0017: const FOSCALB   = $0018     // binary scale
					; FOSCALB = 24
; inc/sane.plh: 0018: const FOLOGB    = $001A     // binary log
					; FOLOGB = 26
; inc/sane.plh: 0019: const FOCLASS   = $001C     // classify
					; FOCLASS = 28
; inc/sane.plh: 0020: const FONEXT    = $001E     // next-after
					; FONEXT = 30
; inc/sane.plh: 0021: //
; inc/sane.plh: 0022: const FOSETENV  = $0001     // set environment
					; FOSETENV = 1
; inc/sane.plh: 0023: const FOGETENV  = $0003     // get environment
					; FOGETENV = 3
; inc/sane.plh: 0024: const FOSETHV   = $0005     // set halt vector
					; FOSETHV = 5
; inc/sane.plh: 0025: const FOGETHV   = $0007     // get halt vector
					; FOGETHV = 7
; inc/sane.plh: 0026: const FOD2B     = $0009     // convert decimal to binary
					; FOD2B = 9
; inc/sane.plh: 0027: const FOB2D     = $000B     // convert binary to decimal
					; FOB2D = 11
; inc/sane.plh: 0028: const FONEG     = $000D     // negate
					; FONEG = 13
; inc/sane.plh: 0029: const FOABS     = $000F     // absolute value
					; FOABS = 15
; inc/sane.plh: 0030: const FOCPYSGN  = $0011     // copy sign
					; FOCPYSGN = 17
; inc/sane.plh: 0031: // UNDEFINED    = $0013
; inc/sane.plh: 0032: const FOSETXCP  = $0015     // set exception
					; FOSETXCP = 21
; inc/sane.plh: 0033: const FOPROCENTRY = $0017   // procedure-entry
					; FOPROCENTRY = 23
; inc/sane.plh: 0034: const FOPROCEXIT = $0019    // procedure-exit
					; FOPROCEXIT = 25
; inc/sane.plh: 0035: const FOTESTXCP = $001B     // test exception
					; FOTESTXCP = 27
; inc/sane.plh: 0036: // UNDEFINED    = $001D
; inc/sane.plh: 0037: // UNDEFINED    = $001F
; inc/sane.plh: 0038: //-----------------------------------------------------------
; inc/sane.plh: 0039: // Operand format masks.
; inc/sane.plh: 0040: //-----------------------------------------------------------
; inc/sane.plh: 0041: const FFEXT     = $0000     // extended -- 80-bit float
					; FFEXT = 0
; inc/sane.plh: 0042: const FFDBL     = $0100     // double   -- 64-bit float
					; FFDBL = 256
; inc/sane.plh: 0043: const FFSGL     = $0200     // single   -- 32-bit float
					; FFSGL = 512
; inc/sane.plh: 0044: // UNDEFINED    = $0300
; inc/sane.plh: 0045: const FFINT     = $0400     // integer  -- 16-bit integer
					; FFINT = 1024
; inc/sane.plh: 0046: const FFCOMP    = $0500     // comp     -- 64-bit integer
					; FFCOMP = 1280
; inc/sane.plh: 0047: // UNDEFINED    = $0600
; inc/sane.plh: 0048: // UNDEFINED    = $0700
; inc/sane.plh: 0049: //-----------------------------------------------------------
; inc/sane.plh: 0050: // Class.
; inc/sane.plh: 0051: //-----------------------------------------------------------
; inc/sane.plh: 0052: const FCSNAN    = $FC       // -4: signaling NAN
					; FCSNAN = 252
; inc/sane.plh: 0053: const FCQNAN    = $FD       // -3: quiet NAN
					; FCQNAN = 253
; inc/sane.plh: 0054: const FCINF     = $FE       // -2: infinite
					; FCINF = 254
; inc/sane.plh: 0055: const FCZERO    = $FF       // -1: zero
					; FCZERO = 255
; inc/sane.plh: 0056: const FCNORM    = $00       //  0: normal
					; FCNORM = 0
; inc/sane.plh: 0057: const FCDENORM  = $01       //  1: denormal
					; FCDENORM = 1
; inc/sane.plh: 0058: //-----------------------------------------------------------
; inc/sane.plh: 0059: // Exceptions.
; inc/sane.plh: 0060: //-----------------------------------------------------------
; inc/sane.plh: 0061: const FBINVALID = $01
					; FBINVALID = 1
; inc/sane.plh: 0062: const FBUFLOW   = $02
					; FBUFLOW = 2
; inc/sane.plh: 0063: const FBOFLOW   = $04
					; FBOFLOW = 4
; inc/sane.plh: 0064: const FBDIVZER  = $08
					; FBDIVZER = 8
; inc/sane.plh: 0065: const FBINEXACT = $10
					; FBINEXACT = 16
; inc/sane.plh: 0066: //-----------------------------------------------------------
; inc/sane.plh: 0067: // Elementary function operation code masks.
; inc/sane.plh: 0068: //-----------------------------------------------------------
; inc/sane.plh: 0069: const FOLNX     = $0000     // base-e log
					; FOLNX = 0
; inc/sane.plh: 0070: const FOLOG2X   = $0002     // base-2 log
					; FOLOG2X = 2
; inc/sane.plh: 0071: const FOLN1X    = $0004     // ln (1 + x)
					; FOLN1X = 4
; inc/sane.plh: 0072: const FOLOG21X  = $0006     // log2 (1 + x)
					; FOLOG21X = 6
; inc/sane.plh: 0073: const FOEXPX    = $0008     // base-e exponential
					; FOEXPX = 8
; inc/sane.plh: 0074: const FOEXP2X   = $000A     // base-2 exponential
					; FOEXP2X = 10
; inc/sane.plh: 0075: const FOEXP1X   = $000C     // exp (x) - 1
					; FOEXP1X = 12
; inc/sane.plh: 0076: const FOEXP21X  = $000E     // exp2 (x) - 1
					; FOEXP21X = 14
; inc/sane.plh: 0077: const FOXPWRI   = $0010     // integer exponentiation
					; FOXPWRI = 16
; inc/sane.plh: 0078: const FOXPWRY   = $0012     // general exponentiation
					; FOXPWRY = 18
; inc/sane.plh: 0079: const FOCOMPND  = $0014     // compound
					; FOCOMPND = 20
; inc/sane.plh: 0080: const FOANNUIT  = $0016     // annuity
					; FOANNUIT = 22
; inc/sane.plh: 0081: const FOATANX   = $0018     // arctangent
					; FOATANX = 24
; inc/sane.plh: 0082: const FOSINX    = $001A     // sine
					; FOSINX = 26
; inc/sane.plh: 0083: const FOCOSX    = $001C     // cosine
					; FOCOSX = 28
; inc/sane.plh: 0084: const FOTANX    = $001E     // tangent
					; FOTANX = 30
; inc/sane.plh: 0085: const FORANDX   = $0020     // random
					; FORANDX = 32
; inc/sane.plh: 0086: //-----------------------------------------------------------
; inc/sane.plh: 0087: // NaN error codes.
; inc/sane.plh: 0088: //-----------------------------------------------------------
; inc/sane.plh: 0089: const NANSQRT   = 1         // Invalid square root such as sqrt(-1).
					; NANSQRT = 1
; inc/sane.plh: 0090: const NANADD    = 2         // Invalid addition such as +INF - +INF.
					; NANADD = 2
; inc/sane.plh: 0091: const NANDIV    = 4         // Invalid division such as 0/0.
					; NANDIV = 4
; inc/sane.plh: 0092: const NANMUL    = 8         // Invalid multiply such as 0 * INF.
					; NANMUL = 8
; inc/sane.plh: 0093: const NANREM    = 9         // Invalid remainder or mod such as x REM 0.
					; NANREM = 9
; inc/sane.plh: 0094: const NANASCBIN = 17        // Attempt to convert invalid ASCII string.
					; NANASCBIN = 17
; inc/sane.plh: 0095: const NANCOMP   = 20        // Result of converting comp NaN to floating.
					; NANCOMP = 20
; inc/sane.plh: 0096: const NANZERO   = 21        // Attempt to create a NaN with a zero code.
					; NANZERO = 21
; inc/sane.plh: 0097: const NANTRIG   = 33        // Invalid argument to trig routine.
					; NANTRIG = 33
; inc/sane.plh: 0098: const NANINVTRIG = 34       // Invalid argument to inverse trig routine.
					; NANINVTRIG = 34
; inc/sane.plh: 0099: const NANLOG    = 36        // Invalid argument to log routine.
					; NANLOG = 36
; inc/sane.plh: 0100: const NANPOWER  = 37        // Invalid argument to x^i or x^y routine.
					; NANPOWER = 37
; inc/sane.plh: 0101: const NANFINAN  = 38        // Invalid argument to financial function.
					; NANFINAN = 38
; inc/sane.plh: 0102: const NANINIT   = 255       // Uninitialized storage.
					; NANINIT = 255
; inc/sane.plh: 0103: //-----------------------------------------------------------
; inc/sane.plh: 0104: // Comparison results.
; inc/sane.plh: 0105: //-----------------------------------------------------------
; inc/sane.plh: 0106: const FCMPGT    = $4040     // Greater Than
					; FCMPGT = 16448
; inc/sane.plh: 0107: const FCMPLT    = $8080     // Less Than
					; FCMPLT = 32896
; inc/sane.plh: 0108: const FCMPEQ    = $0002     // EQual
					; FCMPEQ = 2
; inc/sane.plh: 0109: const FCMPUN    = $0101     // UNordered
					; FCMPUN = 257
; inc/sane.plh: 0110: //-----------------------------------------------------------
; inc/sane.plh: 0111: //
; inc/sane.plh: 0112: // Data types
; inc/sane.plh: 0113: //
; inc/sane.plh: 0114: struc t_single
; inc/sane.plh: 0115:     byte[3] s_mantissa
					; s_mantissa = 0
; inc/sane.plh: 0116:     byte    s_exponent
					; s_exponent = 3
; inc/sane.plh: 0117: end
					; t_single = 4
; inc/sane.plh: 0118: struc t_double
; inc/sane.plh: 0119:     byte[6] d_mantissa
					; d_mantissa = 0
; inc/sane.plh: 0120:     word    d_exponent
					; d_exponent = 6
; inc/sane.plh: 0121: end
					; t_double = 8
; inc/sane.plh: 0122: struc t_extended
; inc/sane.plh: 0123:     byte[8] x_mantissa
					; x_mantissa = 0
; inc/sane.plh: 0124:     word    x_exponent
					; x_exponent = 8
; inc/sane.plh: 0125: end
					; t_extended = 10
; inc/sane.plh: 0126: struc t_bigint
; inc/sane.plh: 0127:     byte[8] l_int
					; l_int = 0
; inc/sane.plh: 0128: end
					; t_bigint = 8
; inc/sane.plh: 0129: //
; inc/sane.plh: 0130: // SANE PLASMA interface
; inc/sane.plh: 0131: //
; inc/sane.plh: 0132: struc t_sane
; inc/sane.plh: 0133:     word initFP
					; initFP = 0
; inc/sane.plh: 0134:     word haltFP
					; haltFP = 2
; inc/sane.plh: 0135:     word op0FP
					; op0FP = 4
; inc/sane.plh: 0136:     word op1FP
					; op1FP = 6
; inc/sane.plh: 0137:     word op2FP
					; op2FP = 8
; inc/sane.plh: 0138:     word op3FP
					; op3FP = 10
; inc/sane.plh: 0139:     word op1ELEM
					; op1ELEM = 12
; inc/sane.plh: 0140:     word op2ELEM
					; op2ELEM = 14
; inc/sane.plh: 0141:     word op3ELEM
					; op3ELEM = 16
; inc/sane.plh: 0142:     word saveZP
					; saveZP = 18
; inc/sane.plh: 0143:     word restoreZP
					; restoreZP = 20
; inc/sane.plh: 0144: end
					; t_sane = 22
; inc/sane.plh: 0145: end
; libsrc/fpu_mf.pla: 0040: 
; libsrc/fpu_mf.pla: 0041: include "inc/fpstr.plh"
; inc/fpstr.plh: 0001: import fpstr
	; DCI STRING: FPSTR
	!BYTE	$C6,$D0,$D3,$D4,$52
					; FPSTR -> X029
; inc/fpstr.plh: 0002: //
; inc/fpstr.plh: 0003: // String formatting bits
; inc/fpstr.plh: 0004: //
; inc/fpstr.plh: 0005: const FPSTR_FIXED = 1 // Fixed count of fractional digits
					; FPSTR_FIXED = 1
; inc/fpstr.plh: 0006: const FPSTR_FLOAT = 0 // Floating count of fractional digits
					; FPSTR_FLOAT = 0
; inc/fpstr.plh: 0007: const FPSTR_STRIP = 2 // Strip trailing fractional zeros
					; FPSTR_STRIP = 2
; inc/fpstr.plh: 0008: const FPSTR_EXP   = 4 // Force exponential format
					; FPSTR_EXP = 4
; inc/fpstr.plh: 0009: const FPSTR_FLEX  = 8 // Flexible switch to EXP format if over/underflow
					; FPSTR_FLEX = 8
; inc/fpstr.plh: 0010: //
; inc/fpstr.plh: 0011: // Parse string into decrecord, return SANE conversion output
; inc/fpstr.plh: 0012: //
; inc/fpstr.plh: 0013: predef str2ext(str, ext)#1
					; STR2EXT -> X030
; inc/fpstr.plh: 0014: //
; inc/fpstr.plh: 0015: // Convert extended FP to string using , return string
; inc/fpstr.plh: 0016: //
; inc/fpstr.plh: 0017: predef ext2str(ext, str, intdigits, fracdigits, format)#1
					; EXT2STR -> X031
; inc/fpstr.plh: 0018: end
; libsrc/fpu_mf.pla: 0041: 
; libsrc/fpu_mf.pla: 0042: include "inc/megaflash.plh"
; inc/megaflash.plh: 0001: //
; inc/megaflash.plh: 0002: // MegaFlash Hardware Constants
; inc/megaflash.plh: 0003: // For Apple IIc/IIc+ with MegaFlash storage device
; inc/megaflash.plh: 0004: //
; inc/megaflash.plh: 0005: import megaflash
	; DCI STRING: MEGAFLASH
	!BYTE	$CD,$C5,$C7,$C1,$C6,$CC,$C1,$D3,$48
					; MEGAFLASH -> X032
; inc/megaflash.plh: 0006: //
; inc/megaflash.plh: 0007: // MegaFlash I/O Registers (Slot 4)
; inc/megaflash.plh: 0008: //
; inc/megaflash.plh: 0009: const MF_SLOT       = 4
					; MF_SLOT = 4
; inc/megaflash.plh: 0010: const MF_CMDREG     = $C480     // Command register
					; MF_CMDREG = 50304
; inc/megaflash.plh: 0011: const MF_PARAMREG   = $C481     // Parameter register (read/write)
					; MF_PARAMREG = 50305
; inc/megaflash.plh: 0012: const MF_STATUSREG  = $C482     // Status register
					; MF_STATUSREG = 50306
; inc/megaflash.plh: 0013: const MF_IDREG      = $C483     // ID register
					; MF_IDREG = 50307
; inc/megaflash.plh: 0014: 
; inc/megaflash.plh: 0015: //
; inc/megaflash.plh: 0016: // MegaFlash FPU Commands
; inc/megaflash.plh: 0017: //
; inc/megaflash.plh: 0018: const MF_CMD_FADD   = $30       // Floating point add
					; MF_CMD_FADD = 48
; inc/megaflash.plh: 0019: const MF_CMD_FMUL   = $31       // Floating point multiply
					; MF_CMD_FMUL = 49
; inc/megaflash.plh: 0020: const MF_CMD_FDIV   = $32       // Floating point divide
					; MF_CMD_FDIV = 50
; inc/megaflash.plh: 0021: const MF_CMD_FSIN   = $33       // Floating point sine
					; MF_CMD_FSIN = 51
; inc/megaflash.plh: 0022: const MF_CMD_FCOS   = $34       // Floating point cosine
					; MF_CMD_FCOS = 52
; inc/megaflash.plh: 0023: const MF_CMD_FTAN   = $35       // Floating point tangent
					; MF_CMD_FTAN = 53
; inc/megaflash.plh: 0024: const MF_CMD_FATN   = $36       // Floating point arctangent
					; MF_CMD_FATN = 54
; inc/megaflash.plh: 0025: const MF_CMD_FLOG   = $37       // Floating point natural log
					; MF_CMD_FLOG = 55
; inc/megaflash.plh: 0026: const MF_CMD_FEXP   = $38       // Floating point exponential
					; MF_CMD_FEXP = 56
; inc/megaflash.plh: 0027: const MF_CMD_FSQR   = $39       // Floating point square root
					; MF_CMD_FSQR = 57
; inc/megaflash.plh: 0028: const MF_CMD_FOUT   = $3A       // Format floating point as string
					; MF_CMD_FOUT = 58
; inc/megaflash.plh: 0029: 
; inc/megaflash.plh: 0030: //
; inc/megaflash.plh: 0031: // MegaFlash Error Codes (in parameter buffer)
; inc/megaflash.plh: 0032: //
; inc/megaflash.plh: 0033: const MF_ERR_NONE       = $00   // No error
					; MF_ERR_NONE = 0
; inc/megaflash.plh: 0034: const MF_ERR_OVERFLOW   = $80   // Overflow error
					; MF_ERR_OVERFLOW = 128
; inc/megaflash.plh: 0035: const MF_ERR_DIV0       = $40   // Division by zero
					; MF_ERR_DIV0 = 64
; inc/megaflash.plh: 0036: const MF_ERR_ILLEGAL    = $20   // Illegal quantity
					; MF_ERR_ILLEGAL = 32
; inc/megaflash.plh: 0037: 
; inc/megaflash.plh: 0038: //
; inc/megaflash.plh: 0039: // Status Register Bits
; inc/megaflash.plh: 0040: //
; inc/megaflash.plh: 0041: const MF_STATUS_BUSY    = $80   // Busy flag (bit 7)
					; MF_STATUS_BUSY = 128
; inc/megaflash.plh: 0042: 
; inc/megaflash.plh: 0043: //
; inc/megaflash.plh: 0044: // MBF (Microsoft Binary Format) constants
; inc/megaflash.plh: 0045: //
; inc/megaflash.plh: 0046: const MBF_SIZE          = 6     // FAC/ARG size: exp + sign + 4 mantissa bytes
					; MBF_SIZE = 6
; inc/megaflash.plh: 0047: const MBF_EXT_SIZE      = 1     // Extension byte size
					; MBF_EXT_SIZE = 1
; inc/megaflash.plh: 0048: const MBF_TOTAL         = 13    // Total buffer size for FAC+ARG+EXT
					; MBF_TOTAL = 13
; inc/megaflash.plh: 0049: 
; inc/megaflash.plh: 0050: //
; inc/megaflash.plh: 0051: // SANE Extended Format constants (for conversion)
; inc/megaflash.plh: 0052: //
; inc/megaflash.plh: 0053: //const t_extended        = 10    // 80-bit extended precision size
; inc/megaflash.plh: 0054: 
; inc/megaflash.plh: 0055: end
; libsrc/fpu_mf.pla: 0042: 
; libsrc/fpu_mf.pla: 0043: 
; libsrc/fpu_mf.pla: 0044: //
; libsrc/fpu_mf.pla: 0045: // External interface to FPU library (same as fpu.pla)
; libsrc/fpu_mf.pla: 0046: //
; libsrc/fpu_mf.pla: 0047: predef reset, getEnv, setEnv(env), testExcept(except), setExcept(except), enterProc(pEnv), exitProc(env)
	!BYTE	$00			; END OF MODULE DEPENDENCIES
; libsrc/fpu_mf.pla: 0048: predef constPi, constE
; libsrc/fpu_mf.pla: 0049: predef pushInt(pInt), pushSgl(pSgl), pushDbl(pDbl), pushExt(pExt), pushStr(pStr)
; libsrc/fpu_mf.pla: 0050: predef pullInt(pInt), pullSgl(pSgl), pullDbl(pDbl), pullExt(pExt), pullStr(pStr,intdigits,fracdigits,format)
; libsrc/fpu_mf.pla: 0051: predef loadInt(pInt,reg), loadSgl(pSgl,reg), loadDbl(pDbl,reg), loadExt(pExt,reg), loadStr(pStr,reg)
; libsrc/fpu_mf.pla: 0052: predef storInt(pInt,reg), storSgl(pSgl,reg), storDbl(pDbl,reg), storExt(pExt,reg), storStr(pStr,intdigits,fracdigits,format,reg)
; libsrc/fpu_mf.pla: 0053: predef shiftUp, shiftDown, rotateUp, rotateDown, dup, swap, clear
; libsrc/fpu_mf.pla: 0054: predef add, sub, mul, div, rem
; libsrc/fpu_mf.pla: 0055: predef neg, abs, type, cmp, logb, scalb(scale), trunc, round, sqrt, squared
; libsrc/fpu_mf.pla: 0056: predef cos, sin, tan, atan, asin, acos, sinh, cosh, tanh, sec, csc, cot
; libsrc/fpu_mf.pla: 0057: predef log2X, log21X, lnX, ln1X, pow2X, pow21X, powEX, powE1X, powE21X, powXInt(powInt), powXY
; libsrc/fpu_mf.pla: 0058: predef compXY, annuityXY, randNum(pSeed)
; libsrc/fpu_mf.pla: 0059: 
; libsrc/fpu_mf.pla: 0060: //
; libsrc/fpu_mf.pla: 0061: // Export table (same structure as fpu.pla)
; libsrc/fpu_mf.pla: 0062: //
; libsrc/fpu_mf.pla: 0063: word fpu = @reset
_D110 					; fpu = @reset
_F000 	!WORD	_P000
; libsrc/fpu_mf.pla: 0064: word = @setEnv, @getEnv, @testExcept, @setExcept, @enterProc, @exitProc
_F001 	!WORD	_P002
_F002 	!WORD	_P001
_F003 	!WORD	_P003
_F004 	!WORD	_P004
_F005 	!WORD	_P005
_F006 	!WORD	_P006
; libsrc/fpu_mf.pla: 0065: word = @constPi, @constE
_F007 	!WORD	_P007
_F008 	!WORD	_P008
; libsrc/fpu_mf.pla: 0066: word = @pushInt, @pushSgl, @pushDbl, @pushExt, @pushStr
_F009 	!WORD	_P009
_F010 	!WORD	_P010
_F011 	!WORD	_P011
_F012 	!WORD	_P012
_F013 	!WORD	_P013
; libsrc/fpu_mf.pla: 0067: word = @pullInt, @pullSgl, @pullDbl, @pullExt, @pullStr
_F014 	!WORD	_P014
_F015 	!WORD	_P015
_F016 	!WORD	_P016
_F017 	!WORD	_P017
_F018 	!WORD	_P018
; libsrc/fpu_mf.pla: 0068: word = @loadInt, @loadSgl, @loadDbl, @loadExt, @loadStr
_F019 	!WORD	_P019
_F020 	!WORD	_P020
_F021 	!WORD	_P021
_F022 	!WORD	_P022
_F023 	!WORD	_P023
; libsrc/fpu_mf.pla: 0069: word = @storInt, @storSgl, @storDbl, @storExt, @storStr
_F024 	!WORD	_P024
_F025 	!WORD	_P025
_F026 	!WORD	_P026
_F027 	!WORD	_P027
_F028 	!WORD	_P028
; libsrc/fpu_mf.pla: 0070: word = @shiftUp, @shiftDown, @rotateUp, @rotateDown, @dup, @swap, @clear
_F029 	!WORD	_P029
_F030 	!WORD	_P030
_F031 	!WORD	_P031
_F032 	!WORD	_P032
_F033 	!WORD	_P033
_F034 	!WORD	_P034
_F035 	!WORD	_P035
; libsrc/fpu_mf.pla: 0071: word = @add, @sub, @mul, @div, @rem
_F036 	!WORD	_P036
_F037 	!WORD	_P037
_F038 	!WORD	_P038
_F039 	!WORD	_P039
_F040 	!WORD	_P040
; libsrc/fpu_mf.pla: 0072: word = @neg, @abs, @type, @cmp
_F041 	!WORD	_P041
_F042 	!WORD	_P042
_F043 	!WORD	_P043
_F044 	!WORD	_P044
; libsrc/fpu_mf.pla: 0073: word = @logb, @scalb, @trunc, @round, @sqrt, @squared
_F045 	!WORD	_P045
_F046 	!WORD	_P046
_F047 	!WORD	_P047
_F048 	!WORD	_P048
_F049 	!WORD	_P049
_F050 	!WORD	_P050
; libsrc/fpu_mf.pla: 0074: word = @cos, @sin, @tan, @atan, @asin, @acos, @sinh, @cosh, @tanh, @sec, @csc, @cot
_F051 	!WORD	_P051
_F052 	!WORD	_P052
_F053 	!WORD	_P053
_F054 	!WORD	_P054
_F055 	!WORD	_P055
_F056 	!WORD	_P056
_F057 	!WORD	_P057
_F058 	!WORD	_P058
_F059 	!WORD	_P059
_F060 	!WORD	_P060
_F061 	!WORD	_P061
_F062 	!WORD	_P062
; libsrc/fpu_mf.pla: 0075: 
; libsrc/fpu_mf.pla: 0076: word = @log2X, @log21X, @lnX, @ln1X, @pow2X, @pow21X, @powEX, @powE1X, @powE21X, @powXInt, @powXY
_F063 	!WORD	_P063
_F064 	!WORD	_P064
_F065 	!WORD	_P065
_F066 	!WORD	_P066
_F067 	!WORD	_P067
_F068 	!WORD	_P068
_F069 	!WORD	_P069
_F070 	!WORD	_P070
_F071 	!WORD	_P071
_F072 	!WORD	_P072
_F073 	!WORD	_P073
; libsrc/fpu_mf.pla: 0077: word = @compXY, @annuityXY, @randNum
_F074 	!WORD	_P074
_F075 	!WORD	_P075
_F076 	!WORD	_P076
; libsrc/fpu_mf.pla: 0078: 
; libsrc/fpu_mf.pla: 0079: //
; libsrc/fpu_mf.pla: 0080: // Useful constants (same as fpu.pla)
; libsrc/fpu_mf.pla: 0081: //
; libsrc/fpu_mf.pla: 0082: byte ext_pi[t_extended]     = $35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40
_D111 					; ext_pi[t_extended]     = $35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40
	!BYTE	$35
	!BYTE	$C2
	!BYTE	$68
	!BYTE	$21
	!BYTE	$A2
	!BYTE	$DA
	!BYTE	$0F
	!BYTE	$C9
	!BYTE	$00
	!BYTE	$40
; libsrc/fpu_mf.pla: 0083: byte ext_e[t_extended]      = $9B,$4A,$BB,$A2,$5B,$54,$F8,$AD,$00,$40
_D112 					; ext_e[t_extended]      = $9B,$4A,$BB,$A2,$5B,$54,$F8,$AD,$00,$40
	!BYTE	$9B
	!BYTE	$4A
	!BYTE	$BB
	!BYTE	$A2
	!BYTE	$5B
	!BYTE	$54
	!BYTE	$F8
	!BYTE	$AD
	!BYTE	$00
	!BYTE	$40
; libsrc/fpu_mf.pla: 0084: // ln(2) constant ~0.693147
; libsrc/fpu_mf.pla: 0085: byte ext_ln2[t_extended]    = $FE,$3F,$B1,$72,$17,$F7,$D1,$CF,$79,$AB
_D113 					; ext_ln2[t_extended]    = $FE,$3F,$B1,$72,$17,$F7,$D1,$CF,$79,$AB
	!BYTE	$FE
	!BYTE	$3F
	!BYTE	$B1
	!BYTE	$72
	!BYTE	$17
	!BYTE	$F7
	!BYTE	$D1
	!BYTE	$CF
	!BYTE	$79
	!BYTE	$AB
; libsrc/fpu_mf.pla: 0086: byte ext_one[t_extended]    = 0  ,$3F,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
_D114 					; ext_one[t_extended]    = 0  ,$3F,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
	!BYTE	$00
	!BYTE	$3F
	!BYTE	$80
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; libsrc/fpu_mf.pla: 0087: byte ext_two[t_extended]    = 0  ,$40,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
_D115 					; ext_two[t_extended]    = 0  ,$40,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
	!BYTE	$00
	!BYTE	$40
	!BYTE	$80
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; libsrc/fpu_mf.pla: 0088: byte ext_negOne[t_extended] = $FF,$3F,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
_D116 					; ext_negOne[t_extended] = $FF,$3F,$80,0  ,0  ,0  ,0  ,0  ,0  ,0
	!BYTE	$FF
	!BYTE	$3F
	!BYTE	$80
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
	!BYTE	$00
; libsrc/fpu_mf.pla: 0089: 
; libsrc/fpu_mf.pla: 0090: //
; libsrc/fpu_mf.pla: 0091: // FP Stack (4 extended precision registers)
; libsrc/fpu_mf.pla: 0092: //
; libsrc/fpu_mf.pla: 0093: byte stack[t_extended*4]
_D117 	!FILL	40			; stack[t_extended*4]
; libsrc/fpu_mf.pla: 0094: word stackRegs[4]
_D118 	!FILL	8			; stackRegs[4]
; libsrc/fpu_mf.pla: 0095: 
; libsrc/fpu_mf.pla: 0096: //
; libsrc/fpu_mf.pla: 0097: // MegaFlash hardware state
; libsrc/fpu_mf.pla: 0098: //
; libsrc/fpu_mf.pla: 0099: byte mfAvailable = FALSE
_D119 					; mfAvailable = FALSE
	!BYTE	$00
; libsrc/fpu_mf.pla: 0100: byte[MBF_TOTAL] mbfBuffer  // Buffer for MBF format conversions
_D120 	!FILL	13			; mbfBuffer  // Buffer for MBF format conversions
; libsrc/fpu_mf.pla: 0101: 
; libsrc/fpu_mf.pla: 0102: //
; libsrc/fpu_mf.pla: 0103: // Import SANE library for fallback and format conversions
; libsrc/fpu_mf.pla: 0104: //
; libsrc/fpu_mf.pla: 0105: word saneInit = 0
_D121 					; saneInit = 0
	!WORD	$0000
; libsrc/fpu_mf.pla: 0106: 
; libsrc/fpu_mf.pla: 0107: //==============================================================================
; libsrc/fpu_mf.pla: 0108: // MEGAFLASH HARDWARE INTERFACE
; libsrc/fpu_mf.pla: 0109: //==============================================================================
; libsrc/fpu_mf.pla: 0110: 
; libsrc/fpu_mf.pla: 0111: //
; libsrc/fpu_mf.pla: 0112: // Wait for MegaFlash operation to complete
; libsrc/fpu_mf.pla: 0113: //
; libsrc/fpu_mf.pla: 0114: asm waitMegaFlash
_A000 					; waitMegaFlash()
; libsrc/fpu_mf.pla: 0115:     !SOURCE "vmsrc/apple/plvmzp.inc"
    !SOURCE "vmsrc/apple/plvmzp.inc"
; libsrc/fpu_mf.pla: 0116:     !SOURCE "vmsrc/apple/megaflash.inc"
    !SOURCE "vmsrc/apple/megaflash.inc"
; libsrc/fpu_mf.pla: 0117:     LDA     MF_STATUSREG
    LDA     MF_STATUSREG
; libsrc/fpu_mf.pla: 0118: -   BIT     MF_STATUSREG
-   BIT     MF_STATUSREG
; libsrc/fpu_mf.pla: 0119:     BMI     -
    BMI     -
; libsrc/fpu_mf.pla: 0120:     RTS
    RTS
; libsrc/fpu_mf.pla: 0121: end
; libsrc/fpu_mf.pla: 0122: 
; libsrc/fpu_mf.pla: 0123: //
; libsrc/fpu_mf.pla: 0124: // Execute MegaFlash FPU command
; libsrc/fpu_mf.pla: 0125: // Input: A = command code
; libsrc/fpu_mf.pla: 0126: // Output: A = error code (0 = success)
; libsrc/fpu_mf.pla: 0127: //
; libsrc/fpu_mf.pla: 0128: asm execMegaFlash(cmd)#1
_A001 					; execMegaFlash()
; libsrc/fpu_mf.pla: 0129:     LDX     ESP
    LDX     ESP
; libsrc/fpu_mf.pla: 0130:     LDA     ESTKL,X             // Get command code
    LDA     ESTKL,X             // Get command code
; libsrc/fpu_mf.pla: 0131: 
; libsrc/fpu_mf.pla: 0132:     // Reset buffer pointers
; libsrc/fpu_mf.pla: 0133:     STZ     MF_CMDREG
    STZ     MF_CMDREG
; libsrc/fpu_mf.pla: 0134: 
; libsrc/fpu_mf.pla: 0135:     // Send command
; libsrc/fpu_mf.pla: 0136:     STA     MF_CMDREG
    STA     MF_CMDREG
; libsrc/fpu_mf.pla: 0137: 
; libsrc/fpu_mf.pla: 0138:     // Wait for completion
; libsrc/fpu_mf.pla: 0139: -   BIT     MF_STATUSREG
-   BIT     MF_STATUSREG
; libsrc/fpu_mf.pla: 0140:     BMI     -
    BMI     -
; libsrc/fpu_mf.pla: 0141: 
; libsrc/fpu_mf.pla: 0142:     // Get error code
; libsrc/fpu_mf.pla: 0143:     LDA     MF_PARAMREG
    LDA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0144:     STA     ESTKL,X
    STA     ESTKL,X
; libsrc/fpu_mf.pla: 0145:     LDA     #0
    LDA     #0
; libsrc/fpu_mf.pla: 0146:     STA     ESTKH,X
    STA     ESTKH,X
; libsrc/fpu_mf.pla: 0147:     RTS
    RTS
; libsrc/fpu_mf.pla: 0148: end
; libsrc/fpu_mf.pla: 0149: 
; libsrc/fpu_mf.pla: 0150: //
; libsrc/fpu_mf.pla: 0151: // Send FAC and ARG to MegaFlash parameter buffer
; libsrc/fpu_mf.pla: 0152: // Input: pFAC, pARG = pointers to 6-byte MBF values
; libsrc/fpu_mf.pla: 0153: //        facExt = FAC extension byte
; libsrc/fpu_mf.pla: 0154: //
; libsrc/fpu_mf.pla: 0155: asm sendFACARG(pFAC, pARG, facExt)#0
_A002 					; sendFACARG()
; libsrc/fpu_mf.pla: 0156:     LDX     ESP
    LDX     ESP
; libsrc/fpu_mf.pla: 0157: 
; libsrc/fpu_mf.pla: 0158:     // Get pointers
; libsrc/fpu_mf.pla: 0159:     LDA     ESTKL+2,X       // pFAC low
    LDA     ESTKL+2,X       // pFAC low
; libsrc/fpu_mf.pla: 0160:     STA     $06
    STA     $06
; libsrc/fpu_mf.pla: 0161:     LDA     ESTKH+2,X       // pFAC high
    LDA     ESTKH+2,X       // pFAC high
; libsrc/fpu_mf.pla: 0162:     STA     $07
    STA     $07
; libsrc/fpu_mf.pla: 0163: 
; libsrc/fpu_mf.pla: 0164:     LDA     ESTKL+1,X       // pARG low
    LDA     ESTKL+1,X       // pARG low
; libsrc/fpu_mf.pla: 0165:     STA     $08
    STA     $08
; libsrc/fpu_mf.pla: 0166:     LDA     ESTKH+1,X       // pARG high
    LDA     ESTKH+1,X       // pARG high
; libsrc/fpu_mf.pla: 0167:     STA     $09
    STA     $09
; libsrc/fpu_mf.pla: 0168: 
; libsrc/fpu_mf.pla: 0169:     LDA     ESTKL,X         // facExt
    LDA     ESTKL,X         // facExt
; libsrc/fpu_mf.pla: 0170:     STA     $0A
    STA     $0A
; libsrc/fpu_mf.pla: 0171: 
; libsrc/fpu_mf.pla: 0172:     INX
    INX
; libsrc/fpu_mf.pla: 0173:     INX
    INX
; libsrc/fpu_mf.pla: 0174:     INX
    INX
; libsrc/fpu_mf.pla: 0175:     STX     ESP
    STX     ESP
; libsrc/fpu_mf.pla: 0176: 
; libsrc/fpu_mf.pla: 0177:     // Reset buffer pointer
; libsrc/fpu_mf.pla: 0178:     STZ     MF_CMDREG
    STZ     MF_CMDREG
; libsrc/fpu_mf.pla: 0179: 
; libsrc/fpu_mf.pla: 0180:     // Send FAC and ARG (interleaved: FAC[i], ARG[i])
; libsrc/fpu_mf.pla: 0181:     LDY     #5
    LDY     #5
; libsrc/fpu_mf.pla: 0182: -   LDA     ($06),Y         // FAC[i]
-   LDA     ($06),Y         // FAC[i]
; libsrc/fpu_mf.pla: 0183:     STA     MF_PARAMREG
    STA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0184:     LDA     ($08),Y         // ARG[i]
    LDA     ($08),Y         // ARG[i]
; libsrc/fpu_mf.pla: 0185:     STA     MF_PARAMREG
    STA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0186:     DEY
    DEY
; libsrc/fpu_mf.pla: 0187:     BPL     -
    BPL     -
; libsrc/fpu_mf.pla: 0188: 
; libsrc/fpu_mf.pla: 0189:     // Send FAC extension
; libsrc/fpu_mf.pla: 0190:     LDA     $0A
    LDA     $0A
; libsrc/fpu_mf.pla: 0191:     STA     MF_PARAMREG
    STA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0192: 
; libsrc/fpu_mf.pla: 0193:     RTS
    RTS
; libsrc/fpu_mf.pla: 0194: end
; libsrc/fpu_mf.pla: 0195: 
; libsrc/fpu_mf.pla: 0196: //
; libsrc/fpu_mf.pla: 0197: // Receive result from MegaFlash parameter buffer
; libsrc/fpu_mf.pla: 0198: // Input: pResult = pointer to 6-byte MBF output
; libsrc/fpu_mf.pla: 0199: // Output: extension byte in A
; libsrc/fpu_mf.pla: 0200: //
; libsrc/fpu_mf.pla: 0201: asm receiveFAC(pResult)#1
_A003 					; receiveFAC()
; libsrc/fpu_mf.pla: 0202:     LDX     ESP
    LDX     ESP
; libsrc/fpu_mf.pla: 0203: 
; libsrc/fpu_mf.pla: 0204:     // Get pointer
; libsrc/fpu_mf.pla: 0205:     LDA     ESTKL,X
    LDA     ESTKL,X
; libsrc/fpu_mf.pla: 0206:     STA     $06
    STA     $06
; libsrc/fpu_mf.pla: 0207:     LDA     ESTKH,X
    LDA     ESTKH,X
; libsrc/fpu_mf.pla: 0208:     STA     $07
    STA     $07
; libsrc/fpu_mf.pla: 0209: 
; libsrc/fpu_mf.pla: 0210:     // Read 6 bytes of FAC
; libsrc/fpu_mf.pla: 0211:     LDY     #5
    LDY     #5
; libsrc/fpu_mf.pla: 0212: -   LDA     MF_PARAMREG
-   LDA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0213:     STA     ($06),Y
    STA     ($06),Y
; libsrc/fpu_mf.pla: 0214:     DEY
    DEY
; libsrc/fpu_mf.pla: 0215:     BPL     -
    BPL     -
; libsrc/fpu_mf.pla: 0216: 
; libsrc/fpu_mf.pla: 0217:     // Read extension byte
; libsrc/fpu_mf.pla: 0218:     LDA     MF_PARAMREG
    LDA     MF_PARAMREG
; libsrc/fpu_mf.pla: 0219:     STA     ESTKL,X
    STA     ESTKL,X
; libsrc/fpu_mf.pla: 0220:     LDA     #0
    LDA     #0
; libsrc/fpu_mf.pla: 0221:     STA     ESTKH,X
    STA     ESTKH,X
; libsrc/fpu_mf.pla: 0222: 
; libsrc/fpu_mf.pla: 0223:     RTS
    RTS
; libsrc/fpu_mf.pla: 0224: end
; libsrc/fpu_mf.pla: 0225: 
; libsrc/fpu_mf.pla: 0226: //
; libsrc/fpu_mf.pla: 0227: // Detect MegaFlash hardware presence
; libsrc/fpu_mf.pla: 0228: //
; libsrc/fpu_mf.pla: 0229: def detectMegaFlash
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
_C000 					; detectMegaFlash()
; libsrc/fpu_mf.pla: 0230:     byte id1, id2
					; id1 -> [0]
					; id2 -> [1]
; libsrc/fpu_mf.pla: 0231: 
; libsrc/fpu_mf.pla: 0232:     // Read ID register twice and XOR - should give $FF if MegaFlash present
; libsrc/fpu_mf.pla: 0233:     id1 = ^MF_IDREG
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0234:     id2 = ^MF_IDREG
; libsrc/fpu_mf.pla: 0235: 
; libsrc/fpu_mf.pla: 0236:     if (id1 ^ id2) == $FF
; libsrc/fpu_mf.pla: 0237:         return TRUE
	!BYTE	$68,$83,$C4		; LAB	50307
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$68,$83,$C4		; LAB	50307
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$98			; XOR
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$24			; BRNE	_B001
	!WORD	_B001-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0238:     fin
_B001 
_B002 
; libsrc/fpu_mf.pla: 0239:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0240: end
; libsrc/fpu_mf.pla: 0241: 
; libsrc/fpu_mf.pla: 0242: //==============================================================================
; libsrc/fpu_mf.pla: 0243: // MBF <-> SANE EXTENDED FORMAT CONVERSION
; libsrc/fpu_mf.pla: 0244: //==============================================================================
; libsrc/fpu_mf.pla: 0245: 
; libsrc/fpu_mf.pla: 0246: //
; libsrc/fpu_mf.pla: 0247: // Convert SANE Extended (80-bit) to MBF (40-bit)
; libsrc/fpu_mf.pla: 0248: // Input: pExt = pointer to 80-bit extended
; libsrc/fpu_mf.pla: 0249: //        pMBF = pointer to 6-byte MBF output
; libsrc/fpu_mf.pla: 0250: // Output: 0 on success, error code on failure
; libsrc/fpu_mf.pla: 0251: //
; libsrc/fpu_mf.pla: 0252: // SANE Extended format:
; libsrc/fpu_mf.pla: 0253: //   Byte 0-1: Sign (bit 15) + Exponent (bits 14-0, bias 16383)
; libsrc/fpu_mf.pla: 0254: //   Byte 2-9: 64-bit mantissa (bit 63 is explicit integer bit)
; libsrc/fpu_mf.pla: 0255: //
; libsrc/fpu_mf.pla: 0256: // MBF format:
; libsrc/fpu_mf.pla: 0257: //   Byte 0: Exponent (bias 128, 0 = zero)
; libsrc/fpu_mf.pla: 0258: //   Byte 1: Sign (bit 7) + Mantissa MSB (bits 6-0, no explicit integer bit)
; libsrc/fpu_mf.pla: 0259: //   Byte 2-5: Mantissa continuation
; libsrc/fpu_mf.pla: 0260: //   (Optional byte 6: Extension for extra precision)
; libsrc/fpu_mf.pla: 0261: //
; libsrc/fpu_mf.pla: 0262: def extendedToMBF(pExt, pMBF)
					; pExt -> [0]
					; pMBF -> [2]
_C001 					; extendedToMBF()
; libsrc/fpu_mf.pla: 0263:     word expWord, i
					; expWord -> [4]
					; i -> [6]
; libsrc/fpu_mf.pla: 0264:     byte signByte, expByte
					; signByte -> [8]
					; expByte -> [9]
; libsrc/fpu_mf.pla: 0265: 
; libsrc/fpu_mf.pla: 0266:     // Get exponent word (bytes 0-1 of extended, big-endian)
; libsrc/fpu_mf.pla: 0267:     expWord = (pExt->0) << 8
	!BYTE	$58,$0A,$02		; ENTER	10,2
; libsrc/fpu_mf.pla: 0268:     expWord = expWord | (pExt=>1)
; libsrc/fpu_mf.pla: 0269: 
; libsrc/fpu_mf.pla: 0270:     // Extract sign bit
; libsrc/fpu_mf.pla: 0271:     if expWord & $8000
; libsrc/fpu_mf.pla: 0272:         signByte = $80
; libsrc/fpu_mf.pla: 0273:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$62			; LW
	!BYTE	$96			; OR 
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B003
	!WORD	_B003-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$50			; BRNCH	_B004
	!WORD	_B004-*
_B003 
; libsrc/fpu_mf.pla: 0274:         signByte = 0
; libsrc/fpu_mf.pla: 0275:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$08			; SLB	[8]
_B004 
; libsrc/fpu_mf.pla: 0276: 
; libsrc/fpu_mf.pla: 0277:     // Extract exponent (15 bits)
; libsrc/fpu_mf.pla: 0278:     expWord = expWord & $7FFF
; libsrc/fpu_mf.pla: 0279: 
; libsrc/fpu_mf.pla: 0280:     // Check for zero
; libsrc/fpu_mf.pla: 0281:     if expWord == 0
; libsrc/fpu_mf.pla: 0282:         // Zero value
; libsrc/fpu_mf.pla: 0283:         pMBF->0 = 0
; libsrc/fpu_mf.pla: 0284:         pMBF->1 = 0
; libsrc/fpu_mf.pla: 0285:         pMBF->2 = 0
; libsrc/fpu_mf.pla: 0286:         pMBF->3 = 0
; libsrc/fpu_mf.pla: 0287:         pMBF->4 = 0
; libsrc/fpu_mf.pla: 0288:         pMBF->5 = 0
; libsrc/fpu_mf.pla: 0289:         return 0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B005
	!WORD	_B005-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/fpu_mf.pla: 0290:     fin
_B005 
_B006 
; libsrc/fpu_mf.pla: 0291: 
; libsrc/fpu_mf.pla: 0292:     // Convert exponent from SANE bias (16383) to MBF bias (128)
; libsrc/fpu_mf.pla: 0293:     // MBF exponent = SANE exponent - 16383 + 128 = SANE exp - 16255
; libsrc/fpu_mf.pla: 0294:     expWord = expWord - 16255
; libsrc/fpu_mf.pla: 0295: 
; libsrc/fpu_mf.pla: 0296:     // Check for overflow/underflow
; libsrc/fpu_mf.pla: 0297:     if expWord < 1
; libsrc/fpu_mf.pla: 0298:         // Underflow - return zero
; libsrc/fpu_mf.pla: 0299:         pMBF->0 = 0
; libsrc/fpu_mf.pla: 0300:         pMBF->1 = 0
; libsrc/fpu_mf.pla: 0301:         pMBF->2 = 0
; libsrc/fpu_mf.pla: 0302:         pMBF->3 = 0
; libsrc/fpu_mf.pla: 0303:         pMBF->4 = 0
; libsrc/fpu_mf.pla: 0304:         pMBF->5 = 0
; libsrc/fpu_mf.pla: 0305:         return 0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$7F,$3F		; CW	16255
	!BYTE	$84			; SUB 
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$02			; CN	1
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B007
	!WORD	_B007-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/fpu_mf.pla: 0306:     fin
_B007 
_B008 
; libsrc/fpu_mf.pla: 0307:     if expWord > 255
; libsrc/fpu_mf.pla: 0308:         // Overflow
; libsrc/fpu_mf.pla: 0309:         return MF_ERR_OVERFLOW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B009
	!WORD	_B009-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/fpu_mf.pla: 0310:     fin
_B009 
_B010 
; libsrc/fpu_mf.pla: 0311: 
; libsrc/fpu_mf.pla: 0312:     expByte = expWord
; libsrc/fpu_mf.pla: 0313: 
; libsrc/fpu_mf.pla: 0314:     // Store exponent
; libsrc/fpu_mf.pla: 0315:     pMBF->0 = expByte
; libsrc/fpu_mf.pla: 0316: 
; libsrc/fpu_mf.pla: 0317:     // Convert mantissa
; libsrc/fpu_mf.pla: 0318:     // SANE mantissa is in bytes 2-9, with bit 63 being the explicit integer bit
; libsrc/fpu_mf.pla: 0319:     // MBF mantissa needs bit 7 of byte 1 set (implicit integer bit), then 31 more bits
; libsrc/fpu_mf.pla: 0320:     //
; libsrc/fpu_mf.pla: 0321:     // SANE byte 2: bit 7 is integer bit (should be 1 for normalized)
; libsrc/fpu_mf.pla: 0322:     // MBF byte 1: bit 7 is sign, bits 6-0 are mantissa MSB (no explicit integer bit)
; libsrc/fpu_mf.pla: 0323: 
; libsrc/fpu_mf.pla: 0324:     pMBF->1 = signByte | ((pExt=>2) & $7F)  // Skip the explicit integer bit
; libsrc/fpu_mf.pla: 0325:     pMBF->2 = pExt=>3
; libsrc/fpu_mf.pla: 0326:     pMBF->3 = pExt=>4
; libsrc/fpu_mf.pla: 0327:     pMBF->4 = pExt=>5
; libsrc/fpu_mf.pla: 0328:     pMBF->5 = pExt=>6  // Extension byte for rounding
; libsrc/fpu_mf.pla: 0329: 
; libsrc/fpu_mf.pla: 0330:     return 0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6C,$09			; DLB	[9]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$96			; OR 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/fpu_mf.pla: 0331: end
; libsrc/fpu_mf.pla: 0332: 
; libsrc/fpu_mf.pla: 0333: //
; libsrc/fpu_mf.pla: 0334: // Convert MBF (40-bit) to SANE Extended (80-bit)
; libsrc/fpu_mf.pla: 0335: // Input: pMBF = pointer to 6-byte MBF input
; libsrc/fpu_mf.pla: 0336: //        pExt = pointer to 10-byte extended output
; libsrc/fpu_mf.pla: 0337: // Output: 0 on success
; libsrc/fpu_mf.pla: 0338: //
; libsrc/fpu_mf.pla: 0339: def MBFToExtended(pMBF, pExt)
					; pMBF -> [0]
					; pExt -> [2]
_C002 					; MBFToExtended()
; libsrc/fpu_mf.pla: 0340:     word expWord
					; expWord -> [4]
; libsrc/fpu_mf.pla: 0341:     byte expByte, signByte, i
					; expByte -> [6]
					; signByte -> [7]
					; i -> [8]
; libsrc/fpu_mf.pla: 0342: 
; libsrc/fpu_mf.pla: 0343:     // Get MBF exponent
; libsrc/fpu_mf.pla: 0344:     expByte = pMBF->0
	!BYTE	$58,$09,$02		; ENTER	9,2
; libsrc/fpu_mf.pla: 0345: 
; libsrc/fpu_mf.pla: 0346:     // Check for zero
; libsrc/fpu_mf.pla: 0347:     if expByte == 0
; libsrc/fpu_mf.pla: 0348:         // Zero value - clear all bytes
; libsrc/fpu_mf.pla: 0349:         pExt->0 = 0
; libsrc/fpu_mf.pla: 0350:         pExt->1 = 0
; libsrc/fpu_mf.pla: 0351:         pExt->2 = 0
; libsrc/fpu_mf.pla: 0352:         pExt->3 = 0
; libsrc/fpu_mf.pla: 0353:         pExt->4 = 0
; libsrc/fpu_mf.pla: 0354:         pExt->5 = 0
; libsrc/fpu_mf.pla: 0355:         pExt->6 = 0
; libsrc/fpu_mf.pla: 0356:         pExt->7 = 0
; libsrc/fpu_mf.pla: 0357:         pExt->8 = 0
; libsrc/fpu_mf.pla: 0358:         pExt->9 = 0
; libsrc/fpu_mf.pla: 0359: 
; libsrc/fpu_mf.pla: 0360:         return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$4E			; BRTRU	_B011
	!WORD	_B011-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/fpu_mf.pla: 0361:     fin
_B011 
_B012 
; libsrc/fpu_mf.pla: 0362: 
; libsrc/fpu_mf.pla: 0363:     // Convert exponent from MBF bias (128) to SANE bias (16383)
; libsrc/fpu_mf.pla: 0364:     // SANE exponent = MBF exponent + 16255
; libsrc/fpu_mf.pla: 0365:     expWord = expByte
; libsrc/fpu_mf.pla: 0366:     expWord = expWord + 16255
; libsrc/fpu_mf.pla: 0367: 
; libsrc/fpu_mf.pla: 0368:     // Extract sign from MBF byte 1
; libsrc/fpu_mf.pla: 0369:     signByte = pMBF->1
; libsrc/fpu_mf.pla: 0370:     if signByte & $80
; libsrc/fpu_mf.pla: 0371:         expWord = expWord | $8000  // Set sign bit
; libsrc/fpu_mf.pla: 0372:     fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$2C,$7F,$3F		; CW	16255
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$6C,$07			; DLB	[7]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B013
	!WORD	_B013-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$96			; OR 
	!BYTE	$76,$04			; SLW	[4]
_B013 
_B014 
; libsrc/fpu_mf.pla: 0373: 
; libsrc/fpu_mf.pla: 0374:     // Store exponent (bytes 0-1, big-endian)
; libsrc/fpu_mf.pla: 0375:     pExt->0 = expWord >> 8
; libsrc/fpu_mf.pla: 0376:     pExt->1 = expWord
; libsrc/fpu_mf.pla: 0377: 
; libsrc/fpu_mf.pla: 0378:     // Convert mantissa
; libsrc/fpu_mf.pla: 0379:     // Set explicit integer bit (bit 63 = 1 for normalized numbers)
; libsrc/fpu_mf.pla: 0380:     pExt->2 = (signByte & $7F) | $80  // Add back the explicit integer bit
; libsrc/fpu_mf.pla: 0381:     pExt->3 = pMBF->2
; libsrc/fpu_mf.pla: 0382:     pExt->4 = pMBF->3
; libsrc/fpu_mf.pla: 0383:     pExt->5 = pMBF->4
; libsrc/fpu_mf.pla: 0384:     pExt->6 = pMBF->5
; libsrc/fpu_mf.pla: 0385: 
; libsrc/fpu_mf.pla: 0386:     // Clear remaining mantissa bytes
; libsrc/fpu_mf.pla: 0387:     pExt->7 = 0
; libsrc/fpu_mf.pla: 0388:     pExt->8 = 0
; libsrc/fpu_mf.pla: 0389:     pExt->9 = 0
; libsrc/fpu_mf.pla: 0390: 
; libsrc/fpu_mf.pla: 0391:     return 0
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/fpu_mf.pla: 0392: end
; libsrc/fpu_mf.pla: 0393: 
; libsrc/fpu_mf.pla: 0394: //==============================================================================
; libsrc/fpu_mf.pla: 0395: // STACK MANIPULATION ROUTINES (same as fpu.pla)
; libsrc/fpu_mf.pla: 0396: //==============================================================================
; libsrc/fpu_mf.pla: 0397: 
; libsrc/fpu_mf.pla: 0398: def rotateUp
_P031 					; rotateUp()
_C003 					; rotateUp()
; libsrc/fpu_mf.pla: 0399:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
; libsrc/fpu_mf.pla: 0400:     return 0
	!BYTE	$6A			; LAW	_D118+6
_F077 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F078 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F079 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F080 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F081 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F082 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F083 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F084 	!WORD	_D118+0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0401: end
; libsrc/fpu_mf.pla: 0402: 
; libsrc/fpu_mf.pla: 0403: def rotateDown
_P032 					; rotateDown()
_C004 					; rotateDown()
; libsrc/fpu_mf.pla: 0404:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[1], stackRegs[2], stackRegs[3], stackRegs[0]
; libsrc/fpu_mf.pla: 0405:     return 0
	!BYTE	$6A			; LAW	_D118+2
_F085 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F086 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+6
_F087 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F088 	!WORD	_D118+0		
	!BYTE	$7A			; SAW	_D118+6
_F089 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F090 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F091 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F092 	!WORD	_D118+0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0406: end
; libsrc/fpu_mf.pla: 0407: 
; libsrc/fpu_mf.pla: 0408: def shiftUp
_P029 					; shiftUp()
_C005 					; shiftUp()
; libsrc/fpu_mf.pla: 0409:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
; libsrc/fpu_mf.pla: 0410:     memcpy(stackRegs[0], stackRegs[1], t_extended)
; libsrc/fpu_mf.pla: 0411:     return 0
	!BYTE	$6A			; LAW	_D118+6
_F093 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F094 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F095 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F096 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F097 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F098 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F099 	!WORD	_D118+2		
	!BYTE	$7E			; DAW	_D118+0
_F100 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F101 	!WORD	_D118+2		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F102 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0412: end
; libsrc/fpu_mf.pla: 0413: 
; libsrc/fpu_mf.pla: 0414: def shiftDown // drop
_P030 					; shiftDown // drop()
_C006 					; shiftDown()
; libsrc/fpu_mf.pla: 0415:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[1], stackRegs[2], stackRegs[3], stackRegs[0]
; libsrc/fpu_mf.pla: 0416:     memcpy(stackRegs[3], stackRegs[2], t_extended)
; libsrc/fpu_mf.pla: 0417:     return 0
	!BYTE	$6A			; LAW	_D118+2
_F103 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F104 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+6
_F105 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F106 	!WORD	_D118+0		
	!BYTE	$7A			; SAW	_D118+6
_F107 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F108 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F109 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F110 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+6
_F111 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+4
_F112 	!WORD	_D118+4		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F113 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0418: end
; libsrc/fpu_mf.pla: 0419: 
; libsrc/fpu_mf.pla: 0420: def _drop(passthru) // Internal version with passthru
					; passthru -> [0]
_C007 					; _drop()
; libsrc/fpu_mf.pla: 0421:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[1], stackRegs[2], stackRegs[3], stackRegs[0]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0422:     memcpy(stackRegs[3], stackRegs[2], t_extended)
; libsrc/fpu_mf.pla: 0423:     return passthru
	!BYTE	$6A			; LAW	_D118+2
_F114 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F115 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+6
_F116 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F117 	!WORD	_D118+0		
	!BYTE	$7A			; SAW	_D118+6
_F118 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F119 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F120 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F121 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+6
_F122 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+4
_F123 	!WORD	_D118+4		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F124 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0424: end
; libsrc/fpu_mf.pla: 0425: 
; libsrc/fpu_mf.pla: 0426: def swap
_P034 					; swap()
_C008 					; swap()
; libsrc/fpu_mf.pla: 0427:     stackRegs[0], stackRegs[1] = stackRegs[1], stackRegs[0]
; libsrc/fpu_mf.pla: 0428:     return 0
	!BYTE	$6A			; LAW	_D118+2
_F125 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F126 	!WORD	_D118+0		
	!BYTE	$7A			; SAW	_D118+2
_F127 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F128 	!WORD	_D118+0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0429: end
; libsrc/fpu_mf.pla: 0430: 
; libsrc/fpu_mf.pla: 0431: def _swap(passthru) // Internal version with passthru
					; passthru -> [0]
_C009 					; _swap()
; libsrc/fpu_mf.pla: 0432:     stackRegs[0], stackRegs[1] = stackRegs[1], stackRegs[0]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0433:     return passthru
	!BYTE	$6A			; LAW	_D118+2
_F129 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F130 	!WORD	_D118+0		
	!BYTE	$7A			; SAW	_D118+2
_F131 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F132 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0434: end
; libsrc/fpu_mf.pla: 0435: 
; libsrc/fpu_mf.pla: 0436: def dup
_P033 					; dup()
_C010 					; dup()
; libsrc/fpu_mf.pla: 0437:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
; libsrc/fpu_mf.pla: 0438:     memcpy(stackRegs[0], stackRegs[1], t_extended)
; libsrc/fpu_mf.pla: 0439:     return 0
	!BYTE	$6A			; LAW	_D118+6
_F133 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F134 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F135 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F136 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F137 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F138 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F139 	!WORD	_D118+2		
	!BYTE	$7E			; DAW	_D118+0
_F140 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F141 	!WORD	_D118+2		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F142 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0440: end
; libsrc/fpu_mf.pla: 0441: 
; libsrc/fpu_mf.pla: 0442: def clear
_P035 					; clear()
_C011 					; clear()
; libsrc/fpu_mf.pla: 0443:     word zero
					; zero -> [0]
; libsrc/fpu_mf.pla: 0444:     zero = 0
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0445: 
; libsrc/fpu_mf.pla: 0446:     if mfAvailable
; libsrc/fpu_mf.pla: 0447:         // Use MegaFlash to create zero
; libsrc/fpu_mf.pla: 0448:         // For now, just set exponent to 0
; libsrc/fpu_mf.pla: 0449:         stackRegs[0]->0 = 0
; libsrc/fpu_mf.pla: 0450:         stackRegs[0]->1 = 0
; libsrc/fpu_mf.pla: 0451:         return 0
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$68			; LAB	_D119+0
_F143 	!WORD	_D119+0		
	!BYTE	$4C			; BRFLS	_B015
	!WORD	_B015-*
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D118+0
_F144 	!WORD	_D118+0		
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D118+0
_F145 	!WORD	_D118+0		
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0452:     fin
_B015 
_B016 
; libsrc/fpu_mf.pla: 0453: 
; libsrc/fpu_mf.pla: 0454:     // Clear SANE
; libsrc/fpu_mf.pla: 0455:     sane:saveZP()
; libsrc/fpu_mf.pla: 0456:     return sane:restoreZP(sane:op2FP(FFINT|FOZ2X, stackRegs[0], @zero))
	!BYTE	$6A			; LAW	_X028+18
_F146 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$04		; CW	1038
	!BYTE	$6A			; LAW	_D118+0
_F147 	!WORD	_D118+0		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$6A			; LAW	_X028+8
_F148 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F149 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0457: end
; libsrc/fpu_mf.pla: 0458: 
; libsrc/fpu_mf.pla: 0459: //==============================================================================
; libsrc/fpu_mf.pla: 0460: // STACK ACCESS ROUTINES
; libsrc/fpu_mf.pla: 0461: //==============================================================================
; libsrc/fpu_mf.pla: 0462: def pushInt(pInt)
					; pInt -> [0]
_P009 					; pushInt(pInt)()
_C012 					; pushInt()
; libsrc/fpu_mf.pla: 0463:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0464:     sane:saveZP()
; libsrc/fpu_mf.pla: 0465:     return sane:restoreZP(sane:op2FP(FFINT|FOZ2X, stackRegs[0], pInt))
	!BYTE	$6A			; LAW	_D118+6
_F150 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F151 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F152 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F153 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F154 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F155 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F156 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F157 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+18
_F158 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$04		; CW	1038
	!BYTE	$6A			; LAW	_D118+0
_F159 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F160 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F161 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0466: end
; libsrc/fpu_mf.pla: 0467: def pullInt(pInt)
					; pInt -> [0]
_P014 					; pullInt(pInt)()
_C013 					; pullInt()
; libsrc/fpu_mf.pla: 0468:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0469:     return _drop(sane:restoreZP(sane:op2FP(FFINT|FOX2Z, pInt, stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F162 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$04		; CW	1040
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D118+0
_F163 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F164 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F165 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F166 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0470: end
; libsrc/fpu_mf.pla: 0471: def loadInt(pInt, reg)
					; pInt -> [0]
					; reg -> [2]
_P019 					; loadInt(pInt, reg)()
_C014 					; loadInt()
; libsrc/fpu_mf.pla: 0472:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0473:     return sane:restoreZP(sane:op2FP(FFINT|FOZ2X, stackRegs[reg & $03], pInt))
	!BYTE	$6A			; LAW	_X028+18
_F167 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$04		; CW	1038
	!BYTE	$26			; LA	_D118+0
_F168 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F169 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F170 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0474: end
; libsrc/fpu_mf.pla: 0475: def storInt(pInt, reg)
					; pInt -> [0]
					; reg -> [2]
_P024 					; storInt(pInt, reg)()
_C015 					; storInt()
; libsrc/fpu_mf.pla: 0476:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0477:     return sane:restoreZP(sane:op2FP(FFINT|FOX2Z, pInt, stackRegs[reg & $03]))
	!BYTE	$6A			; LAW	_X028+18
_F171 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$04		; CW	1040
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D118+0
_F172 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_X028+8
_F173 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F174 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0478: end
; libsrc/fpu_mf.pla: 0479: def pushSgl(pSgl)
					; pSgl -> [0]
_P010 					; pushSgl(pSgl)()
_C016 					; pushSgl()
; libsrc/fpu_mf.pla: 0480:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0481:     sane:saveZP()
; libsrc/fpu_mf.pla: 0482:     return sane:restoreZP(sane:op2FP(FFSGL|FOZ2X, stackRegs[0], pSgl))
	!BYTE	$6A			; LAW	_D118+6
_F175 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F176 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F177 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F178 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F179 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F180 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F181 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F182 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+18
_F183 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$02		; CW	526
	!BYTE	$6A			; LAW	_D118+0
_F184 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F185 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F186 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0483: end
; libsrc/fpu_mf.pla: 0484: def pullSgl(pSgl)
					; pSgl -> [0]
_P015 					; pullSgl(pSgl)()
_C017 					; pullSgl()
; libsrc/fpu_mf.pla: 0485:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0486:     return _drop(sane:restoreZP(sane:op2FP(FFSGL|FOX2Z, pSgl, stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F187 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$02		; CW	528
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D118+0
_F188 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F189 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F190 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F191 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0487: end
; libsrc/fpu_mf.pla: 0488: def loadSgl(pSgl, reg)
					; pSgl -> [0]
					; reg -> [2]
_P020 					; loadSgl(pSgl, reg)()
_C018 					; loadSgl()
; libsrc/fpu_mf.pla: 0489:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0490:     return sane:restoreZP(sane:op2FP(FFSGL|FOZ2X, stackRegs[reg & $03], pSgl))
	!BYTE	$6A			; LAW	_X028+18
_F192 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$02		; CW	526
	!BYTE	$26			; LA	_D118+0
_F193 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F194 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F195 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0491: end
; libsrc/fpu_mf.pla: 0492: def storSgl(pSgl, reg)
					; pSgl -> [0]
					; reg -> [2]
_P025 					; storSgl(pSgl, reg)()
_C019 					; storSgl()
; libsrc/fpu_mf.pla: 0493:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0494:     return sane:restoreZP(sane:op2FP(FFSGL|FOX2Z, pSgl, stackRegs[reg & $03]))
	!BYTE	$6A			; LAW	_X028+18
_F196 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$02		; CW	528
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D118+0
_F197 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_X028+8
_F198 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F199 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0495: end
; libsrc/fpu_mf.pla: 0496: def pushDbl(pDbl)
					; pDbl -> [0]
_P011 					; pushDbl(pDbl)()
_C020 					; pushDbl()
; libsrc/fpu_mf.pla: 0497:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0498:     sane:saveZP()
; libsrc/fpu_mf.pla: 0499:     return sane:restoreZP(sane:op2FP(FFDBL|FOZ2X, stackRegs[0], pDbl))
	!BYTE	$6A			; LAW	_D118+6
_F200 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F201 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F202 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F203 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F204 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F205 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F206 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F207 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+18
_F208 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$01		; CW	270
	!BYTE	$6A			; LAW	_D118+0
_F209 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F210 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F211 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0500: end
; libsrc/fpu_mf.pla: 0501: def pullDbl(pDbl)
					; pDbl -> [0]
_P016 					; pullDbl(pDbl)()
_C021 					; pullDbl()
; libsrc/fpu_mf.pla: 0502:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0503:     return _drop(sane:restoreZP(sane:op2FP(FFDBL|FOX2Z, pDbl, stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F212 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$01		; CW	272
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D118+0
_F213 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F214 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F215 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F216 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0504: end
; libsrc/fpu_mf.pla: 0505: def loadDbl(pDbl, reg)
					; pDbl -> [0]
					; reg -> [2]
_P021 					; loadDbl(pDbl, reg)()
_C022 					; loadDbl()
; libsrc/fpu_mf.pla: 0506:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0507:     return sane:restoreZP(sane:op2FP(FFDBL|FOZ2X, stackRegs[reg & $03], pDbl))
	!BYTE	$6A			; LAW	_X028+18
_F217 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$0E,$01		; CW	270
	!BYTE	$26			; LA	_D118+0
_F218 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F219 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F220 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0508: end
; libsrc/fpu_mf.pla: 0509: def storDbl(pDbl, reg)
					; pDbl -> [0]
					; reg -> [2]
_P026 					; storDbl(pDbl, reg)()
_C023 					; storDbl()
; libsrc/fpu_mf.pla: 0510:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0511:     return sane:restoreZP(sane:op2FP(FFDBL|FOX2Z, pDbl, stackRegs[reg & $03]))
	!BYTE	$6A			; LAW	_X028+18
_F221 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$10,$01		; CW	272
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D118+0
_F222 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_X028+8
_F223 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F224 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0512: end
; libsrc/fpu_mf.pla: 0513: def pushExt(pExt)
					; pExt -> [0]
_P012 					; pushExt(pExt)()
_C024 					; pushExt()
; libsrc/fpu_mf.pla: 0514:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0515:     sane:saveZP()
; libsrc/fpu_mf.pla: 0516:     return sane:restoreZP(sane:op2FP(FFEXT|FOZ2X, stackRegs[0], pExt))
	!BYTE	$6A			; LAW	_D118+6
_F225 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F226 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F227 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F228 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F229 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F230 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F231 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F232 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+18
_F233 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D118+0
_F234 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F235 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F236 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0517: end
; libsrc/fpu_mf.pla: 0518: def pullExt(pExt)
					; pExt -> [0]
_P017 					; pullExt(pExt)()
_C025 					; pullExt()
; libsrc/fpu_mf.pla: 0519:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0520:     return _drop(sane:restoreZP(sane:op2FP(FFEXT|FOX2Z, pExt, stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F237 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D118+0
_F238 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F239 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F240 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F241 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0521: end
; libsrc/fpu_mf.pla: 0522: def loadExt(pExt, reg)
					; pExt -> [0]
					; reg -> [2]
_P022 					; loadExt(pExt, reg)()
_C026 					; loadExt()
; libsrc/fpu_mf.pla: 0523:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0524:     return sane:restoreZP(sane:op2FP(FFEXT|FOZ2X, stackRegs[reg & $03], pExt))
	!BYTE	$6A			; LAW	_X028+18
_F242 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$26			; LA	_D118+0
_F243 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F244 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F245 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0525: end
; libsrc/fpu_mf.pla: 0526: def storExt(pExt, reg)
					; pExt -> [0]
					; reg -> [2]
_P027 					; storExt(pExt, reg)()
_C027 					; storExt()
; libsrc/fpu_mf.pla: 0527:     sane:saveZP()
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/fpu_mf.pla: 0528:     return sane:restoreZP(sane:op2FP(FFEXT|FOX2Z, pExt, stackRegs[reg & $03]))
	!BYTE	$6A			; LAW	_X028+18
_F246 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D118+0
_F247 	!WORD	_D118+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_X028+8
_F248 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F249 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0529: end
; libsrc/fpu_mf.pla: 0530: def pushStr(pStr)
					; pStr -> [0]
_P013 					; pushStr(pStr)()
_C028 					; pushStr()
; libsrc/fpu_mf.pla: 0531:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 0532:     return str2ext(pStr, stackRegs[0])
	!BYTE	$6A			; LAW	_D118+6
_F250 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F251 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F252 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+4
_F253 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F254 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F255 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F256 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F257 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D118+0
_F258 	!WORD	_D118+0		
	!BYTE	$54			; CALL	_X030
_F259 	!WORD	0		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0533: end
; libsrc/fpu_mf.pla: 0534: def pullStr(pStr, intdigits, fracdigits, format)
					; pStr -> [0]
					; intdigits -> [2]
					; fracdigits -> [4]
					; format -> [6]
_P018 					; pullStr(pStr, intdigits, fracdigits, format)()
_C029 					; pullStr()
; libsrc/fpu_mf.pla: 0535:     return _drop(ext2str(stackRegs[0], pStr, intdigits, fracdigits, format))
	!BYTE	$58,$08,$04		; ENTER	8,4
	!BYTE	$6A			; LAW	_D118+0
_F260 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X031
_F261 	!WORD	0		
	!BYTE	$54			; CALL	_C007
_F262 	!WORD	_C007		
	!BYTE	$5A,$08			; LEAVE	8
; libsrc/fpu_mf.pla: 0536: end
; libsrc/fpu_mf.pla: 0537: def loadStr(pStr, reg)
					; pStr -> [0]
					; reg -> [2]
_P023 					; loadStr(pStr, reg)()
_C030 					; loadStr()
; libsrc/fpu_mf.pla: 0538:     return str2ext(pStr, stackRegs[reg])
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D118+0
_F263 	!WORD	_D118+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X030
_F264 	!WORD	0		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0539: end
; libsrc/fpu_mf.pla: 0540: def storStr(pStr, intdigits, fracdigits, format, reg)
					; pStr -> [0]
					; intdigits -> [2]
					; fracdigits -> [4]
					; format -> [6]
					; reg -> [8]
_P028 					; storStr(pStr, intdigits, fracdigits, format, reg)()
_C031 					; storStr()
; libsrc/fpu_mf.pla: 0541:     return ext2str(stackRegs[reg], pStr, intdigits, fracdigits, format)
	!BYTE	$58,$0A,$05		; ENTER	10,5
	!BYTE	$26			; LA	_D118+0
_F265 	!WORD	_D118+0		
	!BYTE	$BA,$08			; IDXLW	[8]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X031
_F266 	!WORD	0		
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/fpu_mf.pla: 0542: end
; libsrc/fpu_mf.pla: 0543: 
; libsrc/fpu_mf.pla: 0544: //==============================================================================
; libsrc/fpu_mf.pla: 0545: // BASIC MATH OPERATIONS (MegaFlash accelerated)
; libsrc/fpu_mf.pla: 0546: //==============================================================================
; libsrc/fpu_mf.pla: 0547: 
; libsrc/fpu_mf.pla: 0548: //
; libsrc/fpu_mf.pla: 0549: // Helper function to execute binary operation on MegaFlash
; libsrc/fpu_mf.pla: 0550: // Input: cmd = MegaFlash command code
; libsrc/fpu_mf.pla: 0551: // Returns: error code (0 = success)
; libsrc/fpu_mf.pla: 0552: //
; libsrc/fpu_mf.pla: 0553: def execBinaryOp(cmd)
					; cmd -> [0]
_C032 					; execBinaryOp()
; libsrc/fpu_mf.pla: 0554:     byte err
					; err -> [2]
; libsrc/fpu_mf.pla: 0555:     byte[MBF_SIZE] mbfFAC, mbfARG, mbfResult
					; mbfFAC -> [3]
					; mbfARG -> [9]
					; mbfResult -> [15]
; libsrc/fpu_mf.pla: 0556: 
; libsrc/fpu_mf.pla: 0557:     if !mfAvailable
	!BYTE	$58,$15,$01		; ENTER	21,1
; libsrc/fpu_mf.pla: 0558:         // Fallback to SANE
; libsrc/fpu_mf.pla: 0559:         return -1  // Signal to use SANE
	!BYTE	$68			; LAB	_D119+0
_F267 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B017
	!WORD	_B017-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$15			; LEAVE	21
; libsrc/fpu_mf.pla: 0560:     fin
_B017 
_B018 
; libsrc/fpu_mf.pla: 0561: 
; libsrc/fpu_mf.pla: 0562:     // Convert stack registers to MBF
; libsrc/fpu_mf.pla: 0563:     err = extendedToMBF(stackRegs[0], @mbfFAC)
; libsrc/fpu_mf.pla: 0564:     if err; return err; fin
	!BYTE	$6A			; LAW	_D118+0
_F268 	!WORD	_D118+0		
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$54			; CALL	_C001
_F269 	!WORD	_C001		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B019
	!WORD	_B019-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
_B019 
_B020 
; libsrc/fpu_mf.pla: 0565: 
; libsrc/fpu_mf.pla: 0566:     err = extendedToMBF(stackRegs[1], @mbfARG)
; libsrc/fpu_mf.pla: 0567:     if err; return err; fin
	!BYTE	$6A			; LAW	_D118+2
_F270 	!WORD	_D118+2		
	!BYTE	$28,$09			; LLA	[9]
	!BYTE	$54			; CALL	_C001
_F271 	!WORD	_C001		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B021
	!WORD	_B021-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
_B021 
_B022 
; libsrc/fpu_mf.pla: 0568: 
; libsrc/fpu_mf.pla: 0569:     // Send to MegaFlash
; libsrc/fpu_mf.pla: 0570:     sendFACARG(@mbfFAC, @mbfARG, 0)
; libsrc/fpu_mf.pla: 0571: 
; libsrc/fpu_mf.pla: 0572:     // Execute command
; libsrc/fpu_mf.pla: 0573:     err = execMegaFlash(cmd)
; libsrc/fpu_mf.pla: 0574:     if err; return err; fin
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$28,$09			; LLA	[9]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A002
_F272 	!WORD	_A002		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A001
_F273 	!WORD	_A001		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B023
	!WORD	_B023-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
_B023 
_B024 
; libsrc/fpu_mf.pla: 0575: 
; libsrc/fpu_mf.pla: 0576:     // Get result
; libsrc/fpu_mf.pla: 0577:     receiveFAC(@mbfResult)
; libsrc/fpu_mf.pla: 0578: 
; libsrc/fpu_mf.pla: 0579:     // Convert back to extended and store in stack[1]
; libsrc/fpu_mf.pla: 0580:     err = MBFToExtended(@mbfResult, stackRegs[1])
; libsrc/fpu_mf.pla: 0581: 
; libsrc/fpu_mf.pla: 0582:     return err
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$54			; CALL	_A003
_F274 	!WORD	_A003		
	!BYTE	$30			; DROP 
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$6A			; LAW	_D118+2
_F275 	!WORD	_D118+2		
	!BYTE	$54			; CALL	_C002
_F276 	!WORD	_C002		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
; libsrc/fpu_mf.pla: 0583: end
; libsrc/fpu_mf.pla: 0584: 
; libsrc/fpu_mf.pla: 0585: //
; libsrc/fpu_mf.pla: 0586: // Helper function to execute unary operation on MegaFlash
; libsrc/fpu_mf.pla: 0587: //
; libsrc/fpu_mf.pla: 0588: def execUnaryOp(cmd)
					; cmd -> [0]
_C033 					; execUnaryOp()
; libsrc/fpu_mf.pla: 0589:     byte err
					; err -> [2]
; libsrc/fpu_mf.pla: 0590:     byte[MBF_SIZE] mbfFAC, mbfARG, mbfResult
					; mbfFAC -> [3]
					; mbfARG -> [9]
					; mbfResult -> [15]
; libsrc/fpu_mf.pla: 0591: 
; libsrc/fpu_mf.pla: 0592:     if !mfAvailable
	!BYTE	$58,$15,$01		; ENTER	21,1
; libsrc/fpu_mf.pla: 0593:         return -1  // Signal to use SANE
	!BYTE	$68			; LAB	_D119+0
_F277 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B025
	!WORD	_B025-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$15			; LEAVE	21
; libsrc/fpu_mf.pla: 0594:     fin
_B025 
_B026 
; libsrc/fpu_mf.pla: 0595: 
; libsrc/fpu_mf.pla: 0596:     // Convert stack register to MBF
; libsrc/fpu_mf.pla: 0597:     err = extendedToMBF(stackRegs[0], @mbfFAC)
; libsrc/fpu_mf.pla: 0598:     if err; return err; fin
	!BYTE	$6A			; LAW	_D118+0
_F278 	!WORD	_D118+0		
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$54			; CALL	_C001
_F279 	!WORD	_C001		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B027
	!WORD	_B027-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
_B027 
_B028 
; libsrc/fpu_mf.pla: 0599: 
; libsrc/fpu_mf.pla: 0600:     // Set ARG to zero (not used for unary ops)
; libsrc/fpu_mf.pla: 0601:     mbfARG.0 = 0
; libsrc/fpu_mf.pla: 0602:     mbfARG.1 = 0
; libsrc/fpu_mf.pla: 0603:     mbfARG.2 = 0
; libsrc/fpu_mf.pla: 0604:     mbfARG.3 = 0
; libsrc/fpu_mf.pla: 0605:     mbfARG.4 = 0
; libsrc/fpu_mf.pla: 0606:     mbfARG.5 = 0
; libsrc/fpu_mf.pla: 0607: 
; libsrc/fpu_mf.pla: 0608:     // Send to MegaFlash
; libsrc/fpu_mf.pla: 0609:     sendFACARG(@mbfFAC, @mbfARG, 0)
; libsrc/fpu_mf.pla: 0610: 
; libsrc/fpu_mf.pla: 0611:     // Execute command
; libsrc/fpu_mf.pla: 0612:     err = execMegaFlash(cmd)
; libsrc/fpu_mf.pla: 0613:     if err; return err; fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0A			; SLB	[10]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$00			; CN	0
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$28,$09			; LLA	[9]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A002
_F280 	!WORD	_A002		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A001
_F281 	!WORD	_A001		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B029
	!WORD	_B029-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
_B029 
_B030 
; libsrc/fpu_mf.pla: 0614: 
; libsrc/fpu_mf.pla: 0615:     // Get result
; libsrc/fpu_mf.pla: 0616:     receiveFAC(@mbfResult)
; libsrc/fpu_mf.pla: 0617: 
; libsrc/fpu_mf.pla: 0618:     // Convert back to extended
; libsrc/fpu_mf.pla: 0619:     err = MBFToExtended(@mbfResult, stackRegs[0])
; libsrc/fpu_mf.pla: 0620: 
; libsrc/fpu_mf.pla: 0621:     return err
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$54			; CALL	_A003
_F282 	!WORD	_A003		
	!BYTE	$30			; DROP 
	!BYTE	$28,$0F			; LLA	[15]
	!BYTE	$6A			; LAW	_D118+0
_F283 	!WORD	_D118+0		
	!BYTE	$54			; CALL	_C002
_F284 	!WORD	_C002		
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$5A,$15			; LEAVE	21
; libsrc/fpu_mf.pla: 0622: end
; libsrc/fpu_mf.pla: 0623: 
; libsrc/fpu_mf.pla: 0624: def add
_P036 					; add()
_C034 					; add()
; libsrc/fpu_mf.pla: 0625:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0626: 
; libsrc/fpu_mf.pla: 0627:     err = execBinaryOp(MF_CMD_FADD)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0628:     if err < 0
; libsrc/fpu_mf.pla: 0629:         // Use SANE fallback
; libsrc/fpu_mf.pla: 0630:     
; libsrc/fpu_mf.pla: 0631:         sane:saveZP()
; libsrc/fpu_mf.pla: 0632:         return _drop(sane:restoreZP(sane:op2FP(FFEXT|FOADD, stackRegs[1], stackRegs[0])))
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C032
_F285 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B031
	!WORD	_B031-*
	!BYTE	$6A			; LAW	_X028+18
_F286 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D118+2
_F287 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F288 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F289 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F290 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F291 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0633:     fin
_B031 
_B032 
; libsrc/fpu_mf.pla: 0634: 
; libsrc/fpu_mf.pla: 0635:     return _drop(err)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C007
_F292 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0636: end
; libsrc/fpu_mf.pla: 0637: 
; libsrc/fpu_mf.pla: 0638: def sub
_P037 					; sub()
_C035 					; sub()
; libsrc/fpu_mf.pla: 0639:     // MegaFlash doesn't have FSUB - use SANE fallback
; libsrc/fpu_mf.pla: 0640:     // (Could also implement as negate + add, but SANE is more reliable)
; libsrc/fpu_mf.pla: 0641: 
; libsrc/fpu_mf.pla: 0642:     sane:saveZP()
; libsrc/fpu_mf.pla: 0643:     return _drop(sane:restoreZP(sane:op2FP(FFEXT|FOSUB, stackRegs[1], stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F293 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_D118+2
_F294 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F295 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F296 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F297 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F298 	!WORD	_C007		
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0644: end
; libsrc/fpu_mf.pla: 0645: 
; libsrc/fpu_mf.pla: 0646: def mul
_P038 					; mul()
_C036 					; mul()
; libsrc/fpu_mf.pla: 0647:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0648: 
; libsrc/fpu_mf.pla: 0649:     err = execBinaryOp(MF_CMD_FMUL)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0650:     if err < 0
; libsrc/fpu_mf.pla: 0651:     
; libsrc/fpu_mf.pla: 0652:         sane:saveZP()
; libsrc/fpu_mf.pla: 0653:         return _drop(sane:restoreZP(sane:op2FP(FFEXT|FOMUL, stackRegs[1], stackRegs[0])))
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F299 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$6A			; LAW	_X028+18
_F300 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$6A			; LAW	_D118+2
_F301 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F302 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F303 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F304 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F305 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0654:     fin
_B033 
_B034 
; libsrc/fpu_mf.pla: 0655: 
; libsrc/fpu_mf.pla: 0656:     return _drop(err)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C007
_F306 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0657: end
; libsrc/fpu_mf.pla: 0658: 
; libsrc/fpu_mf.pla: 0659: def div
_P039 					; div()
_C037 					; div()
; libsrc/fpu_mf.pla: 0660:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0661: 
; libsrc/fpu_mf.pla: 0662:     err = execBinaryOp(MF_CMD_FDIV)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0663:     if err < 0
; libsrc/fpu_mf.pla: 0664:     
; libsrc/fpu_mf.pla: 0665:         sane:saveZP()
; libsrc/fpu_mf.pla: 0666:         return _drop(sane:restoreZP(sane:op2FP(FFEXT|FODIV, stackRegs[1], stackRegs[0])))
	!BYTE	$2A,$32			; CB	50
	!BYTE	$54			; CALL	_C032
_F307 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B035
	!WORD	_B035-*
	!BYTE	$6A			; LAW	_X028+18
_F308 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$0C			; CN	6
	!BYTE	$6A			; LAW	_D118+2
_F309 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F310 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F311 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F312 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F313 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0667:     fin
_B035 
_B036 
; libsrc/fpu_mf.pla: 0668: 
; libsrc/fpu_mf.pla: 0669:     return _drop(err)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C007
_F314 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0670: end
; libsrc/fpu_mf.pla: 0671: 
; libsrc/fpu_mf.pla: 0672: def rem
_P040 					; rem()
_C038 					; rem()
; libsrc/fpu_mf.pla: 0673:     // MegaFlash doesn't support REM - use SANE
; libsrc/fpu_mf.pla: 0674: 
; libsrc/fpu_mf.pla: 0675:     sane:saveZP()
; libsrc/fpu_mf.pla: 0676:     return _drop(sane:restoreZP(sane:op2FP(FFEXT|FOREM, stackRegs[1], stackRegs[0])))
	!BYTE	$6A			; LAW	_X028+18
_F315 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$18			; CN	12
	!BYTE	$6A			; LAW	_D118+2
_F316 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F317 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F318 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F319 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C007
_F320 	!WORD	_C007		
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0677: end
; libsrc/fpu_mf.pla: 0678: 
; libsrc/fpu_mf.pla: 0679: def neg
_P041 					; neg()
_C039 					; neg()
; libsrc/fpu_mf.pla: 0680:     // neg(x) = x * -1 (preserves precision, uses hardware mul)
; libsrc/fpu_mf.pla: 0681:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0682: 
; libsrc/fpu_mf.pla: 0683:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0684:         // Fallback to SANE
; libsrc/fpu_mf.pla: 0685:     
; libsrc/fpu_mf.pla: 0686:         sane:saveZP()
; libsrc/fpu_mf.pla: 0687:         return sane:restoreZP(sane:op1FP(FFEXT|FONEG, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F321 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B037
	!WORD	_B037-*
	!BYTE	$6A			; LAW	_X028+18
_F322 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_D118+0
_F323 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F324 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F325 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0688:     fin
_B037 
_B038 
; libsrc/fpu_mf.pla: 0689: 
; libsrc/fpu_mf.pla: 0690:     // Multiply by -1
; libsrc/fpu_mf.pla: 0691:     memcpy(stackRegs[1], stackRegs[0], t_extended)
; libsrc/fpu_mf.pla: 0692:     memcpy(stackRegs[0], @ext_negOne, t_extended)
; libsrc/fpu_mf.pla: 0693:     return execBinaryOp(MF_CMD_FMUL)
	!BYTE	$6A			; LAW	_D118+2
_F326 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F327 	!WORD	_D118+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F328 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+0
_F329 	!WORD	_D118+0		
	!BYTE	$26			; LA	_D116+0
_F330 	!WORD	_D116+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F331 	!WORD	0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F332 	!WORD	_C032		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0694: end
; libsrc/fpu_mf.pla: 0695: 
; libsrc/fpu_mf.pla: 0696: def abs
_P042 					; abs()
_C040 					; abs()
; libsrc/fpu_mf.pla: 0697:     // abs(x) = x if x >= 0, else -x
; libsrc/fpu_mf.pla: 0698:     // Check sign bit and negate if needed
; libsrc/fpu_mf.pla: 0699:     if stackRegs[0]->0 & $80
; libsrc/fpu_mf.pla: 0700:         // Negative - negate it
; libsrc/fpu_mf.pla: 0701:         return neg
	!BYTE	$6A			; LAW	_D118+0
_F333 	!WORD	_D118+0		
	!BYTE	$60			; LB
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B039
	!WORD	_B039-*
	!BYTE	$54			; CALL	_C039
_F334 	!WORD	_C039		
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0702:     fin
_B039 
_B040 
; libsrc/fpu_mf.pla: 0703:     // Already positive
; libsrc/fpu_mf.pla: 0704:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0705: end
; libsrc/fpu_mf.pla: 0706: 
; libsrc/fpu_mf.pla: 0707: def type
_P043 					; type()
_C041 					; type()
; libsrc/fpu_mf.pla: 0708:     // Type classification - use SANE
; libsrc/fpu_mf.pla: 0709: 
; libsrc/fpu_mf.pla: 0710:     sane:saveZP()
; libsrc/fpu_mf.pla: 0711:     return sane:restoreZP(sane:op1FP(FFEXT|FOCLASS, stackRegs[0]))
	!BYTE	$6A			; LAW	_X028+18
_F335 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$6A			; LAW	_D118+0
_F336 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F337 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F338 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0712: end
; libsrc/fpu_mf.pla: 0713: 
; libsrc/fpu_mf.pla: 0714: def cmp
_P044 					; cmp()
_C042 					; cmp()
; libsrc/fpu_mf.pla: 0715:     // Comparison - use SANE
; libsrc/fpu_mf.pla: 0716: 
; libsrc/fpu_mf.pla: 0717:     sane:saveZP()
; libsrc/fpu_mf.pla: 0718:     return sane:restoreZP(sane:op2FP(FFEXT|FOCMP, stackRegs[1], stackRegs[0]))
	!BYTE	$6A			; LAW	_X028+18
_F339 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$10			; CN	8
	!BYTE	$6A			; LAW	_D118+2
_F340 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F341 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+8
_F342 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F343 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0719: end
; libsrc/fpu_mf.pla: 0720: 
; libsrc/fpu_mf.pla: 0721: def trunc
_P047 					; trunc()
_C043 					; trunc()
; libsrc/fpu_mf.pla: 0722:     // Truncate - use SANE
; libsrc/fpu_mf.pla: 0723: 
; libsrc/fpu_mf.pla: 0724:     sane:saveZP()
; libsrc/fpu_mf.pla: 0725:     return sane:restoreZP(sane:op1FP(FFEXT|FOTTI, stackRegs[0]))
	!BYTE	$6A			; LAW	_X028+18
_F344 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F345 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F346 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F347 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0726: end
; libsrc/fpu_mf.pla: 0727: 
; libsrc/fpu_mf.pla: 0728: def round
_P048 					; round()
_C044 					; round()
; libsrc/fpu_mf.pla: 0729:     // Round - use SANE
; libsrc/fpu_mf.pla: 0730: 
; libsrc/fpu_mf.pla: 0731:     sane:saveZP()
; libsrc/fpu_mf.pla: 0732:     return sane:restoreZP(sane:op1FP(FFEXT|FORTI, stackRegs[0]))
	!BYTE	$6A			; LAW	_X028+18
_F348 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$14			; CB	20
	!BYTE	$6A			; LAW	_D118+0
_F349 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F350 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F351 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0733: end
; libsrc/fpu_mf.pla: 0734: 
; libsrc/fpu_mf.pla: 0735: def sqrt
_P049 					; sqrt()
_C045 					; sqrt()
; libsrc/fpu_mf.pla: 0736:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0737: 
; libsrc/fpu_mf.pla: 0738:     err = execUnaryOp(MF_CMD_FSQR)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0739:     if err < 0
; libsrc/fpu_mf.pla: 0740:     
; libsrc/fpu_mf.pla: 0741:         sane:saveZP()
; libsrc/fpu_mf.pla: 0742:         return sane:restoreZP(sane:op1FP(FFEXT|FOSQRT, stackRegs[0]))
	!BYTE	$2A,$39			; CB	57
	!BYTE	$54			; CALL	_C033
_F352 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B041
	!WORD	_B041-*
	!BYTE	$6A			; LAW	_X028+18
_F353 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$12			; CB	18
	!BYTE	$6A			; LAW	_D118+0
_F354 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F355 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F356 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0743:     fin
_B041 
_B042 
; libsrc/fpu_mf.pla: 0744: 
; libsrc/fpu_mf.pla: 0745:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0746: end
; libsrc/fpu_mf.pla: 0747: 
; libsrc/fpu_mf.pla: 0748: def squared
_P050 					; squared()
_C046 					; squared()
; libsrc/fpu_mf.pla: 0749:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0750: 
; libsrc/fpu_mf.pla: 0751:     // Square by multiplying by itself
; libsrc/fpu_mf.pla: 0752:     memcpy(stackRegs[1], stackRegs[0], t_extended)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0753:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 0754:     if err < 0
; libsrc/fpu_mf.pla: 0755:     
; libsrc/fpu_mf.pla: 0756:         sane:saveZP()
; libsrc/fpu_mf.pla: 0757:         return sane:restoreZP(sane:op2FP(FFEXT|FOMUL, stackRegs[0], stackRegs[0]))
	!BYTE	$6A			; LAW	_D118+2
_F357 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F358 	!WORD	_D118+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F359 	!WORD	0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F360 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B043
	!WORD	_B043-*
	!BYTE	$6A			; LAW	_X028+18
_F361 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$6A			; LAW	_D118+0
_F362 	!WORD	_D118+0		
	!BYTE	$34			; DUP
	!BYTE	$6A			; LAW	_X028+8
_F363 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F364 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0758:     fin
_B043 
_B044 
; libsrc/fpu_mf.pla: 0759: 
; libsrc/fpu_mf.pla: 0760:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0761: end
; libsrc/fpu_mf.pla: 0762: 
; libsrc/fpu_mf.pla: 0763: def logb
_P045 					; logb()
_C047 					; logb()
; libsrc/fpu_mf.pla: 0764:     // Log base - use SANE
; libsrc/fpu_mf.pla: 0765: 
; libsrc/fpu_mf.pla: 0766:     sane:saveZP()
; libsrc/fpu_mf.pla: 0767:     return sane:restoreZP(sane:op1FP(FFEXT|FOLOGB, stackRegs[0]))
	!BYTE	$6A			; LAW	_X028+18
_F365 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$6A			; LAW	_D118+0
_F366 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+6
_F367 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F368 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 0768: end
; libsrc/fpu_mf.pla: 0769: 
; libsrc/fpu_mf.pla: 0770: def scalb(scale)
					; scale -> [0]
_P046 					; scalb(scale)()
_C048 					; scalb()
; libsrc/fpu_mf.pla: 0771:     // scalb(x, n) = x * 2^n = x * pow2(n)
; libsrc/fpu_mf.pla: 0772:     // Hardware accelerated via pow2X and mul
; libsrc/fpu_mf.pla: 0773:     word err
					; err -> [2]
; libsrc/fpu_mf.pla: 0774: 
; libsrc/fpu_mf.pla: 0775:     if !mfAvailable
	!BYTE	$58,$04,$01		; ENTER	4,1
; libsrc/fpu_mf.pla: 0776:     
; libsrc/fpu_mf.pla: 0777:         sane:saveZP()
; libsrc/fpu_mf.pla: 0778:         return sane:restoreZP(sane:op2FP(FFEXT|FOSCALB, stackRegs[0], scale))
	!BYTE	$68			; LAB	_D119+0
_F369 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B045
	!WORD	_B045-*
	!BYTE	$6A			; LAW	_X028+18
_F370 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$18			; CB	24
	!BYTE	$6A			; LAW	_D118+0
_F371 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F372 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F373 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0779:     fin
_B045 
_B046 
; libsrc/fpu_mf.pla: 0780: 
; libsrc/fpu_mf.pla: 0781:     // Push scale as integer, convert to float, compute 2^scale
; libsrc/fpu_mf.pla: 0782:     err = pushInt(scale)
; libsrc/fpu_mf.pla: 0783:     if err < 0
; libsrc/fpu_mf.pla: 0784:         _drop(0)  // Drop the pushed value
; libsrc/fpu_mf.pla: 0785:     
; libsrc/fpu_mf.pla: 0786:         sane:saveZP()
; libsrc/fpu_mf.pla: 0787:         return sane:restoreZP(sane:op2FP(FFEXT|FOSCALB, stackRegs[1], scale))
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C012
_F374 	!WORD	_C012		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B047
	!WORD	_B047-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F375 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F376 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$18			; CB	24
	!BYTE	$6A			; LAW	_D118+2
_F377 	!WORD	_D118+2		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F378 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F379 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0788:     fin
_B047 
_B048 
; libsrc/fpu_mf.pla: 0789: 
; libsrc/fpu_mf.pla: 0790:     // Compute 2^scale
; libsrc/fpu_mf.pla: 0791:     err = pow2X
; libsrc/fpu_mf.pla: 0792:     if err < 0
; libsrc/fpu_mf.pla: 0793:         _drop(0)  // Drop the failed result
; libsrc/fpu_mf.pla: 0794:     
; libsrc/fpu_mf.pla: 0795:         sane:saveZP()
; libsrc/fpu_mf.pla: 0796:         return sane:restoreZP(sane:op2FP(FFEXT|FOSCALB, stackRegs[0], scale))
	!BYTE	$54			; CALL	_P067
_F380 	!WORD	_P067		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B049
	!WORD	_B049-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F381 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F382 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$18			; CB	24
	!BYTE	$6A			; LAW	_D118+0
_F383 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+8
_F384 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F385 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0797:     fin
_B049 
_B050 
; libsrc/fpu_mf.pla: 0798: 
; libsrc/fpu_mf.pla: 0799:     // Multiply x * 2^scale
; libsrc/fpu_mf.pla: 0800:     return mul
	!BYTE	$54			; CALL	_C036
_F386 	!WORD	_C036		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/fpu_mf.pla: 0801: end
; libsrc/fpu_mf.pla: 0802: 
; libsrc/fpu_mf.pla: 0803: //==============================================================================
; libsrc/fpu_mf.pla: 0804: // TRANSCENDENTAL FUNCTIONS (MegaFlash accelerated)
; libsrc/fpu_mf.pla: 0805: //==============================================================================
; libsrc/fpu_mf.pla: 0806: 
; libsrc/fpu_mf.pla: 0807: def cos
_P051 					; cos()
_C049 					; cos()
; libsrc/fpu_mf.pla: 0808:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0809: 
; libsrc/fpu_mf.pla: 0810:     err = execUnaryOp(MF_CMD_FCOS)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0811:     if err < 0
; libsrc/fpu_mf.pla: 0812:         // Use SANE ELEMS
; libsrc/fpu_mf.pla: 0813:     
; libsrc/fpu_mf.pla: 0814:         sane:saveZP()
; libsrc/fpu_mf.pla: 0815:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOCOSX, stackRegs[0]))
	!BYTE	$2A,$34			; CB	52
	!BYTE	$54			; CALL	_C033
_F387 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B051
	!WORD	_B051-*
	!BYTE	$6A			; LAW	_X028+18
_F388 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$6A			; LAW	_D118+0
_F389 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F390 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F391 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0816:     fin
_B051 
_B052 
; libsrc/fpu_mf.pla: 0817: 
; libsrc/fpu_mf.pla: 0818:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0819: end
; libsrc/fpu_mf.pla: 0820: 
; libsrc/fpu_mf.pla: 0821: def sin
_P052 					; sin()
_C050 					; sin()
; libsrc/fpu_mf.pla: 0822:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0823: 
; libsrc/fpu_mf.pla: 0824:     err = execUnaryOp(MF_CMD_FSIN)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0825:     if err < 0
; libsrc/fpu_mf.pla: 0826:     
; libsrc/fpu_mf.pla: 0827:         sane:saveZP()
; libsrc/fpu_mf.pla: 0828:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOSINX, stackRegs[0]))
	!BYTE	$2A,$33			; CB	51
	!BYTE	$54			; CALL	_C033
_F392 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B053
	!WORD	_B053-*
	!BYTE	$6A			; LAW	_X028+18
_F393 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$6A			; LAW	_D118+0
_F394 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F395 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F396 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0829:     fin
_B053 
_B054 
; libsrc/fpu_mf.pla: 0830: 
; libsrc/fpu_mf.pla: 0831:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0832: end
; libsrc/fpu_mf.pla: 0833: 
; libsrc/fpu_mf.pla: 0834: def tan
_P053 					; tan()
_C051 					; tan()
; libsrc/fpu_mf.pla: 0835:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0836: 
; libsrc/fpu_mf.pla: 0837:     err = execUnaryOp(MF_CMD_FTAN)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0838:     if err < 0
; libsrc/fpu_mf.pla: 0839:     
; libsrc/fpu_mf.pla: 0840:         sane:saveZP()
; libsrc/fpu_mf.pla: 0841:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOTANX, stackRegs[0]))
	!BYTE	$2A,$35			; CB	53
	!BYTE	$54			; CALL	_C033
_F397 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B055
	!WORD	_B055-*
	!BYTE	$6A			; LAW	_X028+18
_F398 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1E			; CB	30
	!BYTE	$6A			; LAW	_D118+0
_F399 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F400 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F401 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0842:     fin
_B055 
_B056 
; libsrc/fpu_mf.pla: 0843: 
; libsrc/fpu_mf.pla: 0844:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0845: end
; libsrc/fpu_mf.pla: 0846: 
; libsrc/fpu_mf.pla: 0847: def atan
_P054 					; atan()
_C052 					; atan()
; libsrc/fpu_mf.pla: 0848:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0849: 
; libsrc/fpu_mf.pla: 0850:     err = execUnaryOp(MF_CMD_FATN)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0851:     if err < 0
; libsrc/fpu_mf.pla: 0852:     
; libsrc/fpu_mf.pla: 0853:         sane:saveZP()
; libsrc/fpu_mf.pla: 0854:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOATANX, stackRegs[0]))
	!BYTE	$2A,$36			; CB	54
	!BYTE	$54			; CALL	_C033
_F402 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B057
	!WORD	_B057-*
	!BYTE	$6A			; LAW	_X028+18
_F403 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$18			; CB	24
	!BYTE	$6A			; LAW	_D118+0
_F404 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F405 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F406 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0855:     fin
_B057 
_B058 
; libsrc/fpu_mf.pla: 0856: 
; libsrc/fpu_mf.pla: 0857:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0858: end
; libsrc/fpu_mf.pla: 0859: 
; libsrc/fpu_mf.pla: 0860: def log2X
_P063 					; log2X()
_C053 					; log2X()
; libsrc/fpu_mf.pla: 0861:     // log2(x) = ln(x) / ln(2)
; libsrc/fpu_mf.pla: 0862:     // Use hardware ln, then divide by ln(2)
; libsrc/fpu_mf.pla: 0863:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0864: 
; libsrc/fpu_mf.pla: 0865:     // Compute ln(x)
; libsrc/fpu_mf.pla: 0866:     err = execUnaryOp(MF_CMD_FLOG)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0867:     if err < 0
; libsrc/fpu_mf.pla: 0868:         // Fallback to SANE
; libsrc/fpu_mf.pla: 0869:     
; libsrc/fpu_mf.pla: 0870:         sane:saveZP()
; libsrc/fpu_mf.pla: 0871:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLOG2X, stackRegs[0]))
	!BYTE	$2A,$37			; CB	55
	!BYTE	$54			; CALL	_C033
_F407 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B059
	!WORD	_B059-*
	!BYTE	$6A			; LAW	_X028+18
_F408 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_D118+0
_F409 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F410 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F411 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0872:     fin
_B059 
_B060 
; libsrc/fpu_mf.pla: 0873: 
; libsrc/fpu_mf.pla: 0874:     // Divide by ln(2)
; libsrc/fpu_mf.pla: 0875:     memcpy(stackRegs[1], @ext_ln2, t_extended)
; libsrc/fpu_mf.pla: 0876:     swap
; libsrc/fpu_mf.pla: 0877:     return div
	!BYTE	$6A			; LAW	_D118+2
_F412 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D113+0
_F413 	!WORD	_D113+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F414 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F415 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F416 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0878: end
; libsrc/fpu_mf.pla: 0879: 
; libsrc/fpu_mf.pla: 0880: def log21X
_P064 					; log21X()
_C054 					; log21X()
; libsrc/fpu_mf.pla: 0881:     // log2(1+x) = ln(1+x) / ln(2)
; libsrc/fpu_mf.pla: 0882:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0883: 
; libsrc/fpu_mf.pla: 0884:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0885:     
; libsrc/fpu_mf.pla: 0886:         sane:saveZP()
; libsrc/fpu_mf.pla: 0887:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLOG21X, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F417 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B061
	!WORD	_B061-*
	!BYTE	$6A			; LAW	_X028+18
_F418 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$0C			; CN	6
	!BYTE	$6A			; LAW	_D118+0
_F419 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F420 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F421 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0888:     fin
_B061 
_B062 
; libsrc/fpu_mf.pla: 0889: 
; libsrc/fpu_mf.pla: 0890:     // Compute ln(1+x)
; libsrc/fpu_mf.pla: 0891:     err = ln1X
; libsrc/fpu_mf.pla: 0892:     if err < 0
; libsrc/fpu_mf.pla: 0893:     
; libsrc/fpu_mf.pla: 0894:         sane:saveZP()
; libsrc/fpu_mf.pla: 0895:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLOG21X, stackRegs[0]))
	!BYTE	$54			; CALL	_P066
_F422 	!WORD	_P066		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B063
	!WORD	_B063-*
	!BYTE	$6A			; LAW	_X028+18
_F423 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$0C			; CN	6
	!BYTE	$6A			; LAW	_D118+0
_F424 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F425 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F426 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0896:     fin
_B063 
_B064 
; libsrc/fpu_mf.pla: 0897: 
; libsrc/fpu_mf.pla: 0898:     // Divide by ln(2)
; libsrc/fpu_mf.pla: 0899:     memcpy(stackRegs[1], @ext_ln2, t_extended)
; libsrc/fpu_mf.pla: 0900:     swap
; libsrc/fpu_mf.pla: 0901:     return div
	!BYTE	$6A			; LAW	_D118+2
_F427 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D113+0
_F428 	!WORD	_D113+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F429 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F430 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F431 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0902: end
; libsrc/fpu_mf.pla: 0903: 
; libsrc/fpu_mf.pla: 0904: def lnX
_P065 					; lnX()
_C055 					; lnX()
; libsrc/fpu_mf.pla: 0905:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0906: 
; libsrc/fpu_mf.pla: 0907:     err = execUnaryOp(MF_CMD_FLOG)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0908:     if err < 0
; libsrc/fpu_mf.pla: 0909:     
; libsrc/fpu_mf.pla: 0910:         sane:saveZP()
; libsrc/fpu_mf.pla: 0911:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLNX, stackRegs[0]))
	!BYTE	$2A,$37			; CB	55
	!BYTE	$54			; CALL	_C033
_F432 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B065
	!WORD	_B065-*
	!BYTE	$6A			; LAW	_X028+18
_F433 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D118+0
_F434 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F435 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F436 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0912:     fin
_B065 
_B066 
; libsrc/fpu_mf.pla: 0913: 
; libsrc/fpu_mf.pla: 0914:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0915: end
; libsrc/fpu_mf.pla: 0916: 
; libsrc/fpu_mf.pla: 0917: def ln1X
_P066 					; ln1X()
_C056 					; ln1X()
; libsrc/fpu_mf.pla: 0918:     // ln(1+x) = ln(1 + x)
; libsrc/fpu_mf.pla: 0919:     // Add 1 to x, then compute ln
; libsrc/fpu_mf.pla: 0920:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0921: 
; libsrc/fpu_mf.pla: 0922:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0923:     
; libsrc/fpu_mf.pla: 0924:         sane:saveZP()
; libsrc/fpu_mf.pla: 0925:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLN1X, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F437 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B067
	!WORD	_B067-*
	!BYTE	$6A			; LAW	_X028+18
_F438 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$6A			; LAW	_D118+0
_F439 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F440 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F441 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0926:     fin
_B067 
_B068 
; libsrc/fpu_mf.pla: 0927: 
; libsrc/fpu_mf.pla: 0928:     // Compute 1 + x
; libsrc/fpu_mf.pla: 0929:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 0930:     err = add
; libsrc/fpu_mf.pla: 0931:     if err < 0
; libsrc/fpu_mf.pla: 0932:         // Fallback
; libsrc/fpu_mf.pla: 0933:     
; libsrc/fpu_mf.pla: 0934:         sane:saveZP()
; libsrc/fpu_mf.pla: 0935:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOLN1X, stackRegs[0]))
	!BYTE	$6A			; LAW	_D118+2
_F442 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F443 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F444 	!WORD	0		
	!BYTE	$54			; CALL	_C034
_F445 	!WORD	_C034		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B069
	!WORD	_B069-*
	!BYTE	$6A			; LAW	_X028+18
_F446 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$08			; CN	4
	!BYTE	$6A			; LAW	_D118+0
_F447 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F448 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F449 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0936:     fin
_B069 
_B070 
; libsrc/fpu_mf.pla: 0937: 
; libsrc/fpu_mf.pla: 0938:     // Compute ln(1 + x)
; libsrc/fpu_mf.pla: 0939:     return execUnaryOp(MF_CMD_FLOG)
	!BYTE	$2A,$37			; CB	55
	!BYTE	$54			; CALL	_C033
_F450 	!WORD	_C033		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0940: end
; libsrc/fpu_mf.pla: 0941: 
; libsrc/fpu_mf.pla: 0942: def pow2X
_P067 					; pow2X()
_C057 					; pow2X()
; libsrc/fpu_mf.pla: 0943:     // 2^x = e^(x * ln(2))
; libsrc/fpu_mf.pla: 0944:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0945: 
; libsrc/fpu_mf.pla: 0946:     // Multiply x by ln(2)
; libsrc/fpu_mf.pla: 0947:     memcpy(stackRegs[1], stackRegs[0], t_extended)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0948:     memcpy(stackRegs[0], @ext_ln2, t_extended)
; libsrc/fpu_mf.pla: 0949:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 0950:     if err < 0
; libsrc/fpu_mf.pla: 0951:         // Fallback
; libsrc/fpu_mf.pla: 0952:     
; libsrc/fpu_mf.pla: 0953:         sane:saveZP()
; libsrc/fpu_mf.pla: 0954:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP2X, stackRegs[1]))
	!BYTE	$6A			; LAW	_D118+2
_F451 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F452 	!WORD	_D118+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F453 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+0
_F454 	!WORD	_D118+0		
	!BYTE	$26			; LA	_D113+0
_F455 	!WORD	_D113+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F456 	!WORD	0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F457 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B071
	!WORD	_B071-*
	!BYTE	$6A			; LAW	_X028+18
_F458 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$14			; CN	10
	!BYTE	$6A			; LAW	_D118+2
_F459 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+12
_F460 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F461 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0955:     fin
_B071 
_B072 
; libsrc/fpu_mf.pla: 0956: 
; libsrc/fpu_mf.pla: 0957:     // Compute e^(x*ext_ln2)
; libsrc/fpu_mf.pla: 0958:     return execUnaryOp(MF_CMD_FEXP)
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F462 	!WORD	_C033		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0959: end
; libsrc/fpu_mf.pla: 0960: 
; libsrc/fpu_mf.pla: 0961: def pow21X
_P068 					; pow21X()
_C058 					; pow21X()
; libsrc/fpu_mf.pla: 0962:     // 2^x - 1 = e^(x*ln(2)) - 1
; libsrc/fpu_mf.pla: 0963:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0964: 
; libsrc/fpu_mf.pla: 0965:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0966:     
; libsrc/fpu_mf.pla: 0967:         sane:saveZP()
; libsrc/fpu_mf.pla: 0968:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP21X, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F463 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B073
	!WORD	_B073-*
	!BYTE	$6A			; LAW	_X028+18
_F464 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D118+0
_F465 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F466 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F467 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0969:     fin
_B073 
_B074 
; libsrc/fpu_mf.pla: 0970: 
; libsrc/fpu_mf.pla: 0971:     // Multiply x by ln(2)
; libsrc/fpu_mf.pla: 0972:     memcpy(stackRegs[1], stackRegs[0], t_extended)
; libsrc/fpu_mf.pla: 0973:     memcpy(stackRegs[0], @ext_ln2, t_extended)
; libsrc/fpu_mf.pla: 0974:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 0975:     if err < 0
; libsrc/fpu_mf.pla: 0976:     
; libsrc/fpu_mf.pla: 0977:         sane:saveZP()
; libsrc/fpu_mf.pla: 0978:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP21X, stackRegs[1]))
	!BYTE	$6A			; LAW	_D118+2
_F468 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F469 	!WORD	_D118+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F470 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+0
_F471 	!WORD	_D118+0		
	!BYTE	$26			; LA	_D113+0
_F472 	!WORD	_D113+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F473 	!WORD	0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F474 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$6A			; LAW	_X028+18
_F475 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D118+2
_F476 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+12
_F477 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F478 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0979:     fin
_B075 
_B076 
; libsrc/fpu_mf.pla: 0980: 
; libsrc/fpu_mf.pla: 0981:     // Compute e^(x*ext_ln2)
; libsrc/fpu_mf.pla: 0982:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 0983:     if err; return err; fin
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F479 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B077
	!WORD	_B077-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B077 
_B078 
; libsrc/fpu_mf.pla: 0984: 
; libsrc/fpu_mf.pla: 0985:     // Subtract 1
; libsrc/fpu_mf.pla: 0986:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 0987:     return sub
	!BYTE	$6A			; LAW	_D118+2
_F480 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F481 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F482 	!WORD	0		
	!BYTE	$54			; CALL	_C035
_F483 	!WORD	_C035		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0988: end
; libsrc/fpu_mf.pla: 0989: 
; libsrc/fpu_mf.pla: 0990: def powEX
_P069 					; powEX()
_C059 					; powEX()
; libsrc/fpu_mf.pla: 0991:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 0992: 
; libsrc/fpu_mf.pla: 0993:     err = execUnaryOp(MF_CMD_FEXP)
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 0994:     if err < 0
; libsrc/fpu_mf.pla: 0995:     
; libsrc/fpu_mf.pla: 0996:         sane:saveZP()
; libsrc/fpu_mf.pla: 0997:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXPX, stackRegs[0]))
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F484 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B079
	!WORD	_B079-*
	!BYTE	$6A			; LAW	_X028+18
_F485 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$10			; CN	8
	!BYTE	$6A			; LAW	_D118+0
_F486 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F487 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F488 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 0998:     fin
_B079 
_B080 
; libsrc/fpu_mf.pla: 0999: 
; libsrc/fpu_mf.pla: 1000:     return err
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1001: end
; libsrc/fpu_mf.pla: 1002: 
; libsrc/fpu_mf.pla: 1003: def powE1X
_P070 					; powE1X()
_C060 					; powE1X()
; libsrc/fpu_mf.pla: 1004:     // e^x - 1 = exp(x) - 1
; libsrc/fpu_mf.pla: 1005:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1006: 
; libsrc/fpu_mf.pla: 1007:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1008:     
; libsrc/fpu_mf.pla: 1009:         sane:saveZP()
; libsrc/fpu_mf.pla: 1010:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP1X, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F489 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B081
	!WORD	_B081-*
	!BYTE	$6A			; LAW	_X028+18
_F490 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$18			; CN	12
	!BYTE	$6A			; LAW	_D118+0
_F491 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F492 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F493 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1011:     fin
_B081 
_B082 
; libsrc/fpu_mf.pla: 1012: 
; libsrc/fpu_mf.pla: 1013:     // Compute e^x
; libsrc/fpu_mf.pla: 1014:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1015:     if err < 0
; libsrc/fpu_mf.pla: 1016:     
; libsrc/fpu_mf.pla: 1017:         sane:saveZP()
; libsrc/fpu_mf.pla: 1018:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP1X, stackRegs[0]))
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F494 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B083
	!WORD	_B083-*
	!BYTE	$6A			; LAW	_X028+18
_F495 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$18			; CN	12
	!BYTE	$6A			; LAW	_D118+0
_F496 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F497 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F498 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1019:     fin
_B083 
_B084 
; libsrc/fpu_mf.pla: 1020: 
; libsrc/fpu_mf.pla: 1021:     // Subtract 1
; libsrc/fpu_mf.pla: 1022:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1023:     return sub
	!BYTE	$6A			; LAW	_D118+2
_F499 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F500 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F501 	!WORD	0		
	!BYTE	$54			; CALL	_C035
_F502 	!WORD	_C035		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1024: end
; libsrc/fpu_mf.pla: 1025: 
; libsrc/fpu_mf.pla: 1026: def powE21X
_P071 					; powE21X()
_C061 					; powE21X()
; libsrc/fpu_mf.pla: 1027:     // e^(2x) - 1 = exp(2x) - 1
; libsrc/fpu_mf.pla: 1028:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1029: 
; libsrc/fpu_mf.pla: 1030:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1031:     
; libsrc/fpu_mf.pla: 1032:         sane:saveZP()
; libsrc/fpu_mf.pla: 1033:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP21X, stackRegs[0]))
	!BYTE	$68			; LAB	_D119+0
_F503 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B085
	!WORD	_B085-*
	!BYTE	$6A			; LAW	_X028+18
_F504 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D118+0
_F505 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F506 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F507 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1034:     fin
_B085 
_B086 
; libsrc/fpu_mf.pla: 1035: 
; libsrc/fpu_mf.pla: 1036:     // Multiply x by 2
; libsrc/fpu_mf.pla: 1037:     memcpy(stackRegs[1], stackRegs[0], t_extended)
; libsrc/fpu_mf.pla: 1038:     memcpy(stackRegs[0], @ext_two, t_extended)
; libsrc/fpu_mf.pla: 1039:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 1040:     if err < 0
; libsrc/fpu_mf.pla: 1041:     
; libsrc/fpu_mf.pla: 1042:         sane:saveZP()
; libsrc/fpu_mf.pla: 1043:         return sane:restoreZP(sane:op1ELEM(FFEXT|FOEXP21X, stackRegs[0]))
	!BYTE	$6A			; LAW	_D118+2
_F508 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F509 	!WORD	_D118+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F510 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+0
_F511 	!WORD	_D118+0		
	!BYTE	$26			; LA	_D115+0
_F512 	!WORD	_D115+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F513 	!WORD	0		
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F514 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B087
	!WORD	_B087-*
	!BYTE	$6A			; LAW	_X028+18
_F515 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D118+0
_F516 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+12
_F517 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F518 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1044:     fin
_B087 
_B088 
; libsrc/fpu_mf.pla: 1045: 
; libsrc/fpu_mf.pla: 1046:     // Compute e^(2x)
; libsrc/fpu_mf.pla: 1047:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1048:     if err; return err; fin
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F519 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B089
	!WORD	_B089-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B089 
_B090 
; libsrc/fpu_mf.pla: 1049: 
; libsrc/fpu_mf.pla: 1050:     // Subtract 1
; libsrc/fpu_mf.pla: 1051:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1052:     return sub
	!BYTE	$6A			; LAW	_D118+2
_F520 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F521 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F522 	!WORD	0		
	!BYTE	$54			; CALL	_C035
_F523 	!WORD	_C035		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1053: end
; libsrc/fpu_mf.pla: 1054: 
; libsrc/fpu_mf.pla: 1055: def powXInt(powInt)
					; powInt -> [0]
_P072 					; powXInt(powInt)()
_C062 					; powXInt()
; libsrc/fpu_mf.pla: 1056:     // x^n = e^(n * ln(x))
; libsrc/fpu_mf.pla: 1057:     word err, intVal
					; err -> [2]
					; intVal -> [4]
; libsrc/fpu_mf.pla: 1058: 
; libsrc/fpu_mf.pla: 1059:     if !mfAvailable
	!BYTE	$58,$06,$01		; ENTER	6,1
; libsrc/fpu_mf.pla: 1060:     
; libsrc/fpu_mf.pla: 1061:         sane:saveZP()
; libsrc/fpu_mf.pla: 1062:         return sane:restoreZP(sane:op2ELEM(FFEXT|FOXPWRI, stackRegs[0], powInt))
	!BYTE	$68			; LAB	_D119+0
_F524 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B091
	!WORD	_B091-*
	!BYTE	$6A			; LAW	_X028+18
_F525 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$6A			; LAW	_D118+0
_F526 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+14
_F527 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F528 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/fpu_mf.pla: 1063:     fin
_B091 
_B092 
; libsrc/fpu_mf.pla: 1064: 
; libsrc/fpu_mf.pla: 1065:     // Compute ln(x)
; libsrc/fpu_mf.pla: 1066:     err = execUnaryOp(MF_CMD_FLOG)
; libsrc/fpu_mf.pla: 1067:     if err < 0
; libsrc/fpu_mf.pla: 1068:     
; libsrc/fpu_mf.pla: 1069:         sane:saveZP()
; libsrc/fpu_mf.pla: 1070:         return sane:restoreZP(sane:op2ELEM(FFEXT|FOXPWRI, stackRegs[0], powInt))
	!BYTE	$2A,$37			; CB	55
	!BYTE	$54			; CALL	_C033
_F529 	!WORD	_C033		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B093
	!WORD	_B093-*
	!BYTE	$6A			; LAW	_X028+18
_F530 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$6A			; LAW	_D118+0
_F531 	!WORD	_D118+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+14
_F532 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F533 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/fpu_mf.pla: 1071:     fin
_B093 
_B094 
; libsrc/fpu_mf.pla: 1072: 
; libsrc/fpu_mf.pla: 1073:     // Convert integer to extended and multiply
; libsrc/fpu_mf.pla: 1074:     pushInt(powInt)
; libsrc/fpu_mf.pla: 1075:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 1076:     if err; return err; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C012
_F534 	!WORD	_C012		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F535 	!WORD	_C032		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4C			; BRFLS	_B095
	!WORD	_B095-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$06			; LEAVE	6
_B095 
_B096 
; libsrc/fpu_mf.pla: 1077: 
; libsrc/fpu_mf.pla: 1078:     // Compute e^(n * ln(x))
; libsrc/fpu_mf.pla: 1079:     return execUnaryOp(MF_CMD_FEXP)
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F536 	!WORD	_C033		
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/fpu_mf.pla: 1080: end
; libsrc/fpu_mf.pla: 1081: 
; libsrc/fpu_mf.pla: 1082: def powXY
_P073 					; powXY()
_C063 					; powXY()
; libsrc/fpu_mf.pla: 1083:     // x^y = e^(y * ln(x))
; libsrc/fpu_mf.pla: 1084:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1085: 
; libsrc/fpu_mf.pla: 1086:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1087:     
; libsrc/fpu_mf.pla: 1088:         sane:saveZP()
; libsrc/fpu_mf.pla: 1089:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOXPWRY, stackRegs[0], stackRegs[1]))))
	!BYTE	$68			; LAB	_D119+0
_F537 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B097
	!WORD	_B097-*
	!BYTE	$6A			; LAW	_X028+18
_F538 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$12			; CB	18
	!BYTE	$6A			; LAW	_D118+0
_F539 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F540 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F541 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F542 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F543 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F544 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1090:     fin
_B097 
_B098 
; libsrc/fpu_mf.pla: 1091: 
; libsrc/fpu_mf.pla: 1092:     // Stack has: y, x (top to bottom)
; libsrc/fpu_mf.pla: 1093:     // We need: ln(x), then multiply by y, then exp
; libsrc/fpu_mf.pla: 1094: 
; libsrc/fpu_mf.pla: 1095:     // Compute ln(x) - x is on top of stack
; libsrc/fpu_mf.pla: 1096:     err = execUnaryOp(MF_CMD_FLOG)
; libsrc/fpu_mf.pla: 1097:     if err < 0
; libsrc/fpu_mf.pla: 1098:     
; libsrc/fpu_mf.pla: 1099:         sane:saveZP()
; libsrc/fpu_mf.pla: 1100:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOXPWRY, stackRegs[1], stackRegs[0]))))
	!BYTE	$2A,$37			; CB	55
	!BYTE	$54			; CALL	_C033
_F545 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B099
	!WORD	_B099-*
	!BYTE	$6A			; LAW	_X028+18
_F546 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$12			; CB	18
	!BYTE	$6A			; LAW	_D118+2
_F547 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F548 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_X028+14
_F549 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F550 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F551 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F552 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1101:     fin
_B099 
_B100 
; libsrc/fpu_mf.pla: 1102: 
; libsrc/fpu_mf.pla: 1103:     // Now stack has: y, ln(x)
; libsrc/fpu_mf.pla: 1104:     // Multiply y * ln(x)
; libsrc/fpu_mf.pla: 1105:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 1106:     if err; return _drop(err); fin
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F553 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B101
	!WORD	_B101-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C007
_F554 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
_B101 
_B102 
; libsrc/fpu_mf.pla: 1107: 
; libsrc/fpu_mf.pla: 1108:     // Compute e^(y * ln(x))
; libsrc/fpu_mf.pla: 1109:     return _drop(execUnaryOp(MF_CMD_FEXP))
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F555 	!WORD	_C033		
	!BYTE	$54			; CALL	_C007
_F556 	!WORD	_C007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1110: end
; libsrc/fpu_mf.pla: 1111: 
; libsrc/fpu_mf.pla: 1112: //==============================================================================
; libsrc/fpu_mf.pla: 1113: // ADDITIONAL TRIG FUNCTIONS (using hardware acceleration + identities)
; libsrc/fpu_mf.pla: 1114: //==============================================================================
; libsrc/fpu_mf.pla: 1115: 
; libsrc/fpu_mf.pla: 1116: //
; libsrc/fpu_mf.pla: 1117: // Inverse Sine: asin(x) = atan(x / sqrt(1 - x²))
; libsrc/fpu_mf.pla: 1118: // Valid for -1 <= x <= 1
; libsrc/fpu_mf.pla: 1119: //
; libsrc/fpu_mf.pla: 1120: def asin
_P055 					; asin()
_C064 					; asin()
; libsrc/fpu_mf.pla: 1121:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1122: 
; libsrc/fpu_mf.pla: 1123:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1124:         // No direct SANE asin, but could implement with identities if needed
; libsrc/fpu_mf.pla: 1125:         // For now, return error
; libsrc/fpu_mf.pla: 1126:         return -1
	!BYTE	$68			; LAB	_D119+0
_F557 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B103
	!WORD	_B103-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1127:     fin
_B103 
_B104 
; libsrc/fpu_mf.pla: 1128: 
; libsrc/fpu_mf.pla: 1129:     // Save x
; libsrc/fpu_mf.pla: 1130:     dup
; libsrc/fpu_mf.pla: 1131: 
; libsrc/fpu_mf.pla: 1132:     // Compute x²
; libsrc/fpu_mf.pla: 1133:     dup
; libsrc/fpu_mf.pla: 1134:     err = execBinaryOp(MF_CMD_FMUL)
; libsrc/fpu_mf.pla: 1135:     if err; return err; fin
	!BYTE	$54			; CALL	_C010
_F558 	!WORD	_C010		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C010
_F559 	!WORD	_C010		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$31			; CB	49
	!BYTE	$54			; CALL	_C032
_F560 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B105 
_B106 
; libsrc/fpu_mf.pla: 1136: 
; libsrc/fpu_mf.pla: 1137:     // Compute 1 - x²
; libsrc/fpu_mf.pla: 1138:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1139:     swap
; libsrc/fpu_mf.pla: 1140:     neg
; libsrc/fpu_mf.pla: 1141:     add  // 1 + (-x²)
; libsrc/fpu_mf.pla: 1142: 
; libsrc/fpu_mf.pla: 1143:     // Compute sqrt(1 - x²)
; libsrc/fpu_mf.pla: 1144:     err = execUnaryOp(MF_CMD_FSQR)
; libsrc/fpu_mf.pla: 1145:     if err; return err; fin
	!BYTE	$6A			; LAW	_D118+2
_F561 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F562 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F563 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F564 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C039
_F565 	!WORD	_C039		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C034
_F566 	!WORD	_C034		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$39			; CB	57
	!BYTE	$54			; CALL	_C033
_F567 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B107 
_B108 
; libsrc/fpu_mf.pla: 1146: 
; libsrc/fpu_mf.pla: 1147:     // Swap to get x / sqrt(1 - x²)
; libsrc/fpu_mf.pla: 1148:     swap
; libsrc/fpu_mf.pla: 1149:     err = execBinaryOp(MF_CMD_FDIV)
; libsrc/fpu_mf.pla: 1150:     if err; return err; fin
	!BYTE	$54			; CALL	_C008
_F568 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$32			; CB	50
	!BYTE	$54			; CALL	_C032
_F569 	!WORD	_C032		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B109
	!WORD	_B109-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B109 
_B110 
; libsrc/fpu_mf.pla: 1151: 
; libsrc/fpu_mf.pla: 1152:     // Compute atan
; libsrc/fpu_mf.pla: 1153:     return execUnaryOp(MF_CMD_FATN)
	!BYTE	$2A,$36			; CB	54
	!BYTE	$54			; CALL	_C033
_F570 	!WORD	_C033		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1154: end
; libsrc/fpu_mf.pla: 1155: 
; libsrc/fpu_mf.pla: 1156: //
; libsrc/fpu_mf.pla: 1157: // Inverse Cosine: acos(x) = π/2 - asin(x)
; libsrc/fpu_mf.pla: 1158: //
; libsrc/fpu_mf.pla: 1159: def acos
_P056 					; acos()
_C065 					; acos()
; libsrc/fpu_mf.pla: 1160:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1161: 
; libsrc/fpu_mf.pla: 1162:     // Compute asin(x)
; libsrc/fpu_mf.pla: 1163:     err = asin
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1164:     if err; return err; fin
	!BYTE	$54			; CALL	_C064
_F571 	!WORD	_C064		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B111
	!WORD	_B111-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B111 
_B112 
; libsrc/fpu_mf.pla: 1165: 
; libsrc/fpu_mf.pla: 1166:     // Subtract from π/2
; libsrc/fpu_mf.pla: 1167:     constPi
; libsrc/fpu_mf.pla: 1168:     pushStr("2.0")
	!BYTE	$54			; CALL	_P007
_F572 	!WORD	_P007		
	!BYTE	$30			; DROP 
	!BYTE	$2E			; CS
	!BYTE	$03
	!BYTE	$32,$2E,$30
	!BYTE	$54			; CALL	_C028
_F573 	!WORD	_C028		
	!BYTE	$30			; DROP 
; libsrc/fpu_mf.pla: 1169:     div
; libsrc/fpu_mf.pla: 1170:     swap
; libsrc/fpu_mf.pla: 1171:     return sub
	!BYTE	$54			; CALL	_C037
_F574 	!WORD	_C037		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C008
_F575 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C035
_F576 	!WORD	_C035		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1172: end
; libsrc/fpu_mf.pla: 1173: 
; libsrc/fpu_mf.pla: 1174: //
; libsrc/fpu_mf.pla: 1175: // Hyperbolic Sine: sinh(x) = (e^x - e^-x) / 2
; libsrc/fpu_mf.pla: 1176: //
; libsrc/fpu_mf.pla: 1177: def sinh
_P057 					; sinh()
_C066 					; sinh()
; libsrc/fpu_mf.pla: 1178:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1179: 
; libsrc/fpu_mf.pla: 1180:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1181:     
; libsrc/fpu_mf.pla: 1182:         // SANE doesn't have sinh either, would need to implement
; libsrc/fpu_mf.pla: 1183:         return -1
	!BYTE	$68			; LAB	_D119+0
_F577 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B113
	!WORD	_B113-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1184:     fin
_B113 
_B114 
; libsrc/fpu_mf.pla: 1185: 
; libsrc/fpu_mf.pla: 1186:     // Save x
; libsrc/fpu_mf.pla: 1187:     dup
; libsrc/fpu_mf.pla: 1188: 
; libsrc/fpu_mf.pla: 1189:     // Compute e^x
; libsrc/fpu_mf.pla: 1190:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1191:     if err; return err; fin
	!BYTE	$54			; CALL	_C010
_F578 	!WORD	_C010		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F579 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B115
	!WORD	_B115-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B115 
_B116 
; libsrc/fpu_mf.pla: 1192: 
; libsrc/fpu_mf.pla: 1193:     // Get x again for e^-x
; libsrc/fpu_mf.pla: 1194:     swap
; libsrc/fpu_mf.pla: 1195:     neg
; libsrc/fpu_mf.pla: 1196:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1197:     if err; return err; fin
	!BYTE	$54			; CALL	_C008
_F580 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C039
_F581 	!WORD	_C039		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F582 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B117 
_B118 
; libsrc/fpu_mf.pla: 1198: 
; libsrc/fpu_mf.pla: 1199:     // Compute e^x - e^-x
; libsrc/fpu_mf.pla: 1200:     swap
; libsrc/fpu_mf.pla: 1201:     sub
; libsrc/fpu_mf.pla: 1202: 
; libsrc/fpu_mf.pla: 1203:     // Divide by 2
; libsrc/fpu_mf.pla: 1204:     memcpy(stackRegs[1], @ext_two, t_extended)
; libsrc/fpu_mf.pla: 1205:     swap
; libsrc/fpu_mf.pla: 1206:     return div
	!BYTE	$54			; CALL	_C008
_F583 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C035
_F584 	!WORD	_C035		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D118+2
_F585 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D115+0
_F586 	!WORD	_D115+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F587 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F588 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F589 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1207: end
; libsrc/fpu_mf.pla: 1208: 
; libsrc/fpu_mf.pla: 1209: //
; libsrc/fpu_mf.pla: 1210: // Hyperbolic Cosine: cosh(x) = (e^x + e^-x) / 2
; libsrc/fpu_mf.pla: 1211: //
; libsrc/fpu_mf.pla: 1212: def cosh
_P058 					; cosh()
_C067 					; cosh()
; libsrc/fpu_mf.pla: 1213:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1214: 
; libsrc/fpu_mf.pla: 1215:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1216:     
; libsrc/fpu_mf.pla: 1217:         return -1
	!BYTE	$68			; LAB	_D119+0
_F590 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B119
	!WORD	_B119-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1218:     fin
_B119 
_B120 
; libsrc/fpu_mf.pla: 1219: 
; libsrc/fpu_mf.pla: 1220:     // Save x
; libsrc/fpu_mf.pla: 1221:     dup
; libsrc/fpu_mf.pla: 1222: 
; libsrc/fpu_mf.pla: 1223:     // Compute e^x
; libsrc/fpu_mf.pla: 1224:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1225:     if err; return err; fin
	!BYTE	$54			; CALL	_C010
_F591 	!WORD	_C010		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F592 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B121
	!WORD	_B121-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B121 
_B122 
; libsrc/fpu_mf.pla: 1226: 
; libsrc/fpu_mf.pla: 1227:     // Get x again for e^-x
; libsrc/fpu_mf.pla: 1228:     swap
; libsrc/fpu_mf.pla: 1229:     neg
; libsrc/fpu_mf.pla: 1230:     err = execUnaryOp(MF_CMD_FEXP)
; libsrc/fpu_mf.pla: 1231:     if err; return err; fin
	!BYTE	$54			; CALL	_C008
_F593 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C039
_F594 	!WORD	_C039		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_C033
_F595 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B123
	!WORD	_B123-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B123 
_B124 
; libsrc/fpu_mf.pla: 1232: 
; libsrc/fpu_mf.pla: 1233:     // Compute e^x + e^-x
; libsrc/fpu_mf.pla: 1234:     swap
; libsrc/fpu_mf.pla: 1235:     add
; libsrc/fpu_mf.pla: 1236: 
; libsrc/fpu_mf.pla: 1237:     // Divide by 2
; libsrc/fpu_mf.pla: 1238:     memcpy(stackRegs[1], @ext_two, t_extended)
; libsrc/fpu_mf.pla: 1239:     swap
; libsrc/fpu_mf.pla: 1240:     return div
	!BYTE	$54			; CALL	_C008
_F596 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C034
_F597 	!WORD	_C034		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D118+2
_F598 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D115+0
_F599 	!WORD	_D115+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F600 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F601 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F602 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1241: end
; libsrc/fpu_mf.pla: 1242: 
; libsrc/fpu_mf.pla: 1243: //
; libsrc/fpu_mf.pla: 1244: // Hyperbolic Tangent: tanh(x) = sinh(x) / cosh(x)
; libsrc/fpu_mf.pla: 1245: //
; libsrc/fpu_mf.pla: 1246: def tanh
_P059 					; tanh()
_C068 					; tanh()
; libsrc/fpu_mf.pla: 1247:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1248: 
; libsrc/fpu_mf.pla: 1249:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1250:     
; libsrc/fpu_mf.pla: 1251:         return -1
	!BYTE	$68			; LAB	_D119+0
_F603 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B125
	!WORD	_B125-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1252:     fin
_B125 
_B126 
; libsrc/fpu_mf.pla: 1253: 
; libsrc/fpu_mf.pla: 1254:     // Save x for cosh
; libsrc/fpu_mf.pla: 1255:     dup
; libsrc/fpu_mf.pla: 1256: 
; libsrc/fpu_mf.pla: 1257:     // Compute sinh(x)
; libsrc/fpu_mf.pla: 1258:     err = sinh
; libsrc/fpu_mf.pla: 1259:     if err; return err; fin
	!BYTE	$54			; CALL	_C010
_F604 	!WORD	_C010		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C066
_F605 	!WORD	_C066		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B127
	!WORD	_B127-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B127 
_B128 
; libsrc/fpu_mf.pla: 1260: 
; libsrc/fpu_mf.pla: 1261:     // Get x again
; libsrc/fpu_mf.pla: 1262:     swap
; libsrc/fpu_mf.pla: 1263: 
; libsrc/fpu_mf.pla: 1264:     // Compute cosh(x)
; libsrc/fpu_mf.pla: 1265:     err = cosh
; libsrc/fpu_mf.pla: 1266:     if err; return err; fin
	!BYTE	$54			; CALL	_C008
_F606 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C067
_F607 	!WORD	_C067		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B129
	!WORD	_B129-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B129 
_B130 
; libsrc/fpu_mf.pla: 1267: 
; libsrc/fpu_mf.pla: 1268:     // Divide sinh/cosh
; libsrc/fpu_mf.pla: 1269:     swap
; libsrc/fpu_mf.pla: 1270:     return div
	!BYTE	$54			; CALL	_C008
_F608 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F609 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1271: end
; libsrc/fpu_mf.pla: 1272: 
; libsrc/fpu_mf.pla: 1273: //
; libsrc/fpu_mf.pla: 1274: // Secant: sec(x) = 1 / cos(x)
; libsrc/fpu_mf.pla: 1275: //
; libsrc/fpu_mf.pla: 1276: def sec
_P060 					; sec()
_C069 					; sec()
; libsrc/fpu_mf.pla: 1277:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1278: 
; libsrc/fpu_mf.pla: 1279:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1280:     
; libsrc/fpu_mf.pla: 1281:         return -1
	!BYTE	$68			; LAB	_D119+0
_F610 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B131
	!WORD	_B131-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1282:     fin
_B131 
_B132 
; libsrc/fpu_mf.pla: 1283: 
; libsrc/fpu_mf.pla: 1284:     // Compute cos(x)
; libsrc/fpu_mf.pla: 1285:     err = execUnaryOp(MF_CMD_FCOS)
; libsrc/fpu_mf.pla: 1286:     if err; return err; fin
	!BYTE	$2A,$34			; CB	52
	!BYTE	$54			; CALL	_C033
_F611 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B133
	!WORD	_B133-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B133 
_B134 
; libsrc/fpu_mf.pla: 1287: 
; libsrc/fpu_mf.pla: 1288:     // Compute 1 / cos(x)
; libsrc/fpu_mf.pla: 1289:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1290:     swap
; libsrc/fpu_mf.pla: 1291:     return div
	!BYTE	$6A			; LAW	_D118+2
_F612 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F613 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F614 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F615 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F616 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1292: end
; libsrc/fpu_mf.pla: 1293: 
; libsrc/fpu_mf.pla: 1294: //
; libsrc/fpu_mf.pla: 1295: // Cosecant: csc(x) = 1 / sin(x)
; libsrc/fpu_mf.pla: 1296: //
; libsrc/fpu_mf.pla: 1297: def csc
_P061 					; csc()
_C070 					; csc()
; libsrc/fpu_mf.pla: 1298:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1299: 
; libsrc/fpu_mf.pla: 1300:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1301:     
; libsrc/fpu_mf.pla: 1302:         return -1
	!BYTE	$68			; LAB	_D119+0
_F617 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B135
	!WORD	_B135-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1303:     fin
_B135 
_B136 
; libsrc/fpu_mf.pla: 1304: 
; libsrc/fpu_mf.pla: 1305: 
; libsrc/fpu_mf.pla: 1306:     // Compute sin(x)
; libsrc/fpu_mf.pla: 1307:     err = execUnaryOp(MF_CMD_FSIN)
; libsrc/fpu_mf.pla: 1308:     if err; return err; fin
	!BYTE	$2A,$33			; CB	51
	!BYTE	$54			; CALL	_C033
_F618 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B137
	!WORD	_B137-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B137 
_B138 
; libsrc/fpu_mf.pla: 1309: 
; libsrc/fpu_mf.pla: 1310:     // Compute 1 / sin(x)
; libsrc/fpu_mf.pla: 1311:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1312:     swap
; libsrc/fpu_mf.pla: 1313:     return div
	!BYTE	$6A			; LAW	_D118+2
_F619 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F620 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F621 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F622 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F623 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1314: end
; libsrc/fpu_mf.pla: 1315: 
; libsrc/fpu_mf.pla: 1316: //
; libsrc/fpu_mf.pla: 1317: // Cotangent: cot(x) = 1 / tan(x)
; libsrc/fpu_mf.pla: 1318: //
; libsrc/fpu_mf.pla: 1319: def cot
_P062 					; cot()
_C071 					; cot()
; libsrc/fpu_mf.pla: 1320:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1321: 
; libsrc/fpu_mf.pla: 1322:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1323:     
; libsrc/fpu_mf.pla: 1324:         return -1
	!BYTE	$68			; LAB	_D119+0
_F624 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B139
	!WORD	_B139-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1325:     fin
_B139 
_B140 
; libsrc/fpu_mf.pla: 1326: 
; libsrc/fpu_mf.pla: 1327:     // Compute tan(x)
; libsrc/fpu_mf.pla: 1328:     err = execUnaryOp(MF_CMD_FTAN)
; libsrc/fpu_mf.pla: 1329:     if err; return err; fin
	!BYTE	$2A,$35			; CB	53
	!BYTE	$54			; CALL	_C033
_F625 	!WORD	_C033		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B141
	!WORD	_B141-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
_B141 
_B142 
; libsrc/fpu_mf.pla: 1330: 
; libsrc/fpu_mf.pla: 1331:     // Compute 1 / tan(x)
; libsrc/fpu_mf.pla: 1332:     memcpy(stackRegs[1], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1333:     swap
; libsrc/fpu_mf.pla: 1334:     return div
	!BYTE	$6A			; LAW	_D118+2
_F626 	!WORD	_D118+2		
	!BYTE	$26			; LA	_D114+0
_F627 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F628 	!WORD	0		
	!BYTE	$54			; CALL	_C008
_F629 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F630 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1335: end
; libsrc/fpu_mf.pla: 1336: 
; libsrc/fpu_mf.pla: 1337: //==============================================================================
; libsrc/fpu_mf.pla: 1338: // FINANCIAL FUNCTIONS (Hardware accelerated via powXY)
; libsrc/fpu_mf.pla: 1339: //==============================================================================
; libsrc/fpu_mf.pla: 1340: 
; libsrc/fpu_mf.pla: 1341: def compXY
_P074 					; compXY()
_C072 					; compXY()
; libsrc/fpu_mf.pla: 1342:     // compXY(rate, periods) = (1 + rate)^periods
; libsrc/fpu_mf.pla: 1343:     // Hardware accelerated via powXY
; libsrc/fpu_mf.pla: 1344:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1345: 
; libsrc/fpu_mf.pla: 1346:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1347:     
; libsrc/fpu_mf.pla: 1348:         sane:saveZP()
; libsrc/fpu_mf.pla: 1349:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOCOMPND, stackRegs[0], stackRegs[1]))))
	!BYTE	$68			; LAB	_D119+0
_F631 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B143
	!WORD	_B143-*
	!BYTE	$6A			; LAW	_X028+18
_F632 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$14			; CB	20
	!BYTE	$6A			; LAW	_D118+0
_F633 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F634 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F635 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F636 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F637 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F638 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1350:     fin
_B143 
_B144 
; libsrc/fpu_mf.pla: 1351: 
; libsrc/fpu_mf.pla: 1352:     // Stack: periods (top), rate (second)
; libsrc/fpu_mf.pla: 1353:     // Need to compute: (1 + rate)^periods
; libsrc/fpu_mf.pla: 1354: 
; libsrc/fpu_mf.pla: 1355:     // Push 1.0, then add to rate
; libsrc/fpu_mf.pla: 1356:     memcpy(stackRegs[2], @ext_one, t_extended)  // Push 1.0
; libsrc/fpu_mf.pla: 1357:     memcpy(stackRegs[3], stackRegs[1], t_extended)  // Copy rate
; libsrc/fpu_mf.pla: 1358:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[2], stackRegs[3], stackRegs[0], stackRegs[1]
; libsrc/fpu_mf.pla: 1359: 
; libsrc/fpu_mf.pla: 1360:     // Stack now: rate, 1.0, periods, (old)
; libsrc/fpu_mf.pla: 1361:     err = add  // Compute 1 + rate
; libsrc/fpu_mf.pla: 1362:     if err < 0
; libsrc/fpu_mf.pla: 1363:         _drop(0)
; libsrc/fpu_mf.pla: 1364:     
; libsrc/fpu_mf.pla: 1365:         sane:saveZP()
; libsrc/fpu_mf.pla: 1366:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOCOMPND, stackRegs[0], stackRegs[1]))))
	!BYTE	$6A			; LAW	_D118+4
_F639 	!WORD	_D118+4		
	!BYTE	$26			; LA	_D114+0
_F640 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F641 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+6
_F642 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+2
_F643 	!WORD	_D118+2		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F644 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+4
_F645 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+6
_F646 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+0
_F647 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F648 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+6
_F649 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F650 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F651 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F652 	!WORD	_D118+0		
	!BYTE	$54			; CALL	_C034
_F653 	!WORD	_C034		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B145
	!WORD	_B145-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F654 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F655 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$14			; CB	20
	!BYTE	$6A			; LAW	_D118+0
_F656 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F657 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F658 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F659 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F660 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F661 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1367:     fin
_B145 
_B146 
; libsrc/fpu_mf.pla: 1368: 
; libsrc/fpu_mf.pla: 1369:     // Stack now: (1+rate), periods, ...
; libsrc/fpu_mf.pla: 1370:     // Swap to get periods on top for powXY
; libsrc/fpu_mf.pla: 1371:     swap
; libsrc/fpu_mf.pla: 1372: 
; libsrc/fpu_mf.pla: 1373:     // Stack now: periods, (1+rate), ...
; libsrc/fpu_mf.pla: 1374:     // Call powXY to compute (1+rate)^periods
; libsrc/fpu_mf.pla: 1375:     return powXY
	!BYTE	$54			; CALL	_C008
_F662 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C063
_F663 	!WORD	_C063		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1376: end
; libsrc/fpu_mf.pla: 1377: 
; libsrc/fpu_mf.pla: 1378: def annuityXY
_P075 					; annuityXY()
_C073 					; annuityXY()
; libsrc/fpu_mf.pla: 1379:     // annuityXY(rate, periods) = (1 - (1+rate)^-periods) / rate
; libsrc/fpu_mf.pla: 1380:     // Hardware accelerated via powXY
; libsrc/fpu_mf.pla: 1381:     word err
					; err -> [0]
; libsrc/fpu_mf.pla: 1382: 
; libsrc/fpu_mf.pla: 1383:     if !mfAvailable
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/fpu_mf.pla: 1384:     
; libsrc/fpu_mf.pla: 1385:         sane:saveZP()
; libsrc/fpu_mf.pla: 1386:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOANNUIT, stackRegs[0], stackRegs[1]))))
	!BYTE	$68			; LAB	_D119+0
_F664 	!WORD	_D119+0		
	!BYTE	$4E			; BRTRU	_B147
	!WORD	_B147-*
	!BYTE	$6A			; LAW	_X028+18
_F665 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F666 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F667 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F668 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F669 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F670 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F671 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1387:     fin
_B147 
_B148 
; libsrc/fpu_mf.pla: 1388: 
; libsrc/fpu_mf.pla: 1389:     // Stack: periods (top), rate (second)
; libsrc/fpu_mf.pla: 1390:     // Need: (1 - (1+rate)^-periods) / rate
; libsrc/fpu_mf.pla: 1391: 
; libsrc/fpu_mf.pla: 1392:     // Save rate for later division
; libsrc/fpu_mf.pla: 1393:     memcpy(stackRegs[2], stackRegs[1], t_extended)  // Copy rate to stack[2]
; libsrc/fpu_mf.pla: 1394: 
; libsrc/fpu_mf.pla: 1395:     // Negate periods: -periods
; libsrc/fpu_mf.pla: 1396:     err = neg
; libsrc/fpu_mf.pla: 1397:     if err < 0
; libsrc/fpu_mf.pla: 1398:         _drop(0)
; libsrc/fpu_mf.pla: 1399:     
; libsrc/fpu_mf.pla: 1400:         sane:saveZP()
; libsrc/fpu_mf.pla: 1401:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOANNUIT, stackRegs[0], stackRegs[1]))))
	!BYTE	$6A			; LAW	_D118+4
_F672 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+2
_F673 	!WORD	_D118+2		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F674 	!WORD	0		
	!BYTE	$54			; CALL	_C039
_F675 	!WORD	_C039		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B149
	!WORD	_B149-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F676 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F677 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F678 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F679 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F680 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F681 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F682 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F683 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1402:     fin
_B149 
_B150 
; libsrc/fpu_mf.pla: 1403: 
; libsrc/fpu_mf.pla: 1404:     // Stack now: -periods, rate, rate, ...
; libsrc/fpu_mf.pla: 1405:     // Compute (1 + rate)
; libsrc/fpu_mf.pla: 1406:     memcpy(stackRegs[3], @ext_one, t_extended)  // Push 1.0
; libsrc/fpu_mf.pla: 1407:     stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[1], stackRegs[0], stackRegs[2]
; libsrc/fpu_mf.pla: 1408:     // Stack: 1.0, rate, -periods, rate
; libsrc/fpu_mf.pla: 1409: 
; libsrc/fpu_mf.pla: 1410:     err = add  // 1 + rate
; libsrc/fpu_mf.pla: 1411:     if err < 0
; libsrc/fpu_mf.pla: 1412:         _drop(0); _drop(0)
; libsrc/fpu_mf.pla: 1413:     
; libsrc/fpu_mf.pla: 1414:         sane:saveZP()
; libsrc/fpu_mf.pla: 1415:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOANNUIT, stackRegs[0], stackRegs[1]))))
	!BYTE	$6A			; LAW	_D118+6
_F684 	!WORD	_D118+6		
	!BYTE	$26			; LA	_D114+0
_F685 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F686 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+6
_F687 	!WORD	_D118+6		
	!BYTE	$6A			; LAW	_D118+2
_F688 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_D118+0
_F689 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+4
_F690 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+6
_F691 	!WORD	_D118+6		
	!BYTE	$7A			; SAW	_D118+4
_F692 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F693 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F694 	!WORD	_D118+0		
	!BYTE	$54			; CALL	_C034
_F695 	!WORD	_C034		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B151
	!WORD	_B151-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F696 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F697 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F698 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F699 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F700 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F701 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F702 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F703 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F704 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1416:     fin
_B151 
_B152 
; libsrc/fpu_mf.pla: 1417: 
; libsrc/fpu_mf.pla: 1418:     // Stack: (1+rate), -periods, rate, ...
; libsrc/fpu_mf.pla: 1419:     swap  // Stack: -periods, (1+rate), rate, ...
; libsrc/fpu_mf.pla: 1420: 
; libsrc/fpu_mf.pla: 1421:     err = powXY  // (1+rate)^-periods
; libsrc/fpu_mf.pla: 1422:     if err < 0
; libsrc/fpu_mf.pla: 1423:         _drop(0)
; libsrc/fpu_mf.pla: 1424:     
; libsrc/fpu_mf.pla: 1425:         sane:saveZP()
; libsrc/fpu_mf.pla: 1426:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOANNUIT, stackRegs[0], stackRegs[1]))))
	!BYTE	$54			; CALL	_C008
_F705 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C063
_F706 	!WORD	_C063		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B153
	!WORD	_B153-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F707 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F708 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F709 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F710 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F711 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F712 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F713 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F714 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1427:     fin
_B153 
_B154 
; libsrc/fpu_mf.pla: 1428: 
; libsrc/fpu_mf.pla: 1429:     // Stack: (1+rate)^-periods, rate, ...
; libsrc/fpu_mf.pla: 1430:     // Compute 1 - (1+rate)^-periods
; libsrc/fpu_mf.pla: 1431:     memcpy(stackRegs[2], @ext_one, t_extended)
; libsrc/fpu_mf.pla: 1432:     stackRegs[0], stackRegs[1], stackRegs[2] = stackRegs[2], stackRegs[0], stackRegs[1]
; libsrc/fpu_mf.pla: 1433:     // Stack: 1.0, (1+rate)^-periods, rate, ...
; libsrc/fpu_mf.pla: 1434: 
; libsrc/fpu_mf.pla: 1435:     err = sub  // 1 - (1+rate)^-periods
; libsrc/fpu_mf.pla: 1436:     if err < 0
; libsrc/fpu_mf.pla: 1437:         _drop(0)
; libsrc/fpu_mf.pla: 1438:     
; libsrc/fpu_mf.pla: 1439:         sane:saveZP()
; libsrc/fpu_mf.pla: 1440:         return sane:restoreZP(_drop(_swap(sane:op2ELEM(FFEXT|FOANNUIT, stackRegs[0], stackRegs[1]))))
	!BYTE	$6A			; LAW	_D118+4
_F715 	!WORD	_D118+4		
	!BYTE	$26			; LA	_D114+0
_F716 	!WORD	_D114+0		
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F717 	!WORD	0		
	!BYTE	$6A			; LAW	_D118+4
_F718 	!WORD	_D118+4		
	!BYTE	$6A			; LAW	_D118+0
_F719 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F720 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+4
_F721 	!WORD	_D118+4		
	!BYTE	$7A			; SAW	_D118+2
_F722 	!WORD	_D118+2		
	!BYTE	$7A			; SAW	_D118+0
_F723 	!WORD	_D118+0		
	!BYTE	$54			; CALL	_C035
_F724 	!WORD	_C035		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B155
	!WORD	_B155-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F725 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_X028+18
_F726 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$16			; CB	22
	!BYTE	$6A			; LAW	_D118+0
_F727 	!WORD	_D118+0		
	!BYTE	$6A			; LAW	_D118+2
_F728 	!WORD	_D118+2		
	!BYTE	$6A			; LAW	_X028+14
_F729 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C009
_F730 	!WORD	_C009		
	!BYTE	$54			; CALL	_C007
_F731 	!WORD	_C007		
	!BYTE	$6A			; LAW	_X028+20
_F732 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1441:     fin
_B155 
_B156 
; libsrc/fpu_mf.pla: 1442: 
; libsrc/fpu_mf.pla: 1443:     // Stack: (1-(1+rate)^-periods), rate, ...
; libsrc/fpu_mf.pla: 1444:     // Divide by rate
; libsrc/fpu_mf.pla: 1445:     swap
; libsrc/fpu_mf.pla: 1446:     return div
	!BYTE	$54			; CALL	_C008
_F733 	!WORD	_C008		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C037
_F734 	!WORD	_C037		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1447: end
; libsrc/fpu_mf.pla: 1448: 
; libsrc/fpu_mf.pla: 1449: //==============================================================================
; libsrc/fpu_mf.pla: 1450: // RANDOM NUMBER GENERATION (SANE fallback)
; libsrc/fpu_mf.pla: 1451: //==============================================================================
; libsrc/fpu_mf.pla: 1452: 
; libsrc/fpu_mf.pla: 1453: def randNum(pSeed)
					; pSeed -> [0]
_P076 					; randNum(pSeed)()
_C074 					; randNum()
; libsrc/fpu_mf.pla: 1454: 
; libsrc/fpu_mf.pla: 1455:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1456:     return sane:restoreZP(sane:op1ELEM(FFEXT|FORANDX, pSeed))
	!BYTE	$6A			; LAW	_X028+18
_F735 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$20			; CB	32
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+12
_F736 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F737 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1457: end
; libsrc/fpu_mf.pla: 1458: 
; libsrc/fpu_mf.pla: 1459: //==============================================================================
; libsrc/fpu_mf.pla: 1460: // ENVIRONMENT AND CONSTANTS
; libsrc/fpu_mf.pla: 1461: //==============================================================================
; libsrc/fpu_mf.pla: 1462: 
; libsrc/fpu_mf.pla: 1463: def setEnv(env)
					; env -> [0]
_P002 					; setEnv(env)()
_C075 					; setEnv()
; libsrc/fpu_mf.pla: 1464:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1465:     return sane:restoreZP(sane:op1FP(FOSETENV, env))
	!BYTE	$6A			; LAW	_X028+18
_F738 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+6
_F739 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F740 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1466: end
; libsrc/fpu_mf.pla: 1467: 
; libsrc/fpu_mf.pla: 1468: def getEnv
_P001 					; getEnv()
_C076 					; getEnv()
; libsrc/fpu_mf.pla: 1469:     sane:saveZP()
; libsrc/fpu_mf.pla: 1470:     return sane:restoreZP(sane:op0FP(FOGETENV))
	!BYTE	$6A			; LAW	_X028+18
_F741 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X028+4
_F742 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F743 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 1471: end
; libsrc/fpu_mf.pla: 1472: 
; libsrc/fpu_mf.pla: 1473: def testExcept(except)
					; except -> [0]
_P003 					; testExcept(except)()
_C077 					; testExcept()
; libsrc/fpu_mf.pla: 1474:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1475:     return sane:restoreZP(sane:op1FP(FOTESTXCP, except))
	!BYTE	$6A			; LAW	_X028+18
_F744 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$1B			; CB	27
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+6
_F745 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F746 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1476: end
; libsrc/fpu_mf.pla: 1477: 
; libsrc/fpu_mf.pla: 1478: def setExcept(except)
					; except -> [0]
_P004 					; setExcept(except)()
_C078 					; setExcept()
; libsrc/fpu_mf.pla: 1479:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1480:     return sane:restoreZP(sane:op1FP(FOSETXCP, except))
	!BYTE	$6A			; LAW	_X028+18
_F747 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$15			; CB	21
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+6
_F748 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F749 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1481: end
; libsrc/fpu_mf.pla: 1482: 
; libsrc/fpu_mf.pla: 1483: def enterProc(pEnv)
					; pEnv -> [0]
_P005 					; enterProc(pEnv)()
_C079 					; enterProc()
; libsrc/fpu_mf.pla: 1484:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1485:     return sane:restoreZP(sane:op1FP(FOPROCENTRY, pEnv))
	!BYTE	$6A			; LAW	_X028+18
_F750 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$17			; CB	23
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+6
_F751 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F752 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1486: end
; libsrc/fpu_mf.pla: 1487: 
; libsrc/fpu_mf.pla: 1488: def exitProc(env)
					; env -> [0]
_P006 					; exitProc(env)()
_C080 					; exitProc()
; libsrc/fpu_mf.pla: 1489: 
; libsrc/fpu_mf.pla: 1490:     sane:saveZP()
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/fpu_mf.pla: 1491:     return sane:restoreZP(sane:op1FP(FOPROCEXIT, env))
	!BYTE	$6A			; LAW	_X028+18
_F753 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$19			; CB	25
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X028+6
_F754 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_X028+20
_F755 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/fpu_mf.pla: 1492: end
; libsrc/fpu_mf.pla: 1493: 
; libsrc/fpu_mf.pla: 1494: def constPi
_P007 					; constPi()
_C081 					; constPi()
; libsrc/fpu_mf.pla: 1495:     return pushExt(@ext_pi)
	!BYTE	$26			; LA	_D111+0
_F756 	!WORD	_D111+0		
	!BYTE	$54			; CALL	_C024
_F757 	!WORD	_C024		
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 1496: end
; libsrc/fpu_mf.pla: 1497: 
; libsrc/fpu_mf.pla: 1498: def constE
_P008 					; constE()
_C082 					; constE()
; libsrc/fpu_mf.pla: 1499:     return pushExt(@ext_e)
	!BYTE	$26			; LA	_D112+0
_F758 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C024
_F759 	!WORD	_C024		
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 1500: end
; libsrc/fpu_mf.pla: 1501: 
; libsrc/fpu_mf.pla: 1502: //==============================================================================
; libsrc/fpu_mf.pla: 1503: // INITIALIZATION
; libsrc/fpu_mf.pla: 1504: //==============================================================================
; libsrc/fpu_mf.pla: 1505: 
; libsrc/fpu_mf.pla: 1506: def reset
_P000 					; reset()
_C083 					; reset()
; libsrc/fpu_mf.pla: 1507:     byte i
					; i -> [0]
; libsrc/fpu_mf.pla: 1508:     word zero
					; zero -> [1]
; libsrc/fpu_mf.pla: 1509: 
; libsrc/fpu_mf.pla: 1510:     zero = 0
	!BYTE	$58,$03,$00		; ENTER	3,0
; libsrc/fpu_mf.pla: 1511: 
; libsrc/fpu_mf.pla: 1512:     if sane:initFP() < 0; return -1; fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$01			; SLW	[1]
	!BYTE	$6A			; LAW	_X028+0
_F760 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B157
	!WORD	_B157-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$03			; LEAVE	3
_B157 
_B158 
; libsrc/fpu_mf.pla: 1513:     sane:saveZP()
; libsrc/fpu_mf.pla: 1514: 
; libsrc/fpu_mf.pla: 1515:     // Detect MegaFlash hardware
; libsrc/fpu_mf.pla: 1516:     mfAvailable = detectMegaFlash
; libsrc/fpu_mf.pla: 1517: 
; libsrc/fpu_mf.pla: 1518:     if mfAvailable
; libsrc/fpu_mf.pla: 1519:         puts("MegaFlash FPU detected - hardware acceleration enabled\n")
	!BYTE	$6A			; LAW	_X028+18
_F761 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C000
_F762 	!WORD	_C000		
	!BYTE	$7C			; DAB	_D119+0
_F763 	!WORD	_D119+0		
	!BYTE	$4C			; BRFLS	_B159
	!WORD	_B159-*
	!BYTE	$2E			; CS
	!BYTE	$37
	!BYTE	$4D,$65,$67,$61,$46,$6C,$61,$73
	!BYTE	$68,$20,$46,$50,$55,$20,$64,$65
	!BYTE	$74,$65,$63,$74,$65,$64,$20,$2D
	!BYTE	$20,$68,$61,$72,$64,$77,$61,$72
	!BYTE	$65,$20,$61,$63,$63,$65,$6C,$65
	!BYTE	$72,$61,$74,$69,$6F,$6E,$20,$65
	!BYTE	$6E,$61,$62,$6C,$65,$64,$0D
	!BYTE	$54			; CALL	_X004
_F764 	!WORD	0		
; libsrc/fpu_mf.pla: 1520:     else
	!BYTE	$50			; BRNCH	_B160
	!WORD	_B160-*
_B159 
; libsrc/fpu_mf.pla: 1521:         puts("MegaFlash FPU not found - using SANE software floating point\n")
	!BYTE	$2E			; CS
	!BYTE	$3D
	!BYTE	$4D,$65,$67,$61,$46,$6C,$61,$73
	!BYTE	$68,$20,$46,$50,$55,$20,$6E,$6F
	!BYTE	$74,$20,$66,$6F,$75,$6E,$64,$20
	!BYTE	$2D,$20,$75,$73,$69,$6E,$67,$20
	!BYTE	$53,$41,$4E,$45,$20,$73,$6F,$66
	!BYTE	$74,$77,$61,$72,$65,$20,$66,$6C
	!BYTE	$6F,$61,$74,$69,$6E,$67,$20,$70
	!BYTE	$6F,$69,$6E,$74,$0D
	!BYTE	$54			; CALL	_X004
_F765 	!WORD	0		
; libsrc/fpu_mf.pla: 1522:     fin
_B160 
; libsrc/fpu_mf.pla: 1523: 
; libsrc/fpu_mf.pla: 1524:     // Initialize stack registers
; libsrc/fpu_mf.pla: 1525:     for i = 0 to 3
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B162 
	!BYTE	$6C,$00			; DLB	[0]
; libsrc/fpu_mf.pla: 1526:         stackRegs[i] = @stack[i * t_extended]
; libsrc/fpu_mf.pla: 1527:         sane:op2FP(FFINT|FOZ2X, stackRegs[i], @zero)
; libsrc/fpu_mf.pla: 1528:         loadInt(@zero, i)
; libsrc/fpu_mf.pla: 1529:     next
	!BYTE	$26			; LA	_D117+0
_F766 	!WORD	_D117+0		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$26			; LA	_D118+0
_F767 	!WORD	_D118+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$72			; SW
	!BYTE	$2C,$0E,$04		; CW	1038
	!BYTE	$26			; LA	_D118+0
_F768 	!WORD	_D118+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_X028+8
_F769 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_C014
_F770 	!WORD	_C014		
	!BYTE	$30			; DROP 
_B163 
	!BYTE	$A4			; INCBRLE	_B162
	!WORD	_B162-*
_B161 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; libsrc/fpu_mf.pla: 1530: 
; libsrc/fpu_mf.pla: 1531:     return sane:restoreZP(0)
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X028+20
_F771 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$5A,$03			; LEAVE	3
; libsrc/fpu_mf.pla: 1532: end
; libsrc/fpu_mf.pla: 1533: 
; libsrc/fpu_mf.pla: 1534: //
; libsrc/fpu_mf.pla: 1535: // Keep module in memory
; libsrc/fpu_mf.pla: 1536: //
; libsrc/fpu_mf.pla: 1537: return modkeep
_INIT 
	!BYTE	$2C,$00,$20		; CW	8192
	!BYTE	$5C			; RET
; libsrc/fpu_mf.pla: 1538: done
_SYSFLAGS	=	0
_DEFCNT	=	85
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C050		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C051		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C052		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C053		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C054		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C055		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C056		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C057		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C058		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C059		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C060		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C061		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C062		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C063		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C064		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C065		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C066		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C067		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C068		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C069		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C070		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C071		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C072		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C073		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C074		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C075		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C076		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C077		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C078		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C079		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C080		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C081		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C082		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C083		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F361-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F363-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F364-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F365-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F367-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F368-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F369-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F370-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F372-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F373-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F375-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F376-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F377-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F378-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F379-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F382-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F384-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F385-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F386-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F388-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F389-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F390-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F391-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F393-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F395-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F396-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F398-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F400-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F401-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F402-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F403-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F404-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F405-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F406-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F407-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F408-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F410-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F411-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F413-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F414-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F415-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F418-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F420-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F421-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F422-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F423-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F425-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F426-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F429-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F430-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F431-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F432-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F433-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F434-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F435-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F436-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F438-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F440-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F441-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F442-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F443-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F444-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F446-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F448-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F449-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F451-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F452-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F453-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F456-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F458-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F460-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F461-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F464-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F465-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F466-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F467-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F468-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F469-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F470-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F473-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F475-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F477-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F478-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F479-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F482-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F483-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F485-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F487-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F488-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F489-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F490-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F491-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F492-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F493-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F495-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F496-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F497-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F498-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F501-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F504-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F505-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F506-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F507-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F510-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F513-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F515-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F516-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F517-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F518-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F519-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F520-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F521-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F522-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F523-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F525-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F526-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F527-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F528-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F529-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F530-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F532-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F533-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F534-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F535-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F538-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F540-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F541-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F543-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F544-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F545-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F546-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F547-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F548-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F549-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F552-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F561-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F562-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F563-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F564-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F565-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F568-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F569-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F570-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F571-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F572-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F573-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F574-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F578-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F579-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F580-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F581-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F582-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F583-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F586-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F587-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F588-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F589-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F590-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F591-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F592-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F593-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F594-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F595-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F596-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F597-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F598-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F599-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F600-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F601-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F602-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F603-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F604-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F605-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F606-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F607-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F608-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F609-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F610-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F611-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F612-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F613-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F614-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F615-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F616-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F617-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F618-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F619-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F620-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F621-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F622-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F623-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F624-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F625-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F626-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F627-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F628-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F629-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F630-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F631-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F632-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F633-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F634-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F635-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F636-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F637-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F638-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F639-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F640-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F641-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F642-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F643-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F644-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F645-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F646-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F647-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F648-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F649-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F650-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F651-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F652-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F653-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F654-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F655-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F656-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F657-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F658-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F659-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F660-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F661-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F662-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F663-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F664-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F665-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F666-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F667-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F668-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F669-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F670-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F671-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F672-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F673-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F674-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F675-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F676-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F677-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F678-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F679-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F680-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F681-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F682-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F683-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F684-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F685-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F686-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F687-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F688-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F689-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F690-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F691-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F692-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F693-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F694-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F695-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F696-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F697-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F698-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F699-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F700-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F701-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F702-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F703-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F704-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F705-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F706-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F707-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F708-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F709-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F710-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F711-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F712-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F713-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F714-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F715-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F716-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F717-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F718-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F719-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F720-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F721-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F722-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F723-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F724-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F725-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F726-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F727-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F728-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F729-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F730-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F731-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F732-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F733-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F734-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F735-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F736-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F737-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F738-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F739-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F740-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F741-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F742-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F743-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F744-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F745-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F746-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F747-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F748-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F749-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F750-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F751-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F752-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F753-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F754-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F755-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F756-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F757-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F758-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F759-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F760-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F761-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F762-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F763-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F764-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F765-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F766-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F767-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F768-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F769-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F770-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F771-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: SANE
	!BYTE	$D3,$C1,$CE,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: STR2EXT
	!BYTE	$D3,$D4,$D2,$B2,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: EXT2STR
	!BYTE	$C5,$D8,$D4,$B2,$D3,$D4,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	!BYTE	$00			; END OF ESD
